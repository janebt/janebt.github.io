<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[HTML5总结]]></title>
      <url>/2017/11/01/HTML5%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>这篇文章介绍H5的概念和考察方法。</p>
<p>后续补上demo。</p>
<a id="more"></a>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><blockquote>
<p>提纲参考<a href="http://www.w3school.com.cn/html5/html_5_serversentevents.asp" target="_blank" rel="external">W3</a></p>
</blockquote>
<ul>
<li>HTML5概念</li>
<li>多媒体</li>
<li>拖放</li>
<li>Canvas &amp; SVG</li>
<li>地理定位</li>
<li>Web存储</li>
<li>应用缓存</li>
<li>Web Workers</li>
<li>服务器发送事件</li>
<li>表单</li>
<li>Hisyory API</li>
</ul>
<h1 id="HTML5概念"><a href="#HTML5概念" class="headerlink" title="HTML5概念"></a>HTML5概念</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是HTML5？"><a href="#什么是HTML5？" class="headerlink" title="什么是HTML5？"></a>什么是HTML5？</h3><p>HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件</p>
<h3 id="SGML和HTML，XML和HTML的之间有什么关系？"><a href="#SGML和HTML，XML和HTML的之间有什么关系？" class="headerlink" title="SGML和HTML，XML和HTML的之间有什么关系？"></a>SGML和HTML，XML和HTML的之间有什么关系？</h3><p>SGML（标准通用标记语言）是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML（超文本标记语言）是被用SGML描述的标记语言。</p>
<p>因此利用SGML创建了HTML参照和必须共同遵守的DTD（文档类型定义），你会经常在HTML页面的头部发现“DOCTYPE”属性，用来定义用于解析目标DTD</p>
<p>XML（可扩展标记语言）使用了SGML，例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。</p>
<p>XHTML创建于XML，他被使用在HTML4.0中。</p>
<p>总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML</p>
<h3 id="为什么HTML5里面我们不需要DTD？"><a href="#为什么HTML5里面我们不需要DTD？" class="headerlink" title="为什么HTML5里面我们不需要DTD？"></a>为什么HTML5里面我们不需要DTD？</h3><p>HTML5没有使用SGML或者XHTML，他是一个全新的东西，因此你不需要参考DTD（Document Type Definition文档类型定义），对于HTML5，你仅需放置下面的文档类型代码告诉浏览器识别这是HTML5文档</p>
<h3 id="HTML5的页面结构同HTML4或者更前的HTML有什么区别？"><a href="#HTML5的页面结构同HTML4或者更前的HTML有什么区别？" class="headerlink" title="HTML5的页面结构同HTML4或者更前的HTML有什么区别？"></a>HTML5的页面结构同HTML4或者更前的HTML有什么区别？</h3><p>一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。现在如果我们想在在HTML4的HTML区域中呈现这些内容，我们可能要使用DIV标签。</p>
<p>但是在HTML5中通过为这些区域创建元素名称使他们更加清晰，也使得你的HTML更加可读</p>
<ul>
<li><code>&lt;header&gt;</code>：代表HTML的头部数据</li>
<li><code>&lt;footer&gt;</code>：页面的脚部区域</li>
<li><code>&lt;nav&gt;</code>：页面导航元素</li>
<li><code>&lt;article&gt;</code>：自包含的内容</li>
<li><code>&lt;section&gt;</code>：使用内部article去定义区域或者把分组内容放到区域里</li>
<li><code>&lt;aside&gt;</code>：代表页面的侧边栏内容</li>
</ul>
<h3 id="HTML5-文档类型和字符集是？"><a href="#HTML5-文档类型和字符集是？" class="headerlink" title="HTML5 文档类型和字符集是？"></a>HTML5 文档类型和字符集是？</h3><pre><code class="html">&lt;!doctype html&gt;
&lt;meta charset=”UTF-8″&gt;
</code></pre>
<h3 id="HTML5-废弃了哪些-HTML4-标签？"><a href="#HTML5-废弃了哪些-HTML4-标签？" class="headerlink" title="HTML5 废弃了哪些 HTML4 标签？"></a>HTML5 废弃了哪些 HTML4 标签？</h3><ul>
<li>frame</li>
<li>frameset</li>
<li>noframe</li>
<li>applet</li>
<li>big</li>
<li>center</li>
<li>basefront</li>
</ul>
<h3 id="HTML5-标准提供了哪些新的-API？"><a href="#HTML5-标准提供了哪些新的-API？" class="headerlink" title="HTML5 标准提供了哪些新的 API？"></a>HTML5 标准提供了哪些新的 API？</h3><p>HTML5 提供的应用程序 API 主要有：</p>
<ul>
<li>Media API</li>
<li>Text Track API</li>
<li>Application Cache API</li>
<li>User Interaction</li>
<li>Data Transfer API</li>
<li>Command API</li>
<li>Constraint Validation API</li>
<li>History API</li>
</ul>
<h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="嵌入音频？"><a href="#嵌入音频？" class="headerlink" title="嵌入音频？"></a>嵌入音频？</h3><pre><code class="html">&lt;audio controls&gt;
    &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt;
    Your browser does’nt support audio embedding feature.
&lt;/audio&gt;
</code></pre>
<h3 id="嵌入视频？"><a href="#嵌入视频？" class="headerlink" title="嵌入视频？"></a>嵌入视频？</h3><pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
  &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
   Your browser does’nt support video embedding feature.
&lt;/video&gt;
</code></pre>
<h3 id="除了-audio-和-video，HTML5-还有哪些媒体标签？"><a href="#除了-audio-和-video，HTML5-还有哪些媒体标签？" class="headerlink" title="除了 audio 和 video，HTML5 还有哪些媒体标签？"></a>除了 audio 和 video，HTML5 还有哪些媒体标签？</h3><p><embed> 标签定义嵌入的内容，比如插件。</p>
<pre><code class="html">&lt;embed type=”video/quicktime” src=”Fishing.mov”&gt;
</code></pre>
<p><source> 对于定义多个数据源很有用。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
&lt;/video&gt;
</code></pre>
<p><track> 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
     &lt;track kind=”subtitles” label=”English” src=”jamshed_en.vtt” srclang=”en” default&gt;&lt;/track&gt;
      &lt;track kind=”subtitles” label=”Arabic” src=”jamshed_ar.vtt” srclang=”ar”&gt;&lt;/track&gt;
&lt;/video&gt;
</code></pre>
<h1 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function allowDrop(ev)
{
  ev.preventDefault();
}

function drag(ev)
{
  ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
}

function drop(ev)
{
  ev.preventDefault();
  var data=ev.dataTransfer.getData(&quot;Text&quot;);
  ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>设置元素为可拖放 - draggable</strong></p>
<p>draggable 属性设置为 true </p>
<p><strong>拖动什么 - ondragstart 和 setData()</strong></p>
<p>ondragstart 属性调用了一个函数，drag(<em>event</em>)，它规定了被拖动的数据。</p>
<p>dataTransfer.setData() 方法设置被拖数据的数据类型和值</p>
<p><strong>放到何处 - ondragover</strong></p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<pre><code class="javascript">event.preventDefault()
</code></pre>
<p><strong>进行放置 - ondrop</strong></p>
<p>ondrop 属性调用了一个函数，drop(<em>event</em>)</p>
<h1 id="Canvas-amp-SVG"><a href="#Canvas-amp-SVG" class="headerlink" title="Canvas &amp; SVG"></a>Canvas &amp; SVG</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h3><h4 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h4><pre><code class="javascript">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;
  您的浏览器不支持canvas！
&lt;/canvas&gt;

var canvas = document.getElementById(&#39;myCanvas&#39;);
if (canvas.getContext) {
  var ctx = canvas.getContext(&#39;2d&#39;);
}

//（1）绘制路径
ctx.beginPath(); // 开始路径绘制
ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)
ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线
ctx.lineWidth = 1.0; // 设置线宽
ctx.strokeStyle = &#39;#CC0000&#39;; // 设置线的颜色
ctx.stroke(); // 进行线的着色，这时整条线才变得可见
//最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。

//（2）绘制矩形
//实心矩形
ctx.fillStyle = &#39;yellow&#39;;
ctx.fillRect(50, 50, 200, 100); 
//空心矩形
ctx.strokeRect(10,10,200,100);
//清除某个矩形区域的内容
ctx.clearRect(100,50,50,50);  

//（3）绘制文本
// 设置字体
ctx.font = &quot;Bold 20px Arial&quot;; 
// 设置对齐方式
ctx.textAlign = &quot;left&quot;;
// 设置填充颜色
ctx.fillStyle = &quot;#008600&quot;; 
// 设置字体内容，以及在画布上的位置,绘制文本,不支持文本断行
ctx.fillText(&quot;Hello!&quot;, 10, 50); 
// 绘制空心字
ctx.strokeText(&quot;Hello!&quot;, 10, 100); 

//（4）绘制圆形和扇形
//绘制扇形,startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
//绘制实心的圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.fillStyle = &quot;#000&quot;; 
ctx.fill();
//绘制空心圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.lineWidth = 1.0; 
ctx.strokeStyle = &quot;#000&quot;; 
ctx.stroke();

//（5）设置渐变色
var myGradient = ctx.createLinearGradient(0, 0, 0, 160); 
myGradient.addColorStop(0, &quot;#BABABA&quot;); 
myGradient.addColorStop(1, &quot;#636363&quot;);
//使用方法如下：
ctx.fillStyle = myGradient;
ctx.fillRect(10,10,200,100);

//（6）设置阴影
ctx.shadowOffsetX = 10; // 设置水平位移
ctx.shadowOffsetY = 10; // 设置垂直位移
ctx.shadowBlur = 5; // 设置模糊度
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色
ctx.fillStyle = &quot;#CC0000&quot;; 
ctx.fillRect(10,10,200,100)
</code></pre>
<h4 id="图像处理方法"><a href="#图像处理方法" class="headerlink" title="图像处理方法"></a>图像处理方法</h4><pre><code class="javascript">//drawImage方法:将图像文件插入画布,drawImage方法只能在图像完全载入后才能调用
var image = new Image();
image.onload = function() {
  var canvas = document.createElement(&#39;canvas&#39;);
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext(&#39;2d&#39;).drawImage(image, 0, 0);
  // 插入页面底部
  document.body.appendChild(image);
  return canvas;
}
image.src = &#39;image.png&#39;;

//getImageData方法，putImageData方法:读取Canvas的内容，返回一个对象，包含了每个像素的信息。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新绘制在Canvas上。
var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
context.putImageData(imageData, 0, 0);

//toDataURL方法:将Canvas数据重新转化成一般的图像文件形式。
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL(&#39;image/png&#39;);
  return image;
}

//save方法，restore方法:save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。
ctx.save();
ctx.fillStyle = &#39;#CC0000&#39;;
ctx.fillRect(10,10,150,100);
ctx.restore();
ctx.fillStyle = &#39;#000000&#39;;
ctx.fillRect(180,10,150,100);
</code></pre>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><a href="http://blog.csdn.net/gertyy/article/details/53637951" target="_blank" rel="external">Canvas API 详解</a></p>
<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是SVG？"><a href="#什么是SVG？" class="headerlink" title="什么是SVG？"></a>什么是SVG？</h3><p>SVG（Scalable Vector Graphics可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制，这使得他轻便，显示更加迅速</p>
<pre><code class="html">&lt;svg id=&quot;svgelem&quot; height=&quot;[object SVGAnimatedLength]&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
&lt;line style=&quot;stroke: rgb(255, 0, 0); stroke-width: 2px;&quot; y2=&quot;[object SVGAnimatedLength]&quot; x2=&quot;[object SVGAnimatedLength]&quot; y1=&quot;[object SVGAnimatedLength]&quot; x1=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/line&gt;
</code></pre>
<h3 id="Canvas是什么？"><a href="#Canvas是什么？" class="headerlink" title="Canvas是什么？"></a>Canvas是什么？</h3><p>Canvas是HTML中你可以绘制图形的区域</p>
<h3 id="如何使用Canvas来画一条简单的线？"><a href="#如何使用Canvas来画一条简单的线？" class="headerlink" title="如何使用Canvas来画一条简单的线？"></a>如何使用Canvas来画一条简单的线？</h3><ul>
<li>定义Canvas区域</li>
<li>获取访问canvas上下文区域</li>
<li>绘制图形</li>
</ul>
<pre><code class="javascript">&lt;body  onload=&quot;DrawMe();&quot;&gt;
&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;script&gt;
function DrawMe()
{
var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.moveTo(10,10);
ctx.lineTo(200,100);
ctx.stroke();
}
</code></pre>
<h3 id="如何使用Canvas和HTML5中的SVG去画一个矩形？"><a href="#如何使用Canvas和HTML5中的SVG去画一个矩形？" class="headerlink" title="如何使用Canvas和HTML5中的SVG去画一个矩形？"></a>如何使用Canvas和HTML5中的SVG去画一个矩形？</h3><pre><code class="javascript">HTML5使用SVG绘制矩形的代码
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;rect style=&quot;fill: rgb(0, 0, 255); stroke-width: 1px; stroke: rgb(0, 0, 0);&quot; height=&quot;[object SVGAnimatedLength]&quot; width=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/rect&gt;

HTML5使用Canvas绘制矩形的代码
var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.rect(20,20,150,100);
ctx.stroke();
</code></pre>
<h3 id="Canvas和SVG图形的区别是什么？"><a href="#Canvas和SVG图形的区别是什么？" class="headerlink" title="Canvas和SVG图形的区别是什么？"></a>Canvas和SVG图形的区别是什么？</h3><table>
<thead>
<tr>
<th>SVG</th>
<th>Canvas</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个就好像绘制和记忆，换句话说任何使用SVG绘制的形状都能被记忆和操作，浏览器可以再次显示</td>
<td>Canvas就像绘制和忘记，一旦绘制完成你不能访问像素和操作它</td>
</tr>
<tr>
<td>SVG对于创建图形例如CAD软件是良好的，一旦东西绘制，用户就想去操作它</td>
<td>Canvas在绘制和忘却的场景例如动画和游戏是良好的</td>
</tr>
<tr>
<td>因为为了之后的操作，需要记录坐标，所以比较缓慢</td>
<td>因为没有记住以后事情的意向，所以更快</td>
</tr>
<tr>
<td>我们可以用绘制对象的相关事件处理</td>
<td>我们不能使用绘制对象的相关事件处理，因为我们没有他们的参考</td>
</tr>
<tr>
<td>分辨率无关</td>
<td>分辨率相关</td>
</tr>
</tbody>
</table>
<h1 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a><a href="http://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="external">地理定位</a></h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>getCurrentPosition() 方法</p>
<pre><code>navigator.geolocation.getCurrentPosition(showPosition);
</code></pre><p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数</p>
<h1 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h1><h2 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h2><h3 id="localStorage的特点"><a href="#localStorage的特点" class="headerlink" title="localStorage的特点"></a>localStorage的特点</h3><ol>
<li>localStorage拓展了cookie的4K限制。</li>
</ol>
<ol>
<li><p>localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的。</p>
<p>注意：遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>
</li>
<li><p>localStorage只支持string类型的存储。</p>
</li>
</ol>
<h3 id="我们如何从本地存储中添加和移除数据？"><a href="#我们如何从本地存储中添加和移除数据？" class="headerlink" title="我们如何从本地存储中添加和移除数据？"></a>我们如何从本地存储中添加和移除数据？</h3><pre><code class="javascript">//添加
localStorage[&quot;a&quot;]=1;
localStorage.b=1;
localStorage.setItem(“c”,”India”);

//读取
var a = localStorage[&quot;a&quot;];
var b = localStorage.b;
var country = localStorage.getItem(“Key001”);

//改
localStorage[&quot;a&quot;]=2;

//删
localStorage.clear();    //全删
localStorage.removeItem(&quot;a&quot;);    //部分删

//获取键值
for(i=0;i&lt;localStorage.length;i++){
  var key=localStorage.key(i);
}
</code></pre>
<p>可以存JSON,注意<strong>stringify</strong> 和 <strong>parse</strong></p>
<pre><code class="javascript">var data={
  name:&#39;xiecanyong&#39;,
  sex:&#39;man&#39;,
  hobby:&#39;program&#39;
};

var d=JSON.stringify(data);

storage.setItem(&quot;data&quot;,d);

//将JSON字符串转换成为JSON对象输出
var json=storage.getItem(&quot;data&quot;);
var jsonObj=JSON.parse(json);
</code></pre>
<h3 id="本地存储和cookies之间的区别是什么？"><a href="#本地存储和cookies之间的区别是什么？" class="headerlink" title="本地存储和cookies之间的区别是什么？"></a>本地存储和cookies之间的区别是什么？</h3><table>
<thead>
<tr>
<th></th>
<th>Cookies</th>
<th>Local storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端/服务端</td>
<td>客户端和服务端都能访问数据。Cookie的数据通过每一个请求发送到服务端</td>
<td>只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器</td>
</tr>
<tr>
<td>大小</td>
<td>每个cookie有4095byte</td>
<td>每个域5MB</td>
</tr>
<tr>
<td>过期</td>
<td>Cookies有有效期，所以在过期之后cookie和cookie数据会被删除</td>
<td>没有过期数据，无论最后用户从浏览器删除或者使用Javascript程序删除，我们都需要删除</td>
</tr>
</tbody>
</table>
<h1 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a><a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">知识点</a></h2><h3 id="应用程序缓存优势"><a href="#应用程序缓存优势" class="headerlink" title="应用程序缓存优势"></a>应用程序缓存优势</h3><ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<h2 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h2><h3 id="HTML5中的应用缓存是什么？"><a href="#HTML5中的应用缓存是什么？" class="headerlink" title="HTML5中的应用缓存是什么？"></a>HTML5中的应用缓存是什么？</h3><p>应用缓存可以帮助你指定哪些文件需要缓存，哪些不需要。</p>
<h3 id="HTML5中我们如何实现应用缓存？"><a href="#HTML5中我们如何实现应用缓存？" class="headerlink" title="HTML5中我们如何实现应用缓存？"></a>HTML5中我们如何实现应用缓存？</h3><p>首先我们需要指定”manifest”文件，Mainfest文件的内容类型应是“text/cache-manifest”.</p>
<pre><code>CACHE MANIFEST
# version 1.0
CACHE :
Login.aspx
</code></pre><pre><code>Response.ContentType = &quot;text/cache-manifest&quot;;
Response.Write(&quot;CACHE MANIFEST \n&quot;);
Response.Write(&quot;# 2012-02-21 v1.0.0 \n&quot;);
Response.Write(&quot;CACHE : \n&quot;);
Response.Write(&quot;Login.aspx \n&quot;);
Response.Flush();
Response.End();
</code></pre><p>创建一个缓存manifest文件以后，接下来的事情实在HTML页面中提供mainfest连接</p>
<h3 id="应用缓存中的回退是什么？"><a href="#应用缓存中的回退是什么？" class="headerlink" title="应用缓存中的回退是什么？"></a>应用缓存中的回退是什么？</h3><p>应用缓存中的回退帮助你指定在服务器不可访问的时候，将会显示某文件。例如在下面的manifest文件中，我们说如果谁敲击了”/home”同时服务器不可到达的时候，”homeoffline.html”文件应送达</p>
<pre><code>FALLBACK:
/home/ /homeoffline.html
</code></pre><h3 id="应用缓存中的网络是什么？"><a href="#应用缓存中的网络是什么？" class="headerlink" title="应用缓存中的网络是什么？"></a>应用缓存中的网络是什么？</h3><p>网络命令描述不需要缓存的文件，例如以下代码中，我们说”home.aspx”永远都不应该被缓存或者离线访问。</p>
<pre><code>NETWORK:
home.aspx
</code></pre><h3 id="HTML5-应用程序缓存和浏览器缓存有什么区别？"><a href="#HTML5-应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="HTML5 应用程序缓存和浏览器缓存有什么区别？"></a>HTML5 应用程序缓存和浏览器缓存有什么区别？</h3><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p>
<h1 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h1><h2 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h2><h4 id="什么是Web-Workers？为什么我们需要他们？"><a href="#什么是Web-Workers？为什么我们需要他们？" class="headerlink" title="什么是Web Workers？为什么我们需要他们？"></a>什么是Web Workers？为什么我们需要他们？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p>
<p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>Web worker帮助我们用异步执行Javascript文件</p>
<h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>所有主流浏览器均支持 web worker，除了 Internet Explorer。</p>
<h4 id="Web-Worker线程的限制是什么？"><a href="#Web-Worker线程的限制是什么？" class="headerlink" title="Web Worker线程的限制是什么？"></a>Web Worker线程的限制是什么？</h4><p>Web worker线程不能修改HTML元素，全局变量和Window.Location一类的窗口属性。你可以自由使用Javascript数据类型，XMLHttpRequest调用等。</p>
<p>简而言之，就是<strong>允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</strong>。</p>
<p>原因：worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做<strong>WorkerGlobalScope</strong>的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><pre><code class="javascript">if(typeof(Worker)!==&quot;undefined&quot;)
{
  // Yes! Web worker support!
  // Some code.....
}
else
{
  // Sorry! No Web Worker support..
}
</code></pre>
<h4 id="我们如何在JavaScript中创建一个worker线程？"><a href="#我们如何在JavaScript中创建一个worker线程？" class="headerlink" title="我们如何在JavaScript中创建一个worker线程？"></a>我们如何在JavaScript中创建一个worker线程？</h4><p><strong>主线程</strong>通过Javascript文件名创建<strong>worker</strong>对象</p>
<pre><code class="javascript">var worker = new Worker(&quot;MyHeavyProcess.js&quot;);
</code></pre>
<p><strong>子线程</strong>需要使用“<strong>PostMessage</strong>”发送信息给worker对象</p>
<pre><code class="javascript">worker.postMessage();
</code></pre>
<p><strong>主线程</strong>当worker线程发送数据的时候，我们在调用结束的时候，通过”<strong>onMessage</strong>”事件获取</p>
<pre><code class="javascript">worker.onmessage = function (e) 
{
document.getElementById(&quot;txt1&quot;).value = e.data;
};
</code></pre>
<p>出错处理。<strong>onerror</strong>监听，错误消息可以通过<strong>e.message</strong>来获取。</p>
<h4 id="如何中止Web-Worker"><a href="#如何中止Web-Worker" class="headerlink" title="如何中止Web Worker?"></a>如何中止Web Worker?</h4><p><strong>主线程</strong>。注意：一旦terminate后，无法重新启用，只能另外创建。</p>
<pre><code class="javascript">w.terminate();
</code></pre>
<h1 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。</p>
<h3 id="EventSource，onmessage"><a href="#EventSource，onmessage" class="headerlink" title="EventSource，onmessage"></a>EventSource，onmessage</h3><pre><code class="javascript">var source=new EventSource(&quot;demo_sse.php&quot;);

source.onmessage=function(event){
  document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
};
</code></pre>
<h3 id="服务器端代码实例"><a href="#服务器端代码实例" class="headerlink" title="服务器端代码实例"></a>服务器端代码实例</h3><p><strong>把 “Content-Type” 报头设置为 “text/event-stream”。</strong></p>
<h5 id="ASP-代码-VB-demo-sse-asp"><a href="#ASP-代码-VB-demo-sse-asp" class="headerlink" title="ASP 代码 (VB) (demo_sse.asp):"></a>ASP 代码 (VB) (demo_sse.asp):</h5><pre><code>&lt;%
Response.ContentType=&quot;text/event-stream&quot;
Response.Expires=-1
Response.Write(&quot;data: &quot; &amp; now())
Response.Flush()
%&gt;
</code></pre><h3 id="EventSource-对象"><a href="#EventSource-对象" class="headerlink" title="EventSource 对象"></a>EventSource 对象</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onopen</td>
<td>当通往服务器的连接被打开</td>
</tr>
<tr>
<td>onmessage</td>
<td>当接收到消息</td>
</tr>
<tr>
<td>onerror</td>
<td>当错误发生</td>
</tr>
</tbody>
</table>
<h1 id="WebSQL"><a href="#WebSQL" class="headerlink" title="WebSQL"></a>WebSQL</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="什么是WebSQL？"><a href="#什么是WebSQL？" class="headerlink" title="什么是WebSQL？"></a>什么是WebSQL？</h3><p>WebSQL是一个在浏览器客户端的结构关系数据库，这是浏览器内的本地RDBMS(关系型数据库系统)，你可以使用SQL查询</p>
<h3 id="WebSql是HTML5的一个规范吗？"><a href="#WebSql是HTML5的一个规范吗？" class="headerlink" title="WebSql是HTML5的一个规范吗？"></a>WebSql是HTML5的一个规范吗？</h3><p>不是，许多人把它标记为HTML5，但是他不是HTML5的规范的一部分，这个规范是基于SQLite的</p>
<h3 id="我们如何使用WebSQL？"><a href="#我们如何使用WebSQL？" class="headerlink" title="我们如何使用WebSQL？"></a>我们如何使用WebSQL？</h3><p>第一步我们需要做的是使用如下所示的“OpenDatabase”方法打开数据库</p>
<pre><code class="javascript">var db=openDatabase(&#39;dbCustomer&#39;,&#39;1.0&#39;,&#39;Customer app’, 2 * 1024 * 1024);
</code></pre>
<p>为了执行SQL，我们需要使用“transaction”方法，并调用”executeSql”方法来使用SQL</p>
<pre><code class="javascript">db.transaction(function (tx) 
{
  tx.executeSql(&#39;CREATE TABLE IF NOT EXISTS tblCust(id unique, customername)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES(1, &quot;shiv&quot;)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES (2, &quot;raju&quot;)&#39;);
  tx.executeSql(&#39;SELECT * FROM tblcust&#39;, [], function (tx, results) {
   for (i = 0; i &lt; len; i++)
    {
     msg = &quot;&lt;p&gt;&lt;b&gt;&quot; + results.rows.item(i).log + &quot;&lt;/b&gt;&lt;/p&gt;&quot;;
     document.querySelector(&#39;#customer).innerHTML +=  msg;
    }
 }, null);
});
</code></pre>
<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="浏览器支持-2"><a href="#浏览器支持-2" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><pre><code class="javascript">return !!(window.history &amp;&amp; history.pushState);
</code></pre>
<h3 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h3><p>HTML 5提供了两个新方法：history.pushState(); 和 history.replaceState();两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。</p>
<p>pushState()和replaceState()参数一样，参数说明如下：</p>
<ol>
<li>state：存储JSON字符串，可以用在popstate事件中。</li>
<li>title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替</li>
<li>url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。</li>
</ol>
<h3 id="history对象常见用法"><a href="#history对象常见用法" class="headerlink" title="history对象常见用法"></a>history对象常见用法</h3><p>history.back();//返回上一页，相当于浏览器上后退功能。</p>
<p>history.forward();//去到下一页，相当于浏览器的前进功能。</p>
<p>histoty.go(int);//去到指定的浏览历史记录页面。int是正的时候，就是向前int个历史记录，如果没有那么多，就没有行为。int是负数的时候那么就会向后，为0页面即没有任何变化。</p>
<h1 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="keygen-元素"><a href="#keygen-元素" class="headerlink" title="keygen 元素"></a>keygen 元素</h3><p>keygen 元素的作用是提供一种验证用户的可靠方法。</p>
<h3 id="HTML5-的新的表单属性"><a href="#HTML5-的新的表单属性" class="headerlink" title="HTML5 的新的表单属性"></a>HTML5 的新的表单属性</h3><h4 id="新的-form-属性"><a href="#新的-form-属性" class="headerlink" title="新的 form 属性"></a>新的 form 属性</h4><ul>
<li>autocomplete</li>
<li>novalidate</li>
</ul>
<h4 id="新的-input-属性"><a href="#新的-input-属性" class="headerlink" title="新的 input 属性"></a>新的 input 属性</h4><ul>
<li>autocomplete</li>
<li>autofocus</li>
<li>form</li>
<li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li>
<li>height 和 width</li>
<li>list</li>
<li>min, max 和 step</li>
<li>multiple</li>
<li>pattern (regexp)</li>
<li>placeholder</li>
<li>required</li>
</ul>
<h2 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h2><h3 id="HTML5中的datalist是什么？"><a href="#HTML5中的datalist是什么？" class="headerlink" title="HTML5中的datalist是什么？"></a>HTML5中的datalist是什么？</h3><p>HTML5中的Datalist元素有助于提供文本框自动完成特性</p>
<p>datalist 元素规定输入域的选项列表。</p>
<p>列表是通过 datalist 内的 option 元素创建的。</p>
<p>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id：</p>
<pre><code class="html">&lt;input list=&quot;Country&quot;&gt;
&lt;datalist id=&quot;Country&quot;&gt;
  &lt;option value=&quot;India&quot;&gt;
  &lt;option value=&quot;Italy&quot;&gt;
  &lt;option value=&quot;Iran&quot;&gt;
  &lt;option value=&quot;Israel&quot;&gt;
  &lt;option value=&quot;Indonesia&quot;&gt;
&lt;/datalist&gt;
</code></pre>
<p>提示：option 元素永远都要设置 value 属性。</p>
<h3 id="HTML5中什么是不同的新的表单元素类型？"><a href="#HTML5中什么是不同的新的表单元素类型？" class="headerlink" title="HTML5中什么是不同的新的表单元素类型？"></a>HTML5中什么是不同的新的表单元素类型？</h3><ol>
<li>Color</li>
<li>Date</li>
<li>Datetime-local</li>
<li>Email</li>
<li>Time</li>
<li>Url</li>
<li>Range</li>
<li>Telephone</li>
<li>Number</li>
<li>Search</li>
</ol>
<pre><code class="html">如果你想显示颜色选择对话框
&lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;

如果你想显示日历对话框
&lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt;

如果你想显示含有本地时间的日历
&lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;

如果你想创建一个含有email校验的HTML文本框，我们可以设置类型为“email”
&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;

对于URL验证设置类型为”url”
&lt;input type=&quot;url&quot; name=&quot;sitename&quot;&gt;

如果你想限定数字范围，你可以设置类型为“number”
&lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;

如果你想显示范围控制，你可以使用类型”range”
&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;6&quot;&gt;

想让文本框作为搜索引擎
&lt;input type=&quot;search&quot; name=&quot;googleengine&quot;&gt;

想只能输入时间
&lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;

如果你想使用文本框接受电话号码
&lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt;
</code></pre>
<h3 id="HTML5中什么是输出元素？"><a href="#HTML5中什么是输出元素？" class="headerlink" title="HTML5中什么是输出元素？"></a>HTML5中什么是输出元素？</h3><p>当你需要计算两个输入的和值到一个标签中的时候你需要输出元素。</p>
<p>例如你有两个文本框，你想将来自这两个输入框中的数字求和并放到标签中。</p>
<pre><code class="html">&lt;form onsubmit=&quot;return false&quot;  oninput=&quot;o.value = parseInt(a.value) + parseInt(b.value)&quot;&gt;
  &lt;input name=&quot;a&quot; type=&quot;number&quot;&gt; +
  &lt;input name=&quot;b&quot; type=&quot;number&quot;&gt; =
  &lt;output name=&quot;o&quot; /&gt;
&lt;/form&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端大纲]]></title>
      <url>/2017/11/01/%E5%89%8D%E7%AB%AF%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<p>这篇文章是为了时刻提醒自己，还有哪些坑要填。</p>
<a id="more"></a>
<h1 id="结构层-HTML"><a href="#结构层-HTML" class="headerlink" title="结构层(HTML)"></a>结构层(HTML)</h1><p>对WEB标准的理解</p>
<p>浏览器内核差异</p>
<p><a href="https://janebt.github.io/2017/11/01/HTML5%E6%80%BB%E7%BB%93/">HTML5新特性及应用</a></p>
<h1 id="表示层-CSS"><a href="#表示层-CSS" class="headerlink" title="表示层(CSS)"></a>表示层(CSS)</h1><p>布局</p>
<p>盒子模型</p>
<p>选择器优先级及使用</p>
<p>CSS3新特性及应用</p>
<p>兼容性</p>
<p>Hack</p>
<p>移动端适应</p>
<h1 id="行为层-JavaScript"><a href="#行为层-JavaScript" class="headerlink" title="行为层(JavaScript)"></a>行为层(JavaScript)</h1><p>数据类型</p>
<p>面向对象</p>
<p>作用域</p>
<p>原型链</p>
<p>继承、封装、多态</p>
<p>闭包</p>
<p>插件</p>
<p>跨域</p>
<p>模块化</p>
<p>事件机制</p>
<p>自定义事件</p>
<p>内存泄漏</p>
<p>异步装载回调</p>
<p>模版引擎</p>
<p>Ajax</p>
<p>Jquery</p>
<p>JSON</p>
<p>Nodejs</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>优化</p>
<p>交互</p>
<p>响应式</p>
<p>HTTP</p>
<p>WEB安全</p>
<p>重构</p>
<p>SEO</p>
<p>UED</p>
<p>架构</p>
<p>后端</p>
<p>移动端</p>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速搭建Hexo]]></title>
      <url>/2016/10/01/Hexo%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是提醒自己半年更一次博客忘了要怎么做。当然如果想<strong>迅速</strong>建站，可是可以参考的。</p>
<a id="more"></a>
<h1 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h1><p>首先需要搭建hexo，包括：</p>
<ul>
<li>安装node.js</li>
<li>安装Hexo</li>
<li>后期部署</li>
<li>hexo配置</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code class="shell">npm install -g hexo-cli --no-optional
npm install hexo-deployer-git --save
cd ~/Document/hexo
hexo init
npm install
</code></pre>
<h2 id="后期部署"><a href="#后期部署" class="headerlink" title="后期部署"></a>后期部署</h2><pre><code>hexo new &quot;blogName&quot;        //添加文章
hexo new page &quot;pageName&quot; #新建页面
hexo clean
hexo algolia    //algolia搜索
hexo 

hexo generate    //生成静态页面
hexo sever        //本地启动
hexo deploy        //同步到github
</code></pre><h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>主要是配置下github账户信息：</p>
<pre><code>deploy: 
     type: git 
     repo: https://github.com/用户名/用户名.github.io.git 
     branch: master
</code></pre><p>其他配置信息可以参考各个主题文档</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>用过material、yilla、next等，也用过自定义的主题，其实内容都是大同小异，主要就是_config.yml修改，插入图片，配置rss、评论、搜索、统计等信息。详细见各个主题Doc。</p>
<p>我最近使用的是material( <a href="https://mt.viosey.com/docs/#/" target="_blank" rel="external">Material Theme Doc</a> )，也是我推荐的。它的主题是简洁，看着很干净。</p>
<p>具体流程：</p>
<ul>
<li>安装主题</li>
<li>启用主题</li>
<li>主题配置</li>
</ul>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>在站点 _config.yml 中设置theme</p>
<h2 id="主题配置-1"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="头像等信息"><a href="#头像等信息" class="headerlink" title="头像等信息"></a>头像等信息</h3><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>这块也是因主题而异。material主题只需要在post的md中首行添加</p>
<pre><code>categories:
  - 博客栈
</code></pre><h3 id="设置favicon"><a href="#设置favicon" class="headerlink" title="设置favicon"></a>设置favicon</h3><p>选择一个favicon制作网站完成制作，例如<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>是一个免费的在线制作ico图标网站。</p>
<h1 id="插件第三方"><a href="#插件第三方" class="headerlink" title="插件第三方"></a>插件第三方</h1><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><ul>
<li><a href="http://www.tuicool.com/articles/m6bIJfq" target="_blank" rel="external">为Hexo博客添加版权说明和打赏功能</a> </li>
</ul>
<h2 id="添加canvas-nest特效"><a href="#添加canvas-nest特效" class="headerlink" title="添加canvas_nest特效"></a>添加canvas_nest特效</h2><ul>
<li><a href="http://tc9011.com/2017/02/02/hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/" target="_blank" rel="external">hexo文章添加版权声明及一些特效</a> </li>
</ul>
<h2 id="algolia搜索"><a href="#algolia搜索" class="headerlink" title="algolia搜索"></a>algolia搜索</h2><ul>
<li><a href="http://www.jianshu.com/p/fa2354d61e37" target="_blank" rel="external">hexo+next添加algolia搜索</a></li>
<li>修改文章需要执行：<pre><code>hexo algolia
</code></pre></li>
</ul>
<h2 id="添加文章阅读量"><a href="#添加文章阅读量" class="headerlink" title="添加文章阅读量"></a>添加文章阅读量</h2><ul>
<li><a href="http://www.joryhe.com/2016-05-29-how_to_create_leancloud_read_Counter.html" target="_blank" rel="external">leanCloud,实现文章阅读量统计</a> </li>
</ul>
<h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><ul>
<li><a href="https://segmentfault.com/q/1010000008403584" target="_blank" rel="external">hexo主题下的开启打赏功能具体是怎么实现的呀？</a> </li>
</ul>
<h2 id="音乐外链"><a href="#音乐外链" class="headerlink" title="音乐外链"></a>音乐外链</h2><ul>
<li><a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">Hexo中播放网易云音乐的实践</a> </li>
</ul>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><ul>
<li><a href="http://blog.csdn.net/yingpaixiaochuan/article/details/68954103" target="_blank" rel="external">Hexo博客（Next主题）放弃多说，接入网易云跟贴</a></li>
</ul>
<h2 id="首页文章以摘要形式显示"><a href="#首页文章以摘要形式显示" class="headerlink" title="首页文章以摘要形式显示"></a>首页文章以摘要形式显示</h2><ul>
<li>打开<strong>主题配置文件</strong>，找到如下位置，其中<code>length</code>代表显示摘要的截取字符长度。修改<pre><code>auto_excerpt:
  enable: true
length: 150
</code></pre></li>
</ul>
<h2 id="设置首页文章显示篇数"><a href="#设置首页文章显示篇数" class="headerlink" title="设置首页文章显示篇数"></a>设置首页文章显示篇数</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre><code>  npm install --save hexo-generator-index
  npm install --save hexo-generator-archive
  npm install --save hexo-generator-tag
</code></pre><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><pre><code>index_generator:
  per_page: 5

archive_generator:
  per_page: 20
  yearly: true
  monthly: true

tag_generator:
  per_page: 10
</code></pre><h2 id="设置404公益页面"><a href="#设置404公益页面" class="headerlink" title="设置404公益页面"></a>设置404公益页面</h2><p>在<strong>站点目录</strong>的source文件夹下，新建<code>404.html</code>文件，将下面的代码复制进去保存即可。</p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;404 - arao&#39;blog&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;404错误，页面不存在！&quot;&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="github-clone速度慢"><a href="#github-clone速度慢" class="headerlink" title="github clone速度慢"></a>github clone速度慢</h2><pre><code class="shell">git config --global http.postBuffer 524288000
</code></pre>
<h2 id="Hexo-Next的文章目录形式异常"><a href="#Hexo-Next的文章目录形式异常" class="headerlink" title="Hexo Next的文章目录形式异常"></a>Hexo Next的文章目录形式异常</h2><h3 id="反引号问题"><a href="#反引号问题" class="headerlink" title="反引号问题"></a>反引号问题</h3><p>用typora生成文章并传给next，中间需要注意的是代码注释段(反引号)，typora和next解析逻辑不一样，注意去掉反引号前面的空格,可以使toc匹配<br>如果去除反引号和上面的空行，可以使代码段格式和上面内容对齐</p>
<h3 id="Head错位"><a href="#Head错位" class="headerlink" title="Head错位"></a>Head错位</h3><p>比如上一层是H2，内部是H4，就会出现错位。</p>
<h2 id="Hexo-Next的文章不显示内容"><a href="#Hexo-Next的文章不显示内容" class="headerlink" title="Hexo Next的文章不显示内容"></a>Hexo Next的文章不显示内容</h2><p>引用中设置字体，会导致整个文档无法解析。</p>
<h2 id="Hexo-g-无法生成html"><a href="#Hexo-g-无法生成html" class="headerlink" title="Hexo g 无法生成html"></a>Hexo g 无法生成html</h2><p>排查发现对以下解析问题：</p>
<pre><code>`{{{ xxx }}}`
`{{* foo }}`
`{{ }}`
</code></pre><hr>
<p>基本这就是搭建一个github blog需要包括的内容了。当然，最快的方式也许是找一个官方demo直接clone修改配置。</p>
]]></content>
      
        <categories>
            
            <category> 博客栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
