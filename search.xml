<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[继承、封装、多态]]></title>
      <url>/2017/11/25/Inheritance/</url>
      <content type="html"><![CDATA[<p>本文介绍继承的写法，参考《JS高程》。<br>封装、多态待补。</p>
<a id="more"></a>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><pre><code class="javascript">function Parent0(){
    this.name = &quot;parent0&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child0(){
    Parent0.call( this ); // 或apply
    this.type = &quot;child0&quot;;
}
</code></pre>
<p>问题：</p>
<p>这种方式，父类原型上的东西（<strong>原型对象</strong>）是没法继承的，因此函数复用也就无从谈起，（部分继承）</p>
<h2 id="原型链式继承（借用原型链实现继承）"><a href="#原型链式继承（借用原型链实现继承）" class="headerlink" title="原型链式继承（借用原型链实现继承）"></a>原型链式继承（借用原型链实现继承）</h2><pre><code class="javascript">function Parent1(){
    this.name = &quot;parent1&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child1(){
    this.name = &quot;child1&quot;;
}
Child1.prototype = new Parent1();
</code></pre>
<p>这种方式确实解决了上面借用构造函数继承方式的缺点。</p>
<p>问题：</p>
<p>我们实例化了两个Child1，在实例s1中为父类的colors属性push了一个颜色，但是s2也被跟着改变了。造成这种现象的原因就是原型链上中的原型对象它俩是共用的。</p>
<p>这不是我们想要的，<code>s1</code>和<code>s2</code>这个两个对象应该是隔离的，这是这种继承方式的缺点。</p>
<ol>
<li><strong>注意：包含饮用类型会被共享</strong></li>
<li><strong>构造子类型无法向超类型构造函数传参。</strong></li>
</ol>
<h2 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h2><p>这里所谓的组合是指组合借用构造函数和原型链继承两种方式。</p>
<pre><code class="javascript">//2.原型连继承和借用构造函数 组合实现继承 （组合继承解决原型链继承的引用类型原型属性被实例共享问题）  
function father(name) {  
  this.faName = &#39;father&#39;;  
}  
father.prototype.getfaName = function() {  
  console.log(this.faName);  
};  
function child(args) {  
  this.chName = &#39;child&#39;;  
  father.apply(this,[]); //第二次调用父类构造函数  
}  
child.prototype = new father(); //第一次调用父类构造函数  
child.prototype.constructor = child;  
child.prototype.getchName = function() {  
  console.log(this.chName);  
};  
/* 
缺点：1.两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部） 
     2.子类继承父类的属性，第二次一组在子类实例上，第一次一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低 
*/
</code></pre>
<p>## </p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><pre><code class="javascript">function object (o) {
    function F() {}
    F.prototype = o;
    return new F();
}
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person1 = object (person);
person1.name = &quot;Gerg&quot;;
person1.friends.push(&quot;Job&quot;);
console.log(person1.name);
console.log(person1.friends);

var person2 = object(person);
console.log(person2.name);
console.log(person2.friends);

或es5
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person2 = object.create(person);
</code></pre>
<p>object函数就是改变构造函数的prototype对象的，比如说你要继承person中的属性，那么就写一个空函数，把空函数的prototype对象修改成person。</p>
<p>问题：</p>
<p>引用类型有问题，同原型链式继承</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><pre><code class="javascript">function createAnother(original){
 var clone = Object.create(original); //通过调用函数创建一个新对象
 clone.sayHi = function(){    //以某种方式来增强这个对象
  alert(&quot;Hi&quot;);
 };

 return clone;      //返回这个对象
}

var person = {
 name: &quot;Bob&quot;,
 friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();
</code></pre>
<p>问题：</p>
<p>添加函数，不能复用</p>
<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><pre><code class="javascript">function inheritPrototype(subType, superType){
 var protoType = Object.create(superType.prototype); //创建对象
 protoType.constructor = subType;     //增强对象
 subType.prototype = protoType;      //指定对象
}

function SuperType(name){
 this.name = name;
 this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
 alert(this.name);
}

function SubType(name, age){
 SuperType.call(this, name);　　//第二次调用SuperType()

 this.age = age;
}
inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function(){
 alert(this.age);
}

var instance = new SubType(&quot;Bob&quot;, 18);
instance.sayName();
instance.sayAge();
</code></pre>
<p>将新创建的对象（即副本）赋值给子类型的原型这种方法只调用了一次SuperType构造函数，instanceof 和isPrototypeOf()也能正常使用。</p>
<h2 id="ES6中继承"><a href="#ES6中继承" class="headerlink" title="ES6中继承"></a>ES6中继承</h2><p><code>Class</code> 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code class="javascript">class Parent {
}
class Child1 extends Parent {
    constructor(x, y, colors) {
         super(x, y); // 调用父类的constructor(x, y)
         this.colors = colors;
    }
    toString() {
         return this.colors + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}
</code></pre>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
<p>另一个需要注意的地方是， 在子类的构造函数中， 只有调用super之后， 才可以使用this关键字， 否则会报错。 这是因为子类实例的构建， 是基于对父类实例加工， 只有super方法才能返回父类实例。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1>]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/11/25/Apply,%20call,%20and%20bind/</url>
      <content type="html"><![CDATA[<h1 id="call及apply"><a href="#call及apply" class="headerlink" title="call及apply"></a>call及apply</h1><p>A</p>
<p>所以，可以看出call和apply是为了动态改变this而出现的，当一个object没有某个方法，但是其他的有，我们可以借助call或apply用其它对象的方法来操作。</p>
<p>用的比较多的，通过document.getElementsByTagName选择的dom 节点是一种类似array的array。它不能应用Array下的push,pop等方法。我们可以通过：<br>var domNodes =  Array.prototype.slice.call(document.getElementsByTagName(“*”));<br>这样domNodes就可以应用Array下的所有方法了。</p>
<p>B</p>
<p>call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<blockquote>
<p>var func1 = function(arg1, arg2) {};</p>
</blockquote>
<p>就可以通过 func1.call(this, arg1, arg2); 或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。</p>
<p>JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。</p>
<p>C</p>
<pre><code>obj.call(thisObj, arg1, arg2, ...);
obj.apply(thisObj, [arg1, arg2, ...]);
</code></pre><p>两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。</p>
<p>唯一区别是apply接受的是数组参数，call接受的是连续参数。</p>
<p>call是apply的语法糖。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[前端大纲]]></title>
      <url>/2017/11/01/%E5%89%8D%E7%AB%AF%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<p>这篇文章是为了时刻提醒自己，还有哪些坑要填。</p>
<a id="more"></a>
<h1 id="结构层-HTML"><a href="#结构层-HTML" class="headerlink" title="结构层(HTML)"></a>结构层(HTML)</h1><p>对WEB标准的理解</p>
<p>浏览器内核差异</p>
<p><a href="https://janebt.github.io/2017/11/01/HTML5/">HTML5新特性及应用</a></p>
<h1 id="表示层-CSS"><a href="#表示层-CSS" class="headerlink" title="表示层(CSS)"></a>表示层(CSS)</h1><p>布局</p>
<p>盒子模型</p>
<p>选择器优先级及使用</p>
<p>CSS3新特性及应用</p>
<p>兼容性</p>
<p>Hack</p>
<p>移动端适应</p>
<h1 id="行为层-JavaScript"><a href="#行为层-JavaScript" class="headerlink" title="行为层(JavaScript)"></a>行为层(JavaScript)</h1><p>数据类型</p>
<p>面向对象</p>
<p>作用域</p>
<p><a href="https://janebt.github.io/2017/11/01/Prototype/">原型链</a></p>
<p><a href="https://janebt.github.io/2017/11/25/Inheritance/">继承、封装、多态</a></p>
<p><a href="https://janebt.github.io/2017/11/25/Apply, call, and bind/">Apply, call, and bind</a></p>
<p>闭包</p>
<p>插件</p>
<p>跨域</p>
<p>模块化</p>
<p>事件机制</p>
<p>自定义事件</p>
<p>内存泄漏</p>
<p>异步装载回调</p>
<p>模版引擎</p>
<p>Ajax</p>
<p>Jquery</p>
<p>JSON</p>
<p>Nodejs</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>优化</p>
<p>交互</p>
<p>响应式</p>
<p>HTTP</p>
<p>WEB安全</p>
<p>重构</p>
<p>SEO</p>
<p>UED</p>
<p>架构</p>
<p>后端</p>
<p>移动端</p>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5总结]]></title>
      <url>/2017/11/01/HTML5/</url>
      <content type="html"><![CDATA[<p>这篇文章介绍H5的概念和考察方法。</p>
<p>后续补上demo。</p>
<a id="more"></a>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><blockquote>
<p>提纲参考<a href="http://www.w3school.com.cn/html5/html_5_serversentevents.asp" target="_blank" rel="external">W3</a></p>
</blockquote>
<ul>
<li>HTML5概念</li>
<li>多媒体</li>
<li>拖放</li>
<li>Canvas &amp; SVG</li>
<li>地理定位</li>
<li>Web存储</li>
<li>应用缓存</li>
<li>Web Workers</li>
<li>服务器发送事件</li>
<li>表单</li>
<li>Hisyory API</li>
</ul>
<h1 id="HTML5概念"><a href="#HTML5概念" class="headerlink" title="HTML5概念"></a>HTML5概念</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是HTML5？"><a href="#什么是HTML5？" class="headerlink" title="什么是HTML5？"></a>什么是HTML5？</h3><p>HTML5是最新的HTML标准，他的主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件</p>
<h3 id="SGML和HTML，XML和HTML的之间有什么关系？"><a href="#SGML和HTML，XML和HTML的之间有什么关系？" class="headerlink" title="SGML和HTML，XML和HTML的之间有什么关系？"></a>SGML和HTML，XML和HTML的之间有什么关系？</h3><p>SGML（标准通用标记语言）是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML（超文本标记语言）是被用SGML描述的标记语言。</p>
<p>因此利用SGML创建了HTML参照和必须共同遵守的DTD（文档类型定义），你会经常在HTML页面的头部发现“DOCTYPE”属性，用来定义用于解析目标DTD</p>
<p>XML（可扩展标记语言）使用了SGML，例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。</p>
<p>XHTML创建于XML，他被使用在HTML4.0中。</p>
<p>总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML</p>
<h3 id="为什么HTML5里面我们不需要DTD？"><a href="#为什么HTML5里面我们不需要DTD？" class="headerlink" title="为什么HTML5里面我们不需要DTD？"></a>为什么HTML5里面我们不需要DTD？</h3><p>HTML5没有使用SGML或者XHTML，他是一个全新的东西，因此你不需要参考DTD（Document Type Definition文档类型定义），对于HTML5，你仅需放置下面的文档类型代码告诉浏览器识别这是HTML5文档</p>
<h3 id="HTML5的页面结构同HTML4或者更前的HTML有什么区别？"><a href="#HTML5的页面结构同HTML4或者更前的HTML有什么区别？" class="headerlink" title="HTML5的页面结构同HTML4或者更前的HTML有什么区别？"></a>HTML5的页面结构同HTML4或者更前的HTML有什么区别？</h3><p>一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。现在如果我们想在在HTML4的HTML区域中呈现这些内容，我们可能要使用DIV标签。</p>
<p>但是在HTML5中通过为这些区域创建元素名称使他们更加清晰，也使得你的HTML更加可读</p>
<ul>
<li><code>&lt;header&gt;</code>：代表HTML的头部数据</li>
<li><code>&lt;footer&gt;</code>：页面的脚部区域</li>
<li><code>&lt;nav&gt;</code>：页面导航元素</li>
<li><code>&lt;article&gt;</code>：自包含的内容</li>
<li><code>&lt;section&gt;</code>：使用内部article去定义区域或者把分组内容放到区域里</li>
<li><code>&lt;aside&gt;</code>：代表页面的侧边栏内容</li>
</ul>
<h3 id="HTML5-文档类型和字符集是？"><a href="#HTML5-文档类型和字符集是？" class="headerlink" title="HTML5 文档类型和字符集是？"></a>HTML5 文档类型和字符集是？</h3><pre><code class="html">&lt;!doctype html&gt;
&lt;meta charset=”UTF-8″&gt;
</code></pre>
<h3 id="HTML5-废弃了哪些-HTML4-标签？"><a href="#HTML5-废弃了哪些-HTML4-标签？" class="headerlink" title="HTML5 废弃了哪些 HTML4 标签？"></a>HTML5 废弃了哪些 HTML4 标签？</h3><ul>
<li>frame</li>
<li>frameset</li>
<li>noframe</li>
<li>applet</li>
<li>big</li>
<li>center</li>
<li>basefront</li>
</ul>
<h3 id="HTML5-标准提供了哪些新的-API？"><a href="#HTML5-标准提供了哪些新的-API？" class="headerlink" title="HTML5 标准提供了哪些新的 API？"></a>HTML5 标准提供了哪些新的 API？</h3><p>HTML5 提供的应用程序 API 主要有：</p>
<ul>
<li>Media API</li>
<li>Text Track API</li>
<li>Application Cache API</li>
<li>User Interaction</li>
<li>Data Transfer API</li>
<li>Command API</li>
<li>Constraint Validation API</li>
<li>History API</li>
</ul>
<h1 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h1><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><h3 id="嵌入音频？"><a href="#嵌入音频？" class="headerlink" title="嵌入音频？"></a>嵌入音频？</h3><pre><code class="html">&lt;audio controls&gt;
    &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt;
    Your browser does’nt support audio embedding feature.
&lt;/audio&gt;
</code></pre>
<h3 id="嵌入视频？"><a href="#嵌入视频？" class="headerlink" title="嵌入视频？"></a>嵌入视频？</h3><pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
  &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
   Your browser does’nt support video embedding feature.
&lt;/video&gt;
</code></pre>
<h3 id="除了-audio-和-video，HTML5-还有哪些媒体标签？"><a href="#除了-audio-和-video，HTML5-还有哪些媒体标签？" class="headerlink" title="除了 audio 和 video，HTML5 还有哪些媒体标签？"></a>除了 audio 和 video，HTML5 还有哪些媒体标签？</h3><p><embed> 标签定义嵌入的内容，比如插件。</p>
<pre><code class="html">&lt;embed type=”video/quicktime” src=”Fishing.mov”&gt;
</code></pre>
<p><source> 对于定义多个数据源很有用。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
&lt;/video&gt;
</code></pre>
<p><track> 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
     &lt;track kind=”subtitles” label=”English” src=”jamshed_en.vtt” srclang=”en” default&gt;&lt;/track&gt;
      &lt;track kind=”subtitles” label=”Arabic” src=”jamshed_ar.vtt” srclang=”ar”&gt;&lt;/track&gt;
&lt;/video&gt;
</code></pre>
<h1 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function allowDrop(ev)
{
  ev.preventDefault();
}

function drag(ev)
{
  ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
}

function drop(ev)
{
  ev.preventDefault();
  var data=ev.dataTransfer.getData(&quot;Text&quot;);
  ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>设置元素为可拖放 - draggable</strong></p>
<p>draggable 属性设置为 true </p>
<p><strong>拖动什么 - ondragstart 和 setData()</strong></p>
<p>ondragstart 属性调用了一个函数，drag(<em>event</em>)，它规定了被拖动的数据。</p>
<p>dataTransfer.setData() 方法设置被拖数据的数据类型和值</p>
<p><strong>放到何处 - ondragover</strong></p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<pre><code class="javascript">event.preventDefault()
</code></pre>
<p><strong>进行放置 - ondrop</strong></p>
<p>ondrop 属性调用了一个函数，drop(<em>event</em>)</p>
<h1 id="Canvas-amp-SVG"><a href="#Canvas-amp-SVG" class="headerlink" title="Canvas &amp; SVG"></a>Canvas &amp; SVG</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h3><h4 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h4><pre><code class="javascript">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;
  您的浏览器不支持canvas！
&lt;/canvas&gt;

var canvas = document.getElementById(&#39;myCanvas&#39;);
if (canvas.getContext) {
  var ctx = canvas.getContext(&#39;2d&#39;);
}

//（1）绘制路径
ctx.beginPath(); // 开始路径绘制
ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)
ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线
ctx.lineWidth = 1.0; // 设置线宽
ctx.strokeStyle = &#39;#CC0000&#39;; // 设置线的颜色
ctx.stroke(); // 进行线的着色，这时整条线才变得可见
//最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。

//（2）绘制矩形
//实心矩形
ctx.fillStyle = &#39;yellow&#39;;
ctx.fillRect(50, 50, 200, 100); 
//空心矩形
ctx.strokeRect(10,10,200,100);
//清除某个矩形区域的内容
ctx.clearRect(100,50,50,50);  

//（3）绘制文本
// 设置字体
ctx.font = &quot;Bold 20px Arial&quot;; 
// 设置对齐方式
ctx.textAlign = &quot;left&quot;;
// 设置填充颜色
ctx.fillStyle = &quot;#008600&quot;; 
// 设置字体内容，以及在画布上的位置,绘制文本,不支持文本断行
ctx.fillText(&quot;Hello!&quot;, 10, 50); 
// 绘制空心字
ctx.strokeText(&quot;Hello!&quot;, 10, 100); 

//（4）绘制圆形和扇形
//绘制扇形,startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
//绘制实心的圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.fillStyle = &quot;#000&quot;; 
ctx.fill();
//绘制空心圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.lineWidth = 1.0; 
ctx.strokeStyle = &quot;#000&quot;; 
ctx.stroke();

//（5）设置渐变色
var myGradient = ctx.createLinearGradient(0, 0, 0, 160); 
myGradient.addColorStop(0, &quot;#BABABA&quot;); 
myGradient.addColorStop(1, &quot;#636363&quot;);
//使用方法如下：
ctx.fillStyle = myGradient;
ctx.fillRect(10,10,200,100);

//（6）设置阴影
ctx.shadowOffsetX = 10; // 设置水平位移
ctx.shadowOffsetY = 10; // 设置垂直位移
ctx.shadowBlur = 5; // 设置模糊度
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色
ctx.fillStyle = &quot;#CC0000&quot;; 
ctx.fillRect(10,10,200,100)
</code></pre>
<h4 id="图像处理方法"><a href="#图像处理方法" class="headerlink" title="图像处理方法"></a>图像处理方法</h4><pre><code class="javascript">//drawImage方法:将图像文件插入画布,drawImage方法只能在图像完全载入后才能调用
var image = new Image();
image.onload = function() {
  var canvas = document.createElement(&#39;canvas&#39;);
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext(&#39;2d&#39;).drawImage(image, 0, 0);
  // 插入页面底部
  document.body.appendChild(image);
  return canvas;
}
image.src = &#39;image.png&#39;;

//getImageData方法，putImageData方法:读取Canvas的内容，返回一个对象，包含了每个像素的信息。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新绘制在Canvas上。
var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
context.putImageData(imageData, 0, 0);

//toDataURL方法:将Canvas数据重新转化成一般的图像文件形式。
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL(&#39;image/png&#39;);
  return image;
}

//save方法，restore方法:save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。
ctx.save();
ctx.fillStyle = &#39;#CC0000&#39;;
ctx.fillRect(10,10,150,100);
ctx.restore();
ctx.fillStyle = &#39;#000000&#39;;
ctx.fillRect(180,10,150,100);
</code></pre>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><a href="http://blog.csdn.net/gertyy/article/details/53637951" target="_blank" rel="external">Canvas API 详解</a></p>
<h2 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是SVG？"><a href="#什么是SVG？" class="headerlink" title="什么是SVG？"></a>什么是SVG？</h3><p>SVG（Scalable Vector Graphics可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制，这使得他轻便，显示更加迅速</p>
<pre><code class="html">&lt;svg id=&quot;svgelem&quot; height=&quot;[object SVGAnimatedLength]&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
&lt;line style=&quot;stroke: rgb(255, 0, 0); stroke-width: 2px;&quot; y2=&quot;[object SVGAnimatedLength]&quot; x2=&quot;[object SVGAnimatedLength]&quot; y1=&quot;[object SVGAnimatedLength]&quot; x1=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/line&gt;
</code></pre>
<h3 id="Canvas是什么？"><a href="#Canvas是什么？" class="headerlink" title="Canvas是什么？"></a>Canvas是什么？</h3><p>Canvas是HTML中你可以绘制图形的区域</p>
<h3 id="如何使用Canvas来画一条简单的线？"><a href="#如何使用Canvas来画一条简单的线？" class="headerlink" title="如何使用Canvas来画一条简单的线？"></a>如何使用Canvas来画一条简单的线？</h3><ul>
<li>定义Canvas区域</li>
<li>获取访问canvas上下文区域</li>
<li>绘制图形</li>
</ul>
<pre><code class="javascript">&lt;body  onload=&quot;DrawMe();&quot;&gt;
&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;script&gt;
function DrawMe()
{
var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.moveTo(10,10);
ctx.lineTo(200,100);
ctx.stroke();
}
</code></pre>
<h3 id="如何使用Canvas和HTML5中的SVG去画一个矩形？"><a href="#如何使用Canvas和HTML5中的SVG去画一个矩形？" class="headerlink" title="如何使用Canvas和HTML5中的SVG去画一个矩形？"></a>如何使用Canvas和HTML5中的SVG去画一个矩形？</h3><pre><code class="javascript">HTML5使用SVG绘制矩形的代码
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;rect style=&quot;fill: rgb(0, 0, 255); stroke-width: 1px; stroke: rgb(0, 0, 0);&quot; height=&quot;[object SVGAnimatedLength]&quot; width=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/rect&gt;

HTML5使用Canvas绘制矩形的代码
var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.rect(20,20,150,100);
ctx.stroke();
</code></pre>
<h3 id="Canvas和SVG图形的区别是什么？"><a href="#Canvas和SVG图形的区别是什么？" class="headerlink" title="Canvas和SVG图形的区别是什么？"></a>Canvas和SVG图形的区别是什么？</h3><table>
<thead>
<tr>
<th>SVG</th>
<th>Canvas</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个就好像绘制和记忆，换句话说任何使用SVG绘制的形状都能被记忆和操作，浏览器可以再次显示</td>
<td>Canvas就像绘制和忘记，一旦绘制完成你不能访问像素和操作它</td>
</tr>
<tr>
<td>SVG对于创建图形例如CAD软件是良好的，一旦东西绘制，用户就想去操作它</td>
<td>Canvas在绘制和忘却的场景例如动画和游戏是良好的</td>
</tr>
<tr>
<td>因为为了之后的操作，需要记录坐标，所以比较缓慢</td>
<td>因为没有记住以后事情的意向，所以更快</td>
</tr>
<tr>
<td>我们可以用绘制对象的相关事件处理</td>
<td>我们不能使用绘制对象的相关事件处理，因为我们没有他们的参考</td>
</tr>
<tr>
<td>分辨率无关</td>
<td>分辨率相关</td>
</tr>
</tbody>
</table>
<h1 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a><a href="http://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="external">地理定位</a></h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><p>getCurrentPosition() 方法</p>
<pre><code>navigator.geolocation.getCurrentPosition(showPosition);
</code></pre><p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数</p>
<h1 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h1><h2 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h2><h3 id="localStorage的特点"><a href="#localStorage的特点" class="headerlink" title="localStorage的特点"></a>localStorage的特点</h3><ol>
<li>localStorage拓展了cookie的4K限制。</li>
</ol>
<ol>
<li><p>localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的。</p>
<p>注意：遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>
</li>
<li><p>localStorage只支持string类型的存储。</p>
</li>
</ol>
<h3 id="我们如何从本地存储中添加和移除数据？"><a href="#我们如何从本地存储中添加和移除数据？" class="headerlink" title="我们如何从本地存储中添加和移除数据？"></a>我们如何从本地存储中添加和移除数据？</h3><pre><code class="javascript">//添加
localStorage[&quot;a&quot;]=1;
localStorage.b=1;
localStorage.setItem(“c”,”India”);

//读取
var a = localStorage[&quot;a&quot;];
var b = localStorage.b;
var country = localStorage.getItem(“Key001”);

//改
localStorage[&quot;a&quot;]=2;

//删
localStorage.clear();    //全删
localStorage.removeItem(&quot;a&quot;);    //部分删

//获取键值
for(i=0;i&lt;localStorage.length;i++){
  var key=localStorage.key(i);
}
</code></pre>
<p>可以存JSON,注意<strong>stringify</strong> 和 <strong>parse</strong></p>
<pre><code class="javascript">var data={
  name:&#39;xiecanyong&#39;,
  sex:&#39;man&#39;,
  hobby:&#39;program&#39;
};

var d=JSON.stringify(data);

storage.setItem(&quot;data&quot;,d);

//将JSON字符串转换成为JSON对象输出
var json=storage.getItem(&quot;data&quot;);
var jsonObj=JSON.parse(json);
</code></pre>
<h3 id="本地存储和cookies之间的区别是什么？"><a href="#本地存储和cookies之间的区别是什么？" class="headerlink" title="本地存储和cookies之间的区别是什么？"></a>本地存储和cookies之间的区别是什么？</h3><table>
<thead>
<tr>
<th></th>
<th>Cookies</th>
<th>Local storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端/服务端</td>
<td>客户端和服务端都能访问数据。Cookie的数据通过每一个请求发送到服务端</td>
<td>只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器</td>
</tr>
<tr>
<td>大小</td>
<td>每个cookie有4095byte</td>
<td>每个域5MB</td>
</tr>
<tr>
<td>过期</td>
<td>Cookies有有效期，所以在过期之后cookie和cookie数据会被删除</td>
<td>没有过期数据，无论最后用户从浏览器删除或者使用Javascript程序删除，我们都需要删除</td>
</tr>
</tbody>
</table>
<h1 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a><a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">知识点</a></h2><h3 id="应用程序缓存优势"><a href="#应用程序缓存优势" class="headerlink" title="应用程序缓存优势"></a>应用程序缓存优势</h3><ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<h2 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h2><h3 id="HTML5中的应用缓存是什么？"><a href="#HTML5中的应用缓存是什么？" class="headerlink" title="HTML5中的应用缓存是什么？"></a>HTML5中的应用缓存是什么？</h3><p>应用缓存可以帮助你指定哪些文件需要缓存，哪些不需要。</p>
<h3 id="HTML5中我们如何实现应用缓存？"><a href="#HTML5中我们如何实现应用缓存？" class="headerlink" title="HTML5中我们如何实现应用缓存？"></a>HTML5中我们如何实现应用缓存？</h3><p>首先我们需要指定”manifest”文件，Mainfest文件的内容类型应是“text/cache-manifest”.</p>
<pre><code>CACHE MANIFEST
# version 1.0
CACHE :
Login.aspx
</code></pre><pre><code>Response.ContentType = &quot;text/cache-manifest&quot;;
Response.Write(&quot;CACHE MANIFEST \n&quot;);
Response.Write(&quot;# 2012-02-21 v1.0.0 \n&quot;);
Response.Write(&quot;CACHE : \n&quot;);
Response.Write(&quot;Login.aspx \n&quot;);
Response.Flush();
Response.End();
</code></pre><p>创建一个缓存manifest文件以后，接下来的事情实在HTML页面中提供mainfest连接</p>
<h3 id="应用缓存中的回退是什么？"><a href="#应用缓存中的回退是什么？" class="headerlink" title="应用缓存中的回退是什么？"></a>应用缓存中的回退是什么？</h3><p>应用缓存中的回退帮助你指定在服务器不可访问的时候，将会显示某文件。例如在下面的manifest文件中，我们说如果谁敲击了”/home”同时服务器不可到达的时候，”homeoffline.html”文件应送达</p>
<pre><code>FALLBACK:
/home/ /homeoffline.html
</code></pre><h3 id="应用缓存中的网络是什么？"><a href="#应用缓存中的网络是什么？" class="headerlink" title="应用缓存中的网络是什么？"></a>应用缓存中的网络是什么？</h3><p>网络命令描述不需要缓存的文件，例如以下代码中，我们说”home.aspx”永远都不应该被缓存或者离线访问。</p>
<pre><code>NETWORK:
home.aspx
</code></pre><h3 id="HTML5-应用程序缓存和浏览器缓存有什么区别？"><a href="#HTML5-应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="HTML5 应用程序缓存和浏览器缓存有什么区别？"></a>HTML5 应用程序缓存和浏览器缓存有什么区别？</h3><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p>
<h1 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h1><h2 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h2><h4 id="什么是Web-Workers？为什么我们需要他们？"><a href="#什么是Web-Workers？为什么我们需要他们？" class="headerlink" title="什么是Web Workers？为什么我们需要他们？"></a>什么是Web Workers？为什么我们需要他们？</h4><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。</p>
<p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<p>Web worker帮助我们用异步执行Javascript文件</p>
<h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>所有主流浏览器均支持 web worker，除了 Internet Explorer。</p>
<h4 id="Web-Worker线程的限制是什么？"><a href="#Web-Worker线程的限制是什么？" class="headerlink" title="Web Worker线程的限制是什么？"></a>Web Worker线程的限制是什么？</h4><p>Web worker线程不能修改HTML元素，全局变量和Window.Location一类的窗口属性。你可以自由使用Javascript数据类型，XMLHttpRequest调用等。</p>
<p>简而言之，就是<strong>允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</strong>。</p>
<p>原因：worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做<strong>WorkerGlobalScope</strong>的东东，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。</p>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><pre><code class="javascript">if(typeof(Worker)!==&quot;undefined&quot;)
{
  // Yes! Web worker support!
  // Some code.....
}
else
{
  // Sorry! No Web Worker support..
}
</code></pre>
<h4 id="我们如何在JavaScript中创建一个worker线程？"><a href="#我们如何在JavaScript中创建一个worker线程？" class="headerlink" title="我们如何在JavaScript中创建一个worker线程？"></a>我们如何在JavaScript中创建一个worker线程？</h4><p><strong>主线程</strong>通过Javascript文件名创建<strong>worker</strong>对象</p>
<pre><code class="javascript">var worker = new Worker(&quot;MyHeavyProcess.js&quot;);
</code></pre>
<p><strong>子线程</strong>需要使用“<strong>PostMessage</strong>”发送信息给worker对象</p>
<pre><code class="javascript">worker.postMessage();
</code></pre>
<p><strong>主线程</strong>当worker线程发送数据的时候，我们在调用结束的时候，通过”<strong>onMessage</strong>”事件获取</p>
<pre><code class="javascript">worker.onmessage = function (e) 
{
document.getElementById(&quot;txt1&quot;).value = e.data;
};
</code></pre>
<p>出错处理。<strong>onerror</strong>监听，错误消息可以通过<strong>e.message</strong>来获取。</p>
<h4 id="如何中止Web-Worker"><a href="#如何中止Web-Worker" class="headerlink" title="如何中止Web Worker?"></a>如何中止Web Worker?</h4><p><strong>主线程</strong>。注意：一旦terminate后，无法重新启用，只能另外创建。</p>
<pre><code class="javascript">w.terminate();
</code></pre>
<h1 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>所有主流浏览器均支持服务器发送事件，除了 Internet Explorer。</p>
<h3 id="EventSource，onmessage"><a href="#EventSource，onmessage" class="headerlink" title="EventSource，onmessage"></a>EventSource，onmessage</h3><pre><code class="javascript">var source=new EventSource(&quot;demo_sse.php&quot;);

source.onmessage=function(event){
  document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
};
</code></pre>
<h3 id="服务器端代码实例"><a href="#服务器端代码实例" class="headerlink" title="服务器端代码实例"></a>服务器端代码实例</h3><p><strong>把 “Content-Type” 报头设置为 “text/event-stream”。</strong></p>
<h5 id="ASP-代码-VB-demo-sse-asp"><a href="#ASP-代码-VB-demo-sse-asp" class="headerlink" title="ASP 代码 (VB) (demo_sse.asp):"></a>ASP 代码 (VB) (demo_sse.asp):</h5><pre><code>&lt;%
Response.ContentType=&quot;text/event-stream&quot;
Response.Expires=-1
Response.Write(&quot;data: &quot; &amp; now())
Response.Flush()
%&gt;
</code></pre><h3 id="EventSource-对象"><a href="#EventSource-对象" class="headerlink" title="EventSource 对象"></a>EventSource 对象</h3><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onopen</td>
<td>当通往服务器的连接被打开</td>
</tr>
<tr>
<td>onmessage</td>
<td>当接收到消息</td>
</tr>
<tr>
<td>onerror</td>
<td>当错误发生</td>
</tr>
</tbody>
</table>
<h1 id="WebSQL"><a href="#WebSQL" class="headerlink" title="WebSQL"></a>WebSQL</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="什么是WebSQL？"><a href="#什么是WebSQL？" class="headerlink" title="什么是WebSQL？"></a>什么是WebSQL？</h3><p>WebSQL是一个在浏览器客户端的结构关系数据库，这是浏览器内的本地RDBMS(关系型数据库系统)，你可以使用SQL查询</p>
<h3 id="WebSql是HTML5的一个规范吗？"><a href="#WebSql是HTML5的一个规范吗？" class="headerlink" title="WebSql是HTML5的一个规范吗？"></a>WebSql是HTML5的一个规范吗？</h3><p>不是，许多人把它标记为HTML5，但是他不是HTML5的规范的一部分，这个规范是基于SQLite的</p>
<h3 id="我们如何使用WebSQL？"><a href="#我们如何使用WebSQL？" class="headerlink" title="我们如何使用WebSQL？"></a>我们如何使用WebSQL？</h3><p>第一步我们需要做的是使用如下所示的“OpenDatabase”方法打开数据库</p>
<pre><code class="javascript">var db=openDatabase(&#39;dbCustomer&#39;,&#39;1.0&#39;,&#39;Customer app’, 2 * 1024 * 1024);
</code></pre>
<p>为了执行SQL，我们需要使用“transaction”方法，并调用”executeSql”方法来使用SQL</p>
<pre><code class="javascript">db.transaction(function (tx) 
{
  tx.executeSql(&#39;CREATE TABLE IF NOT EXISTS tblCust(id unique, customername)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES(1, &quot;shiv&quot;)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES (2, &quot;raju&quot;)&#39;);
  tx.executeSql(&#39;SELECT * FROM tblcust&#39;, [], function (tx, results) {
   for (i = 0; i &lt; len; i++)
    {
     msg = &quot;&lt;p&gt;&lt;b&gt;&quot; + results.rows.item(i).log + &quot;&lt;/b&gt;&lt;/p&gt;&quot;;
     document.querySelector(&#39;#customer).innerHTML +=  msg;
    }
 }, null);
});
</code></pre>
<h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="浏览器支持-2"><a href="#浏览器支持-2" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><pre><code class="javascript">return !!(window.history &amp;&amp; history.pushState);
</code></pre>
<h3 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h3><p>HTML 5提供了两个新方法：history.pushState(); 和 history.replaceState();两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。</p>
<p>pushState()和replaceState()参数一样，参数说明如下：</p>
<ol>
<li>state：存储JSON字符串，可以用在popstate事件中。</li>
<li>title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替</li>
<li>url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。</li>
</ol>
<h3 id="history对象常见用法"><a href="#history对象常见用法" class="headerlink" title="history对象常见用法"></a>history对象常见用法</h3><p>history.back();//返回上一页，相当于浏览器上后退功能。</p>
<p>history.forward();//去到下一页，相当于浏览器的前进功能。</p>
<p>histoty.go(int);//去到指定的浏览历史记录页面。int是正的时候，就是向前int个历史记录，如果没有那么多，就没有行为。int是负数的时候那么就会向后，为0页面即没有任何变化。</p>
<h1 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="keygen-元素"><a href="#keygen-元素" class="headerlink" title="keygen 元素"></a>keygen 元素</h3><p>keygen 元素的作用是提供一种验证用户的可靠方法。</p>
<h3 id="HTML5-的新的表单属性"><a href="#HTML5-的新的表单属性" class="headerlink" title="HTML5 的新的表单属性"></a>HTML5 的新的表单属性</h3><h4 id="新的-form-属性"><a href="#新的-form-属性" class="headerlink" title="新的 form 属性"></a>新的 form 属性</h4><ul>
<li>autocomplete</li>
<li>novalidate</li>
</ul>
<h4 id="新的-input-属性"><a href="#新的-input-属性" class="headerlink" title="新的 input 属性"></a>新的 input 属性</h4><ul>
<li>autocomplete</li>
<li>autofocus</li>
<li>form</li>
<li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li>
<li>height 和 width</li>
<li>list</li>
<li>min, max 和 step</li>
<li>multiple</li>
<li>pattern (regexp)</li>
<li>placeholder</li>
<li>required</li>
</ul>
<h2 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h2><h3 id="HTML5中的datalist是什么？"><a href="#HTML5中的datalist是什么？" class="headerlink" title="HTML5中的datalist是什么？"></a>HTML5中的datalist是什么？</h3><p>HTML5中的Datalist元素有助于提供文本框自动完成特性</p>
<p>datalist 元素规定输入域的选项列表。</p>
<p>列表是通过 datalist 内的 option 元素创建的。</p>
<p>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id：</p>
<pre><code class="html">&lt;input list=&quot;Country&quot;&gt;
&lt;datalist id=&quot;Country&quot;&gt;
  &lt;option value=&quot;India&quot;&gt;
  &lt;option value=&quot;Italy&quot;&gt;
  &lt;option value=&quot;Iran&quot;&gt;
  &lt;option value=&quot;Israel&quot;&gt;
  &lt;option value=&quot;Indonesia&quot;&gt;
&lt;/datalist&gt;
</code></pre>
<p>提示：option 元素永远都要设置 value 属性。</p>
<h3 id="HTML5中什么是不同的新的表单元素类型？"><a href="#HTML5中什么是不同的新的表单元素类型？" class="headerlink" title="HTML5中什么是不同的新的表单元素类型？"></a>HTML5中什么是不同的新的表单元素类型？</h3><ol>
<li>Color</li>
<li>Date</li>
<li>Datetime-local</li>
<li>Email</li>
<li>Time</li>
<li>Url</li>
<li>Range</li>
<li>Telephone</li>
<li>Number</li>
<li>Search</li>
</ol>
<pre><code class="html">如果你想显示颜色选择对话框
&lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;

如果你想显示日历对话框
&lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt;

如果你想显示含有本地时间的日历
&lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;

如果你想创建一个含有email校验的HTML文本框，我们可以设置类型为“email”
&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;

对于URL验证设置类型为”url”
&lt;input type=&quot;url&quot; name=&quot;sitename&quot;&gt;

如果你想限定数字范围，你可以设置类型为“number”
&lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;

如果你想显示范围控制，你可以使用类型”range”
&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;6&quot;&gt;

想让文本框作为搜索引擎
&lt;input type=&quot;search&quot; name=&quot;googleengine&quot;&gt;

想只能输入时间
&lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;

如果你想使用文本框接受电话号码
&lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt;
</code></pre>
<h3 id="HTML5中什么是输出元素？"><a href="#HTML5中什么是输出元素？" class="headerlink" title="HTML5中什么是输出元素？"></a>HTML5中什么是输出元素？</h3><p>当你需要计算两个输入的和值到一个标签中的时候你需要输出元素。</p>
<p>例如你有两个文本框，你想将来自这两个输入框中的数字求和并放到标签中。</p>
<pre><code class="html">&lt;form onsubmit=&quot;return false&quot;  oninput=&quot;o.value = parseInt(a.value) + parseInt(b.value)&quot;&gt;
  &lt;input name=&quot;a&quot; type=&quot;number&quot;&gt; +
  &lt;input name=&quot;b&quot; type=&quot;number&quot;&gt; =
  &lt;output name=&quot;o&quot; /&gt;
&lt;/form&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型与原型链]]></title>
      <url>/2017/11/01/Prototype/</url>
      <content type="html"><![CDATA[<p>本文介绍原型和原型链的概念，参考多篇热门博客，持续总结和更新思想。</p>
<a id="more"></a>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h2><p>任何一个对象Object都有<em>proto</em>，它是每一个对象的私有属性，是天生自带的。</p>
<p>又叫做隐式原型</p>
<p>JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf().</p>
<p>Note: Object.prototype 这个对象是个例外，它的<code>__proto__</code>值为null </p>
<p>隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</p>
<p>一个对象的<strong>proto</strong>记录着自己的原型链，决定了自身的数据类型，改变<strong>proto</strong>就等于改变对象的数据类型。</p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><strong>原型对象</strong>。不是任何对象都有prototype，只有构造函数有prototype，是后天赋予的。</p>
<p>每创建一个函数都会有一个prototype属性，这个属性是一个指针，<strong>指向一个对象（通过该构造函数创建实例对象的原型对象）</strong>。</p>
<p>原型对象是包含特定类型的所有实例共享的属性和方法。原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。</p>
<p>原型对象属于普通对象。</p>
<p>又叫做显式原型。</p>
<p><strong>Note</strong>：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性</p>
<p>函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。</p>
<p>在原型对象上定义方法和属性的目的是为了被子类继承和使用。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p>
<h2 id="获取对象的原型"><a href="#获取对象的原型" class="headerlink" title="获取对象的原型"></a>获取对象的原型</h2><pre><code class="javascript">dog1.__proto__  //不推荐  
Object.getPrototypeOf(dog1) === Dog.prototype   //推荐
</code></pre>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的存在，主要是为了实现对象的<code>继承</code>。</p>
<p>原型链基本思路（图解）：</p>
<p><img src="http://img.blog.csdn.net/20161006191631510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="原型链查找"><a href="#原型链查找" class="headerlink" title="原型链查找"></a>原型链查找</h2><p><strong>调用一个对象的属性或方法，一但这个对象中没有，就去这个对象的<em>proto</em>中查找。这个对象的<em>proto</em>指向自己构造函数的prototype属性</strong></p>
<p>关键的点在于找到创建这个对象的构造函数，本质上只有一种方式，也就是通过new来创建。</p>
<p>由Object.create(o)创建出来的对象它的隐式原型指向o。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的<strong>proto</strong>属性</p>
<p>当使用<code>new</code>去调用构造函数时，相当于执行了</p>
<pre><code class="javascript">var o = {};
o.__proto__ = F.prototype;
F.call(o);
</code></pre>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型对象prototype上都有个预定义的<code>constructor</code>属性，用来引用它的函数对象。这是一种循环引用。</p>
<pre><code class="javascript">function F(){};
F.prototype.constructor === F;
</code></pre>
<p>在实际运用中，经常会有下列的写法</p>
<pre><code class="javascript">function F(){};
F.prototype = {
    constructor : F,
    doSomething : function(){}
}
</code></pre>
<p>这里要加<code>constructor</code>是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。</p>
<p>实例对象的constructor属性指向其构造函数, 因此</p>
<pre><code class="javascript">Object.constructor === Function;
Function.constructor === Function;
</code></pre>
<p>由 Object.create() 创建出来的对象没有构造函数</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-Function-prototype没有prototype属性"><a href="#Case1-Function-prototype没有prototype属性" class="headerlink" title="Case1.Function.prototype没有prototype属性"></a>Case1.Function.prototype没有prototype属性</h2><p><strong>原型对象属于普通对象。</strong>Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。</p>
<pre><code class="javascript">function person(){};  

console.log(typeof person.prototype) //Object  
console.log(typeof Object.prototype) // Object  
console.log(typeof Function.prototype) // 特殊 Function  
console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性
</code></pre>
<h2 id="Case2-构造函数的显示原型的隐式原型"><a href="#Case2-构造函数的显示原型的隐式原型" class="headerlink" title="Case2.构造函数的显示原型的隐式原型"></a>Case2.构造函数的显示原型的隐式原型</h2><p>内建对象(built-in object)比如Array()，Array.prototype.<strong>proto</strong>指向什么？</p>
<p>Array.prototype.<strong>proto</strong> === Object.prototype，或者也可以这么理解，所有的内建对象都是由Object()创建而来。</p>
<p>Array是函数对象，是Function的实例对象，Array是通过new Function创建出来的。因为Array是Function的实例，所以Array.<strong>proto</strong> ===  Function.prototype</p>
<h2 id="Case3-instanceof"><a href="#Case3-instanceof" class="headerlink" title="Case3.instanceof"></a>Case3.instanceof</h2><h3 id="解释1"><a href="#解释1" class="headerlink" title="解释1"></a>解释1</h3><p>instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>内部实现原理：</p>
<pre><code class="javascript">//设 L instanceof R 
//通过判断
 L.__proto__.__proto__ ..... === R.prototype ？
//最终返回true or false
</code></pre>
<h3 id="解释2"><a href="#解释2" class="headerlink" title="解释2"></a>解释2</h3><p><code>A instanceof B</code> 是在 A 的原型链里查找 B 的 constructor，找到返回 true，找不到返回 false。</p>
<pre><code class="javascript">Function instanceof Object === true
Object instanceof Function === true

Object.__proto__ === Function.prototype; // true
Object.__proto__ == Object.prototype; // false
Function.prototype.__proto__ === Object.prototype; // true
</code></pre>
<h2 id="Case4-Function、Object关系"><a href="#Case4-Function、Object关系" class="headerlink" title="Case4.Function、Object关系"></a>Case4.Function、Object关系</h2><p><code>Object.prototype</code>是所有对象的根源<br><code>Object.prototype</code>只是挂载在<code>Object</code>函数对象上<br><code>Function.prototype</code>构造自<code>Object.prototype</code><br><code>Function.prototype</code> 只是挂载在<code>Function</code>函数对象上<br><code>Object</code>函数和<code>Function</code>函数构造自<code>Function.prototype</code><br><code>Object</code>字面量对象{}构造自<code>Object.prototype</code><br><code>Object</code>字面量对象<code>{}.__proto__</code>（原构造对象） === <code>Object.prototype</code><br><code>Function</code>函数 和 自定义函数 都继承（构造而成）自<code>Function.prototype</code><br><code>Function.prototype</code> 和 <code>Function.__proto__</code>（原构造对象）相同<br>所以，是先有的<code>Object.prototype</code>,再有的<code>Function.prototype</code>，再有的<code>Function</code>和<code>Object</code>函数对象</p>
<h2 id="Case5-Function、Object、Prototype、proto内存关系图"><a href="#Case5-Function、Object、Prototype、proto内存关系图" class="headerlink" title="Case5.Function、Object、Prototype、proto内存关系图"></a>Case5.Function、Object、Prototype、<strong>proto</strong>内存关系图</h2><ol>
<li>所有对象所有对象，包括函数对象的原型链最终都指向了Object.prototype，而Object.prototype.<strong>proto</strong>===null，原型链至此结束。</li>
<li>Animal.prototype是一个普通对象。</li>
<li>Object是一个函数对象，也是Function构造的，Object.prototype是一个普通对象。</li>
<li>Object.prototype.<strong>type</strong>指向null。</li>
<li>Function.prototype是一个函数对象，前面说函数对象都有一个显示的prototype属性，但是Function.prototype却没有prototype属性，即Function.prototype.prototype===undefined，所有Function.prototype函数对象是一个特例，没有prototype属性。</li>
<li>Object虽是Function构造的一个函数对象，但是Object.prototype没有指向Function.prototype，即Object.prototype!==Function.prototype。</li>
</ol>
<p><img src="http://images.blogjava.net/blogjava_net/heavensay/web-front/8199006.png" alt=""></p>
<h2 id="Case6-经典原型链"><a href="#Case6-经典原型链" class="headerlink" title="Case6.经典原型链"></a>Case6.经典原型链</h2><p><img src="https://pic2.zhimg.com/50/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt=""></p>
<h2 id="Case7-《JavaScript-世界万物诞生记》"><a href="#Case7-《JavaScript-世界万物诞生记》" class="headerlink" title="Case7.《JavaScript 世界万物诞生记》"></a>Case7.《JavaScript 世界万物诞生记》</h2><p>Object作为一个机器可以看做是有由Function制造出来的，而Function作为一个对象可以看做是由Object制造出来的。</p>
<p><img src="https://pic2.zhimg.com/v2-52726a7f86690c0663452112d66836c5_r.png" alt=""></p>
<h2 id="Case8-《什么是-JS-原型链？》"><a href="#Case8-《什么是-JS-原型链？》" class="headerlink" title="Case8.《什么是 JS 原型链？》"></a>Case8.《什么是 JS 原型链？》</h2><blockquote>
<p>这篇流程讲的很清晰</p>
</blockquote>
<pre><code class="javascript">var obj = { name: &#39;obj&#39; }
</code></pre>
<h3 id="valueOf-toString-constructor-是怎么来？"><a href="#valueOf-toString-constructor-是怎么来？" class="headerlink" title="valueOf / toString / constructor 是怎么来？"></a>valueOf / toString / constructor 是怎么来？</h3><ol>
<li>obj.<strong>proto</strong> 有很多属性，包括 valueOf、toString、constructor 等</li>
<li>obj.<strong>proto</strong> 其实也有一个叫做 <strong>proto</strong> 的属性，值为 null</li>
</ol>
<h3 id="共享原型链"><a href="#共享原型链" class="headerlink" title="共享原型链"></a>共享原型链</h3><p>如果我们改写 obj2.<strong>proto</strong>.toString，那么 obj.toString 其实也会变！</p>
<h3 id="差异化"><a href="#差异化" class="headerlink" title="差异化"></a>差异化</h3><p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？</p>
<p>直接赋值就好了：</p>
<pre><code class="javascript">obj.toString = function(){ return &#39;新的 toString 方法&#39; }
</code></pre>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>「读」属性时会<strong>沿着原型链搜索</strong>。</p>
<p>「新增」属性时<strong>不会</strong>去看原型链（但是如果你给这个属性加了一些配置，则不一样）。</p>
<h2 id="Case9-《最详尽的-JS-原型与原型链终极详解》"><a href="#Case9-《最详尽的-JS-原型与原型链终极详解》" class="headerlink" title="Case9 《最详尽的 JS 原型与原型链终极详解》"></a>Case9 《最详尽的 JS 原型与原型链终极详解》</h2><h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p>对象也有区别，大致可以分为两类，即：普通对象（Object）和函数对象（Function）。<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p>
<h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p><strong>实例的构造函数属性（constructor）指向构造函数。</strong></p>
<h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数,即：<code>Person.prototype.constructor == Person</code></p>
<p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p>
<p><code>Function.prototype</code> 为什么是函数对象呢？</p>
<pre><code class="javascript"> var A = new Function ();
 Function.prototype = A;
</code></pre>
<p><strong>凡是通过 new Function( ) 产生的对象都是函数对象</strong>。因为 A 是函数对象，所以<code>Function.prototype</code> 是函数对象。</p>
<h3 id="六-原型链"><a href="#六-原型链" class="headerlink" title="六. 原型链"></a>六. 原型链</h3><p>Person.prototype.<strong>proto</strong> 是什么？</p>
<p><code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。所以 <code>Person.prototype.__proto__ === Object.prototype</code></p>
<h3 id="七-函数对象"><a href="#七-函数对象" class="headerlink" title="七. 函数对象"></a>七. 函数对象</h3><h5 id="所有函数对象的proto都指向Function-prototype，它是一个空函数"><a href="#所有函数对象的proto都指向Function-prototype，它是一个空函数" class="headerlink" title="所有函数对象的proto都指向Function.prototype，它是一个空函数"></a>所有<em>函数对象</em>的<strong>proto</strong>都指向Function.prototype，它是一个空函数</h5><p><strong>所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind</strong></p>
<p><code>Function.prototype</code>也是唯一一个<code>typeof XXX.prototype</code>为 <code>function</code>的<code>prototype</code>。其它的构造器的<code>prototype</code>都是一个对象</p>
<p><code>Function.prototype</code>的<code>__proto__</code>是谁呢？</p>
<pre><code class="javascript">Function.prototype.__proto__ === Object.prototype
</code></pre>
<p>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<h3 id="八-Prototype"><a href="#八-Prototype" class="headerlink" title="八. Prototype"></a>八. Prototype</h3><p>可以用一个 ES5 提供的新方法：<code>Object.getOwnPropertyNames</code>获取所有（<strong>包括不可枚举的属性</strong>）的属性名<strong>不包括 prototy 中的属性</strong>，返回一个数组</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="external">JS重点整理之JS原型链彻底搞清楚</a></li>
<li><a href="http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html" target="_blank" rel="external">Js中Prototype、<strong>proto</strong>、Constructor、Object、Function关系介绍</a></li>
<li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="external">js中<strong>proto</strong>和prototype的区别和关系？</a></li>
<li><a href="https://segmentfault.com/a/1190000005363885" target="_blank" rel="external">JavaScript之原型链</a></li>
<li><a href="https://segmentfault.com/q/1010000000249140" target="_blank" rel="external">Function为何是Object的实例呢</a></li>
<li><a href="https://segmentfault.com/q/1010000002736664" target="_blank" rel="external">js 原型的问题 Object 和 Function 到底是什么关系？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22989691" target="_blank" rel="external">JavaScript 世界万物诞生记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23090041?refer=study-fe" target="_blank" rel="external">「每日一题」什么是 JS 原型链？</a></li>
<li><a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解，没有「可能是」</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速搭建Hexo]]></title>
      <url>/2016/10/01/Hexo/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是提醒自己半年更一次博客忘了要怎么做。当然如果想<strong>迅速</strong>建站，可是可以参考的。</p>
<a id="more"></a>
<h1 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h1><p>首先需要搭建hexo，包括：</p>
<ul>
<li>安装node.js</li>
<li>安装Hexo</li>
<li>后期部署</li>
<li>hexo配置</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code class="shell">npm install -g hexo-cli --no-optional
npm install hexo-deployer-git --save
cd ~/Document/hexo
hexo init
npm install
</code></pre>
<h2 id="后期部署"><a href="#后期部署" class="headerlink" title="后期部署"></a>后期部署</h2><pre><code>hexo new &quot;blogName&quot;        //添加文章
hexo new page &quot;pageName&quot; #新建页面
hexo clean
hexo algolia    //algolia搜索
hexo 

hexo generate    //生成静态页面
hexo sever        //本地启动
hexo deploy        //同步到github
</code></pre><h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>主要是配置下github账户信息：</p>
<pre><code>deploy: 
     type: git 
     repo: https://github.com/用户名/用户名.github.io.git 
     branch: master
</code></pre><p>其他配置信息可以参考各个主题文档</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>用过material、yilla、next等，也用过自定义的主题，其实内容都是大同小异，主要就是_config.yml修改，插入图片，配置rss、评论、搜索、统计等信息。详细见各个主题Doc。</p>
<p>我最近使用的是material( <a href="https://mt.viosey.com/docs/#/" target="_blank" rel="external">Material Theme Doc</a> )，也是我推荐的。它的主题是简洁，看着很干净。</p>
<p>具体流程：</p>
<ul>
<li>安装主题</li>
<li>启用主题</li>
<li>主题配置</li>
</ul>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>在站点 _config.yml 中设置theme</p>
<h2 id="主题配置-1"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="头像等信息"><a href="#头像等信息" class="headerlink" title="头像等信息"></a>头像等信息</h3><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>这块也是因主题而异。material主题只需要在post的md中首行添加</p>
<pre><code>categories:
  - 博客栈
</code></pre><h3 id="设置favicon"><a href="#设置favicon" class="headerlink" title="设置favicon"></a>设置favicon</h3><p>选择一个favicon制作网站完成制作，例如<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>是一个免费的在线制作ico图标网站。</p>
<h1 id="插件第三方"><a href="#插件第三方" class="headerlink" title="插件第三方"></a>插件第三方</h1><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><ul>
<li><a href="http://www.tuicool.com/articles/m6bIJfq" target="_blank" rel="external">为Hexo博客添加版权说明和打赏功能</a> </li>
</ul>
<h2 id="添加canvas-nest特效"><a href="#添加canvas-nest特效" class="headerlink" title="添加canvas_nest特效"></a>添加canvas_nest特效</h2><ul>
<li><a href="http://tc9011.com/2017/02/02/hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/" target="_blank" rel="external">hexo文章添加版权声明及一些特效</a> </li>
</ul>
<h2 id="algolia搜索"><a href="#algolia搜索" class="headerlink" title="algolia搜索"></a>algolia搜索</h2><ul>
<li><a href="http://www.jianshu.com/p/fa2354d61e37" target="_blank" rel="external">hexo+next添加algolia搜索</a></li>
<li>修改文章需要执行：<pre><code>hexo algolia
</code></pre></li>
</ul>
<h2 id="添加文章阅读量"><a href="#添加文章阅读量" class="headerlink" title="添加文章阅读量"></a>添加文章阅读量</h2><ul>
<li><a href="http://www.joryhe.com/2016-05-29-how_to_create_leancloud_read_Counter.html" target="_blank" rel="external">leanCloud,实现文章阅读量统计</a> </li>
</ul>
<h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><ul>
<li><a href="https://segmentfault.com/q/1010000008403584" target="_blank" rel="external">hexo主题下的开启打赏功能具体是怎么实现的呀？</a> </li>
</ul>
<h2 id="音乐外链"><a href="#音乐外链" class="headerlink" title="音乐外链"></a>音乐外链</h2><ul>
<li><a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">Hexo中播放网易云音乐的实践</a> </li>
</ul>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><ul>
<li><a href="http://blog.csdn.net/yingpaixiaochuan/article/details/68954103" target="_blank" rel="external">Hexo博客（Next主题）放弃多说，接入网易云跟贴</a></li>
</ul>
<h2 id="首页文章以摘要形式显示"><a href="#首页文章以摘要形式显示" class="headerlink" title="首页文章以摘要形式显示"></a>首页文章以摘要形式显示</h2><ul>
<li>打开<strong>主题配置文件</strong>，找到如下位置，其中<code>length</code>代表显示摘要的截取字符长度。修改<pre><code>auto_excerpt:
  enable: true
length: 150
</code></pre></li>
</ul>
<h2 id="设置首页文章显示篇数"><a href="#设置首页文章显示篇数" class="headerlink" title="设置首页文章显示篇数"></a>设置首页文章显示篇数</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre><code>  npm install --save hexo-generator-index
  npm install --save hexo-generator-archive
  npm install --save hexo-generator-tag
</code></pre><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><pre><code>index_generator:
  per_page: 5

archive_generator:
  per_page: 20
  yearly: true
  monthly: true

tag_generator:
  per_page: 10
</code></pre><h2 id="设置404公益页面"><a href="#设置404公益页面" class="headerlink" title="设置404公益页面"></a>设置404公益页面</h2><p>在<strong>站点目录</strong>的source文件夹下，新建<code>404.html</code>文件，将下面的代码复制进去保存即可。</p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;404 - arao&#39;blog&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;404错误，页面不存在！&quot;&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="github-clone速度慢"><a href="#github-clone速度慢" class="headerlink" title="github clone速度慢"></a>github clone速度慢</h2><pre><code class="shell">git config --global http.postBuffer 524288000
</code></pre>
<h2 id="Hexo-Next的文章目录形式异常"><a href="#Hexo-Next的文章目录形式异常" class="headerlink" title="Hexo Next的文章目录形式异常"></a>Hexo Next的文章目录形式异常</h2><h3 id="反引号问题"><a href="#反引号问题" class="headerlink" title="反引号问题"></a>反引号问题</h3><p>用typora生成文章并传给next，中间需要注意的是代码注释段(反引号)，typora和next解析逻辑不一样，注意去掉反引号前面的空格,可以使toc匹配<br>如果去除反引号和上面的空行，可以使代码段格式和上面内容对齐</p>
<h3 id="Head错位"><a href="#Head错位" class="headerlink" title="Head错位"></a>Head错位</h3><p>比如上一层是H2，内部是H4，就会出现错位。</p>
<h2 id="Hexo-Next的文章不显示内容"><a href="#Hexo-Next的文章不显示内容" class="headerlink" title="Hexo Next的文章不显示内容"></a>Hexo Next的文章不显示内容</h2><p>引用中设置字体，会导致整个文档无法解析。</p>
<h2 id="Hexo-g-无法生成html"><a href="#Hexo-g-无法生成html" class="headerlink" title="Hexo g 无法生成html"></a>Hexo g 无法生成html</h2><p>排查发现对以下解析问题：</p>
<pre><code>`{{{ xxx }}}`
`{{* foo }}`
`{{ }}`
</code></pre><hr>
<p>基本这就是搭建一个github blog需要包括的内容了。当然，最快的方式也许是找一个官方demo直接clone修改配置。</p>
]]></content>
      
        <categories>
            
            <category> 博客栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
