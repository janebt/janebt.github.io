<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[前端大纲]]></title>
      <url>/2117/11/01/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>做总结有三个目的：</p>
<ul>
<li>想成为前端架构师，还有哪些坑要填</li>
<li>对所学的知识做一个总结</li>
<li>由浅入深，记录自己的学习，内在源动力</li>
</ul>
<blockquote>
<p>最好能做成一个可扩展的思维导图，并附上链接，做成一颗技能树</p>
</blockquote>
<a id="more"></a>
<h1 id="结构层-HTML"><a href="#结构层-HTML" class="headerlink" title="结构层(HTML)"></a>结构层(HTML)</h1><p><a href="https://janebt.github.io/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/">对WEB标准的理解</a></p>
<p><a href="https://janebt.github.io/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/">浏览器内核差异</a></p>
<p><a href="https://janebt.github.io/2017/01/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML5/">HTML5新特性及应用</a></p>
<h1 id="表示层-CSS"><a href="#表示层-CSS" class="headerlink" title="表示层(CSS)"></a>表示层(CSS)</h1><p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">布局</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">盒子模型</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">选择器优先级及使用</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">CSS3新特性及应用</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">兼容性</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">Hack</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">移动端适应</a></p>
<h1 id="行为层-JavaScript"><a href="#行为层-JavaScript" class="headerlink" title="行为层(JavaScript)"></a>行为层(JavaScript)</h1><p><a href="https://janebt.github.io/2017/04/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a></p>
<p><a href="https://janebt.github.io/2017/02/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/">表达式与运算符</a></p>
<p><a href="https://janebt.github.io/2017/02/27/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%80%97%E5%8F%B7%E3%80%81%E5%86%92%E5%8F%B7%E4%B8%8E%E6%8B%AC%E5%8F%B7/">逗号、冒号与括号</a></p>
<p><a href="https://janebt.github.io/2017/02/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></p>
<p><a href="https://janebt.github.io/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/">作用域</a></p>
<p><a href="https://janebt.github.io/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a></p>
<p><a href="https://janebt.github.io/2017/03/25/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E7%BB%A7%E6%89%BF/">继承、封装、多态</a></p>
<p><a href="https://janebt.github.io/2017/03/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%B8%8A%E4%B8%8B%E6%96%87/">上下文</a></p>
<p><a href="https://janebt.github.io/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%97%AD%E5%8C%85/">闭包</a></p>
<p>插件</p>
<p><a href="https://janebt.github.io/2017/06/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%B7%A8%E5%9F%9F/">跨域</a></p>
<p>模块化</p>
<p><a href="https://janebt.github.io/2017/05/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">事件机制</a></p>
<p>自定义事件</p>
<p><a href="https://janebt.github.io/2017/04/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存泄漏</a></p>
<p>异步装载回调</p>
<p>模版引擎</p>
<p><a href="https://janebt.github.io/2017/08/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/Ajax/">Ajax</a></p>
<p>Jquery</p>
<p><a href="https://janebt.github.io/2017/04/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/json/">JSON</a></p>
<p>Nodejs</p>
<p><a href="">ES6</a></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>优化</p>
<p>交互</p>
<p>响应式</p>
<p><a href="https://janebt.github.io/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/http/">HTTP</a></p>
<p><a href="https://janebt.github.io/2017/12/02/%E5%89%8D%E7%AB%AF/%E8%B6%8B%E5%8A%BF%E6%8A%80%E6%9C%AF/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></p>
<p>重构</p>
<p>SEO</p>
<p>UED</p>
<p>架构</p>
<p>后端</p>
<p>移动端</p>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git使用的一些理解]]></title>
      <url>/2018/01/27/%E5%B7%A5%E5%85%B7/Git/Git%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Git用了很久，但没有思考过原理，偶尔使用遇到问题就很捉急，把工作中遇到的问题都提上来。</p>
<a id="more"></a>
<h1 id="Git使用的一些理解"><a href="#Git使用的一些理解" class="headerlink" title="Git使用的一些理解"></a>Git使用的一些理解</h1><h2 id="remote、origin和master"><a href="#remote、origin和master" class="headerlink" title="remote、origin和master"></a>remote、origin和master</h2><h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><blockquote>
<p>本地已有一个分支，想push到github上，怎么关联呢？</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code class="sh">git push -u origin master -f
</code></pre>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote>
<p>问题是，origin是什么，master是什么，怎么绑定的？</p>
</blockquote>
<p>关于remote的常用操作:</p>
<pre><code class="sh">git remote add origin https://github.com/lonelyc/MyRepo.git
git remote remove xxx
git remote -v

origin    https://github.com/janebt/janeBlog.git (fetch)
origin    https://github.com/janebt/janeBlog.git (push)
</code></pre>
<p>这样就很清楚了，remote指定的是本地默认的origin 和远程库的一个关联，其中默认指定了fetch和push操作</p>
<p>origin我的理解是：origin指向的是repository</p>
<p>其实很清楚， <code>git push</code>就是默认 <code>git push origin master</code></p>
<p><code>$git push origin master</code> （省略了<code>&lt;dst&gt;</code>，等价于 <code>git push origin master:master</code> ）</p>
<p><code>$git push origin master:master</code> (在local repository中找到名字为master的branch，使用它去更新remote repository下名字为master的branch，如果remote repository下不存在名字是master的branch，那么新建一个)</p>
<p>origin是一个链接，它指定了本地库到远程库的连接，但是本地哪个库和远程哪个branch的连接，就由master指定</p>
<hr>
<p>回归问题，这样做还是有问题，github创建时会有一个默认提交，而这边push的提交不带这个提交，所以要强行merge，必然会失败，提示要先pull再push。这时可以直接使用 -f 参数强行推送，然后在github上 dismiss这个冲突问题。</p>
<p>一个tip，github会有很多问题，比如ssh、路径不对什么的。<strong>我的建议是，直接<code>vim .git/config</code>。</strong></p>
<h2 id="push-和-pull"><a href="#push-和-pull" class="headerlink" title="push 和 pull"></a>push 和 pull</h2><h3 id="情景-1"><a href="#情景-1" class="headerlink" title="情景"></a>情景</h3><blockquote>
<p>git clone的远程库，push总会莫名报错。考虑实现 git push自动在远程库中建立本地分支同名的远程分支。但会失败</p>
</blockquote>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>未设置</p>
<pre><code class="sh">git clone xxx
git branch --track local_branch origin/branch
git branch --set-upstream-to=origin/&lt;branch&gt; pj-risk
git pull
git push origin lcoal_branch
</code></pre>
<p>git push的一种简单方法，可以设置current，这样会自动创建同名branch，和track的没关系</p>
<pre><code class="sh">git config --global push.default current
</code></pre>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><blockquote>
<p>为什么<code>git push</code>与<code>git pull</code>命令的默认行为混乱</p>
</blockquote>
<p>先上两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000002783245" target="_blank" rel="external">Git push与pull的默认行为</a></li>
<li><a href="https://stackoverflow.com/questions/24864700/fatal-the-upstream-branch-of-your-current-branch-does-not-match-the-name-of-you" target="_blank" rel="external">fatal: The upstream branch of your current branch does not match the name of your current branch</a></li>
</ul>
<p>总结一下干货：</p>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>如果你未曾改动过git config中的<code>push.default</code>属性，根据我们使用的git不同版本（Git 2.0之前或之后），<code>git push</code>通常会有两种截然不同的行为:</p>
<ol>
<li>develop分支中本地新增的commit被push到远程仓库</li>
<li>push失败，并收到git如下的警告</li>
</ol>
<p>为什么git版本不同会有两种不同的push行为？</p>
<p>因为在<a href="http://git-scm.com/docs/git-config" target="_blank" rel="external">git的全局配置中，有一个push.default</a>属性，其决定了<code>git push</code>操作的默认行为。在Git 2.0之前，这个属性的默认被设为’matching’，2.0之后则被更改为了’simple’。</p>
<p>可以通过<code>git version</code>确定当前的git版本（如果小于2.0，更新是个更好的选择），通过<code>git config --global push.default &#39;option&#39;</code>改变push.default的默认行为（或者也可直接编辑~/.gitconfig文件）。</p>
<p><strong>push.default</strong> 有以下几个可选值：<br><strong>nothing, current, upstream, simple, matching</strong></p>
<p>其用途分别为：</p>
<ul>
<li><strong>nothing</strong> - push操作无效，除非显式指定远程分支，例如<code>git push origin develop</code>（我觉得。。。可以给那些不愿学git的同事配上此项）。</li>
<li><strong>current</strong> - push当前分支到远程同名分支，如果远程同名分支不存在则自动创建同名分支。</li>
<li><strong>upstream</strong> - push当前分支到它的upstream分支上（这一项其实用于经常从本地分支push/pull到同一远程仓库的情景，这种模式叫做central workflow）。</li>
<li><strong>simple</strong> - simple和upstream是相似的，只有一点不同，simple必须保证本地分支和它的远程<br>upstream分支同名，否则会拒绝push操作。</li>
<li><strong>matching</strong> - push所有本地和远程两端都存在的同名分支。</li>
</ul>
<h4 id="upstream-amp-downstream"><a href="#upstream-amp-downstream" class="headerlink" title="upstream &amp; downstream"></a>upstream &amp; downstream</h4><p><a href="http://stackoverflow.com/questions/2739376/definition-of-downstream-and-upstream" target="_blank" rel="external">git中的upstream到底是什么</a>：</p>
<blockquote>
<p>git中存在upstream和downstream，简言之，当我们把仓库A中某分支x的代码push到仓库B分支y，此时仓库B的这个分支y就叫做A中x分支的upstream，而x则被称作y的downstream，这是一个相对关系，每一个本地分支都相对地可以有一个远程的upstream分支（注意这个upstream分支可以不同名，但通常我们都会使用同名分支作为upstream）。</p>
</blockquote>
<p>初次提交本地分支，并不会定义当前本地分支的upstream分支，解决方法：</p>
<ul>
<li><code>git push --set-upstream origin develop</code></li>
<li><code>git push -u origin develop</code></li>
</ul>
<p>注意push.default = current可以在远程同名分支不存在的情况下自动创建同名分支，我就如此指定。</p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>当我们执行<code>git pull</code>的时候，实际上是做了<code>git fetch + git merge</code>操作：</p>
<ul>
<li><p>fetch操作将会更新本地仓库的remote tracking，也就是refs/remotes中的代码，并不会对refs/heads中本地当前的代码造成影响。</p>
</li>
<li><p>当进行merge时，对git来说，如果我们没有设定当前分支的upstream，它并不知道我们要合并哪个分支到当前分支，所以我们需要通过下面的代码指定当前分支的upstream：</p>
<pre><code class="sh">git branch --set-upstream-to=origin/&lt;branch&gt; develop
</code></pre>
</li>
</ul>
<p>实际上，如果我们没有指定upstream，git在merge时会访问git config中当前分支(develop)merge的默认配置</p>
<pre><code class="sh">[branch &quot;develop&quot;]
    remote = origin
    merge = refs/heads/develop // [1]为什么不是refs/remotes/develop?

git config branch.develop.merge refs/heads/develop
</code></pre>
<blockquote>
<p>[1] 为什么merge = refs/heads/develop 而不是refs/remotes/develop?</p>
<p>因为这里merge指代的是我们想要merge的远程分支，是remote上的refs/heads/develop，文中即是origin上的refs/heads/develop，这和我们在本地直接执行<code>git merge</code>是不同的(本地执行<code>git merge origin/develop</code>则是直接merge refs/remotes/develop)。</p>
</blockquote>
<hr>
<p>回归问题，我遇到的问题其实是git push的默认行为不对。我的操作是通过修改.gitconfig 指定默认的push行为未current，对于pull操作，通过—track来指定pull的remote分支，我认为这样的一个好处是自由高，有一个场景：</p>
<blockquote>
<p>本地分支 需要 能push到远程并新建远程同名分支，只需要执行 <code>git push</code>；需要 pull 远程的master分支，只要执行<code>git pull</code> 。相当于做了一步默认分支指定。只需要在创建本地分支时候 —track 指定一下即可。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPC项目Websocketd服务器总结]]></title>
      <url>/2018/01/20/%E9%A1%B9%E7%9B%AE/IPC%E9%A1%B9%E7%9B%AEWebsocketd%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>工作需要，在16年写了个websocket服务器做实时推送音量。当时还没有找到C版的websocket，于是自己参考java写了个，功能比较简单，协议特性实现了实时，但是同步功能是靠开多线程实现，大PV可能不稳定，这块可以再优化管理。</p>
<p>这篇主要介绍一下原理，实现比较简单可参考我的github，如果使用主流服务器语言库也很多。</p>
<a id="more"></a>
<h1 id="C版websocketd服务器总结"><a href="#C版websocketd服务器总结" class="headerlink" title="C版websocketd服务器总结"></a>C版websocketd服务器总结</h1><h2 id="websocketd"><a href="#websocketd" class="headerlink" title="websocketd"></a>websocketd</h2><h3 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h3><h4 id="1-WebSocket-API简介"><a href="#1-WebSocket-API简介" class="headerlink" title="1. WebSocket API简介"></a>1. WebSocket API简介</h4><pre><code class="javascript">var ws = new WebSocket(“ws://echo.websocket.org”);  
ws.onopen = function(){ws.send(“Test!”); };  
ws.onmessage = function(evt){console.log(evt.data);ws.close();};  
ws.onclose = function(evt){console.log(“WebSocketClosed!”);};  
ws.onerror = function(evt){console.log(“WebSocketError!”);};
</code></pre>
<h4 id="2-为什么引入WebSocket协议"><a href="#2-为什么引入WebSocket协议" class="headerlink" title="2. 为什么引入WebSocket协议"></a>2. 为什么引入WebSocket协议</h4><h5 id="1-Polling"><a href="#1-Polling" class="headerlink" title="1. Polling"></a>1. Polling</h5><ul>
<li>既浪费了网络带宽，又浪费了CPU的利用率</li>
<li>实时性</li>
</ul>
<h5 id="2-Long-Polling"><a href="#2-Long-Polling" class="headerlink" title="2. Long Polling"></a>2. Long Polling</h5><ul>
<li>Browser显示实时数据最快的时间为2×RTT（往返时间）,网络拥塞</li>
<li>网络带宽浪费</li>
</ul>
<h5 id="3-WebSocket"><a href="#3-WebSocket" class="headerlink" title="3. WebSocket"></a>3. WebSocket</h5><p><img src="http://img.my.csdn.net/uploads/201202/27/0_133032795020RR.gif" alt=""></p>
<ol>
<li>Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用程序将收到错误消息通知。</li>
<li><p>在TCP建立连接成功后，Browser/UA通过http协议传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端。</p>
</li>
<li><p>WebSocket服务器收到Browser/UA发送来的握手请求后，如果数据包数据和格式正确，客户端和服务器端的协议版本号匹配等等，就接受本次握手连接，并给出相应的数据回复，同样回复的数据包也是采用http协议传输。</p>
</li>
<li>Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，此时Web开发者就可以在此时通过send接口想服务器发送数据。否则，握手连接失败，Web应用程序会收到onerror消息，并且能知道连接失败的原因。</li>
</ol>
<p>总结为：握手阶段 + 通信阶段</p>
<h3 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>客户端握手请求报头：</p>
<pre><code class="http">GET /chat HTTP/1.1  // 请求行
Host: server.example.com
Upgrade: websocket  // required
Connection: Upgrade // required
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== // required
Origin: http://example.com  // 用于防止未认证的跨域脚本使用浏览器 websocket api 与服务端进行通信
Sec-WebSocket-Protocol: chat, superchat  // optional, 子协议协商字段
Sec-WebSocket-Version: 13
</code></pre>
<p>服务端响应报头:</p>
<pre><code class="http">HTTP/1.1 101 Switching Protocols  // 状态行
Upgrade: websocket   // required
Connection: Upgrade  // required
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= // required
Sec-WebSocket-Protocol: chat // 表明选择的子协议
</code></pre>
<p>握手阶段，具体来讲，就是当浏览器脚本 new WebSocket(url) 后，浏览器对服务器发送一个协议升级的请求，请求中带有 Sec-WebSocket-Key 字段。</p>
<p>服务端接收到协议提升请求后对这个字段加上一个特定的 <strong>GUID</strong> 后做一次 sha1 运算，然后再获取结果的 base64 格式摘要，<strong>作为 Sec-WebSocket-Accept 响应头的值响应回客户端浏览器</strong>，就完成了握手。</p>
<h3 id="ws帧解码与编码"><a href="#ws帧解码与编码" class="headerlink" title="ws帧解码与编码"></a>ws帧解码与编码</h3><p>…</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>initSocket()，包括：</p>
<pre><code class="c">initSocket()
{
  gethostname
  socket
  setsockopt
  bind(curr_sock)
}
</code></pre>
<p>mainLoop()，包括：</p>
<pre><code class="c">while
{
      listen(curr_sock)
     select    //非阻塞，等待多个fd中至少一个就绪,测超时，测fd
    FD_ISSET(curr_sock)    //检查哪一个fd就绪
    {
          fork_sock = accept(curr_sock)    //用于读缓冲区
        fork()
        close(curr_sock);
        startChild()
    }
}
</code></pre>
<p>startChild()，包括：</p>
<pre><code class="c">startChild()
{
  while(1)
  {
    read
    1.握手：shakeHand

    2.解包
    decodeReceiveData
    switch(opcode)
      case：handleTextMsg + encodeSendData //组payload，前者是处理json，后者编码响应报文
    write(fork_sock)
  }
}
</code></pre>
<h3 id="一些浅显的思考"><a href="#一些浅显的思考" class="headerlink" title="一些浅显的思考"></a>一些浅显的思考</h3><h4 id="为什么websocket一直不火？"><a href="#为什么websocket一直不火？" class="headerlink" title="为什么websocket一直不火？"></a>为什么websocket一直不火？</h4><p>现在是18年了，距离websocket出现也有3年多了，可是国内很多公司好像都不待见。我认为可能有以下一些原因：</p>
<ul>
<li>技术框架不成熟，国内除了BAT很多担心技术壁垒踩坑，很多公司http切https都很少，更不要说http2、websocket这些了。</li>
<li>使用场景少，很少有需要实时+不断推送+安全性的数据流的场景，有兼容性等考虑。</li>
<li>B/S架构想变为C/S架构，已经不是http切成https那么简单了，有一种颠覆性的认识，需要改动的东西很多，参考java为什么还在存活且存活的最好。反而我认为ajax切fetch这种会更easy。</li>
</ul>
<h4 id="websocket使用场景？"><a href="#websocket使用场景？" class="headerlink" title="websocket使用场景？"></a>websocket使用场景？</h4><ul>
<li>长连接+实时</li>
<li>个人认为多用在少交互多展示的场景，倒不是协议的问题，比如后台要处理5s才能响应siri并普推，那么这5s的间隔是要优化的，这不是主要问题，主要问题是后台也要对延时性响应的要求怎么处理，一般放到队列处理那么最后一个被处理的websocket请求就会爆炸，当然普通的交互也有这个问题，但是普通交互没有实时性的要求。</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li>深入细化+优化</li>
<li>搭一套高效的框架，其中开一个websocket端口来专门分发实时展示页</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> websocket </tag>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《阮一峰--Redux 入门教程》笔记]]></title>
      <url>/2018/01/10/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/%E3%80%8A%E9%98%AE%E4%B8%80%E5%B3%B0--Redux%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Redux 入门教程学习笔记。</p>
<p>这篇文章讲的很好，配合官网文可以快速入门。</p>
<a id="more"></a>
<h1 id="《阮一峰–Redux-入门教程》笔记"><a href="#《阮一峰–Redux-入门教程》笔记" class="headerlink" title="《阮一峰–Redux 入门教程》笔记"></a>《阮一峰–Redux 入门教程》笔记</h1><h2 id="我的问题"><a href="#我的问题" class="headerlink" title="我的问题"></a>我的问题</h2><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>只是为为异步吗？那为什么不直接使用promise呢做thunk呢？使用细节呢</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>reducer的颗粒度才是最好</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>哪些state应该扔到store里，跨层多次使用就扔吗</p>
<hr>
<h2 id="Redux-入门教程"><a href="#Redux-入门教程" class="headerlink" title="Redux 入门教程"></a>Redux 入门教程</h2><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="external">阮一峰–Redux 入门教程</a></p>
<p>关于中间件部分不理解</p>
</blockquote>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>有两个方面，它没涉及。</p>
<blockquote>
<ul>
<li>代码结构</li>
<li>组件之间的通信</li>
</ul>
</blockquote>
<h4 id="零、你可能不需要-Redux"><a href="#零、你可能不需要-Redux" class="headerlink" title="零、你可能不需要 Redux"></a>零、你可能不需要 Redux</h4><p>Redux 的适用场景：多交互、多数据源。</p>
<blockquote>
<ul>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
<li>多个用户之间可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ul>
</blockquote>
<p>从组件角度看：</p>
<blockquote>
<ul>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ul>
</blockquote>
<h4 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h4><p>React + Flux + <a href="http://redux.js.org/" target="_blank" rel="external">文档</a> + 小视频（<a href="https://egghead.io/courses/getting-started-with-redux" target="_blank" rel="external">前30集</a>，<a href="https://egghead.io/courses/building-react-applications-with-idiomatic-redux" target="_blank" rel="external">后30集</a>）</p>
<h4 id="二、设计思想"><a href="#二、设计思想" class="headerlink" title="二、设计思想"></a>二、设计思想</h4><blockquote>
<p>（1）Web 应用是一个状态机，视图与状态是一一对应的。</p>
<p>（2）所有的状态，保存在一个对象里面。</p>
</blockquote>
<h4 id="三、基本概念和-API"><a href="#三、基本概念和-API" class="headerlink" title="三、基本概念和 API"></a>三、基本概念和 API</h4><h5 id="3-1-Store"><a href="#3-1-Store" class="headerlink" title="3.1 Store"></a>3.1 Store</h5><p>整个应用只能有一个 Store。</p>
<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>
<pre><code class="react">import { createStore } from &#39;redux&#39;;
const store = createStore(fn);
</code></pre>
<h5 id="3-2-State"><a href="#3-2-State" class="headerlink" title="3.2 State"></a>3.2 State</h5><p>如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。可以通过<code>store.getState()</code>拿到。</p>
<pre><code class="react">import { createStore } from &#39;redux&#39;;
const store = createStore(fn);

const state = store.getState();
</code></pre>
<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。</p>
<h5 id="3-3-Action"><a href="#3-3-Action" class="headerlink" title="3.3 Action"></a>3.3 Action</h5><p>State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。其他属性可以自由设置</p>
<pre><code class="react">const action = {
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
};
</code></pre>
<p>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
<h5 id="3-4-Action-Creator"><a href="#3-4-Action-Creator" class="headerlink" title="3.4 Action Creator"></a>3.4 Action Creator</h5><p>View 要发送多少种消息，就会有多少种 Action。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>
<pre><code class="react">const ADD_TODO = &#39;添加 TODO&#39;;

function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}

const action = addTodo(&#39;Learn Redux&#39;);
</code></pre>
<p><code>addTodo</code>函数就是一个 Action Creator。</p>
<h5 id="3-5-store-dispatch"><a href="#3-5-store-dispatch" class="headerlink" title="3.5 store.dispatch()"></a>3.5 store.dispatch()</h5><p><code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</p>
<pre><code class="react">store.dispatch({
  type: &#39;ADD_TODO&#39;,
  payload: &#39;Learn Redux&#39;
});
</code></pre>
<p><code>store.dispatch</code>接受一个 Action 对象作为参数，将它发送出去。</p>
<p>结合 Action Creator，这段代码可以改写如下。</p>
<pre><code class="react">store.dispatch(addTodo(&#39;Learn Redux&#39;));
</code></pre>
<h5 id="3-6-Reducer"><a href="#3-6-Reducer" class="headerlink" title="3.6 Reducer"></a>3.6 Reducer</h5><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<pre><code class="react">const reducer = function (state, action) {
  // ...
  return new_state;
};
</code></pre>
<p><code>store.dispatch</code>方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入<code>createStore</code>方法。</p>
<pre><code class="react">import { createStore } from &#39;redux&#39;;
const store = createStore(reducer);
</code></pre>
<p>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的<code>reduce</code>方法的参数。</p>
<h5 id="3-7-纯函数"><a href="#3-7-纯函数" class="headerlink" title="3.7 纯函数"></a>3.7 纯函数</h5><p>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<blockquote>
<ul>
<li>不得改写参数</li>
<li>不能调用系统 I/O 的API</li>
<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>
</ul>
</blockquote>
<p>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</p>
<pre><code class="react">// State 是一个对象
function reducer(state, action) {
  return Object.assign({}, state, { thingToChange });
  // 或者
  return { ...state, ...newState };
}

// State 是一个数组
function reducer(state, action) {
  return [...state, newItem];
}
</code></pre>
<p>最好把 State 对象设成只读。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</p>
<h5 id="3-8-store-subscribe"><a href="#3-8-store-subscribe" class="headerlink" title="3.8 store.subscribe()"></a>3.8 store.subscribe()</h5><p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p>
<pre><code class="react">import { createStore } from &#39;redux&#39;;
const store = createStore(reducer);

store.subscribe(listener);
</code></pre>
<p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。</p>
<p><code>store.subscribe</code>方法返回一个函数，调用这个函数就可以解除监听。</p>
<pre><code class="react">let unsubscribe = store.subscribe(() =&gt;
  console.log(store.getState())
);

unsubscribe();
</code></pre>
<h4 id="四、Store-的实现"><a href="#四、Store-的实现" class="headerlink" title="四、Store 的实现"></a>四、Store 的实现</h4><p>可以发现 Store 提供了三个方法。</p>
<ul>
<li>store.getState()</li>
<li>store.dispatch()</li>
<li>store.subscribe()</li>
</ul>
<pre><code class="react">import { createStore } from &#39;redux&#39;;
let { subscribe, dispatch, getState } = createStore(reducer);
</code></pre>
<p><code>createStore</code>方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。</p>
<pre><code class="react">let store = createStore(todoApp, window.STATE_FROM_SERVER)
</code></pre>
<p>注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。</p>
<p><code>createStore</code>方法的一个简单实现</p>
<pre><code class="react">const createStore = (reducer) =&gt; {
  let state;
  let listeners = [];

  const getState = () =&gt; state;

  const dispatch = (action) =&gt; {
    state = reducer(state, action);
    listeners.forEach(listener =&gt; listener());
  };

  const subscribe = (listener) =&gt; {
    listeners.push(listener);
    return () =&gt; {
      listeners = listeners.filter(l =&gt; l !== listener);
    }
  };

  dispatch({});

  return { getState, dispatch, subscribe };
};
</code></pre>
<h4 id="五、Reducer-的拆分"><a href="#五、Reducer-的拆分" class="headerlink" title="五、Reducer 的拆分"></a>五、Reducer 的拆分</h4><p>Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，导致 Reducer 函数也十分庞大。</p>
<pre><code class="react">const chatReducer = (state = defaultState, action = {}) =&gt; {
  return {
    chatLog: chatLog(state.chatLog, action),
    statusMessage: statusMessage(state.statusMessage, action),
    userName: userName(state.userName, action)
  }
};
</code></pre>
<p>这样一拆，Reducer 就易读易写多了。而且，这种拆分与 React 应用的结构相吻合：一个 React 根组件由很多子组件构成。这就是说，子组件与子 Reducer 完全可以对应。</p>
<p>Redux 提供了一个<code>combineReducers</code>方法，用于 Reducer 的拆分合成。</p>
<pre><code class="react">import { combineReducers } from &#39;redux&#39;;

const chatReducer = combineReducers({
  chatLog,
  statusMessage,
  userName
})

export default todoApp;
</code></pre>
<p>这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。</p>
<pre><code class="react">const reducer = combineReducers({
  a: doSomethingWithA,
  b: processB,
  c: c
})
</code></pre>
<p>可以把所有子 Reducer 放在一个文件里面，然后统一引入。</p>
<pre><code class="react">import { combineReducers } from &#39;redux&#39;
import * as reducers from &#39;./reducers&#39;

const reducer = combineReducers(reducers)
</code></pre>
<h4 id="六、工作流程"><a href="#六、工作流程" class="headerlink" title="六、工作流程"></a>六、工作流程</h4><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg" alt=""></p>
<p>首先，用户发出 Action。</p>
<pre><code class="react">store.dispatch(action);
</code></pre>
<p>Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。Reducer 会返回新的 State</p>
<pre><code class="react">let nextState = todoApp(previousState, action);
</code></pre>
<p>State 一旦有变化，Store 就会调用监听函数。</p>
<pre><code class="react">store.subscribe(listener);
</code></pre>
<p><code>listener</code>可以通过<code>store.getState()</code>得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p>
<pre><code class="react">function listerner() {
  let newState = store.getState();
  component.setState(newState);   
}
</code></pre>
<h4 id="七、实例：计数器"><a href="#七、实例：计数器" class="headerlink" title="七、实例：计数器"></a>七、实例：计数器</h4><h3 id="中间件与异步操作"><a href="#中间件与异步操作" class="headerlink" title="中间件与异步操作"></a>中间件与异步操作</h3><p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。</p>
<p>怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。</p>
<h4 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h4><p>如果要添加功能，你会在哪个环节添加？</p>
<blockquote>
<p>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</p>
<p>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</p>
<p>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</p>
</blockquote>
<p>中间件就是一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p>
<p>Case. <code>store.dispatch</code>进行了重定义，在发送 Action 前后添加了打印功能。</p>
<h4 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h4><p>常用的中间件都有现成的，只要引用别人写好的模块即可。介绍怎么使用中间件。</p>
<pre><code class="react">import { applyMiddleware, createStore } from &#39;redux&#39;;
import createLogger from &#39;redux-logger&#39;;
const logger = createLogger();

const store = createStore(
  reducer,
  applyMiddleware(logger)
);
</code></pre>
<p>有两点需要注意：</p>
<p>（1）<code>createStore</code>方法可以接受整个应用的初始状态作为参数，那样的话，<code>applyMiddleware</code>就是第三个参数了。</p>
<pre><code class="react">const store = createStore(
  reducer,
  initial_state,
  applyMiddleware(logger)
);
</code></pre>
<p>（2）中间件的次序有讲究。</p>
<pre><code class="react">const store = createStore(
  reducer,
  applyMiddleware(thunk, promise, logger)
);
</code></pre>
<p>比如，<code>logger</code>就一定要放在最后，否则输出结果会不正确。</p>
<h4 id="三、applyMiddleware"><a href="#三、applyMiddleware" class="headerlink" title="三、applyMiddleware()"></a>三、applyMiddleware()</h4><p>它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。</p>
<pre><code class="react">export default function applyMiddleware(...middlewares) {
  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {
    var store = createStore(reducer, preloadedState, enhancer);
    var dispatch = store.dispatch;
    var chain = [];

    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    };
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);

    return {...store, dispatch}
  }
}
</code></pre>
<p>上面代码中，所有中间件被放进了一个数组<code>chain</code>，然后嵌套执行，最后执行<code>store.dispatch</code>。可以看到，中间件内部（<code>middlewareAPI</code>）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法。</p>
<h4 id="四、异步操作的基本思路"><a href="#四、异步操作的基本思路" class="headerlink" title="四、异步操作的基本思路"></a>四、异步操作的基本思路</h4><p>同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。</p>
<ul>
<li>操作发起时的 Action</li>
<li>操作成功时的 Action</li>
<li>操作失败时的 Action</li>
</ul>
<p>以向服务器取出数据为例，三种 Action 可以有两种不同的写法。</p>
<pre><code>// 写法一：名称相同，参数不同
{ type: &#39;FETCH_POSTS&#39; }
{ type: &#39;FETCH_POSTS&#39;, status: &#39;error&#39;, error: &#39;Oops&#39; }
{ type: &#39;FETCH_POSTS&#39;, status: &#39;success&#39;, response: { ... } }

// 写法二：名称不同
{ type: &#39;FETCH_POSTS_REQUEST&#39; }
{ type: &#39;FETCH_POSTS_FAILURE&#39;, error: &#39;Oops&#39; }
{ type: &#39;FETCH_POSTS_SUCCESS&#39;, response: { ... } }
</code></pre><p>除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。</p>
<pre><code class="react">let state = {
  // ... 
  isFetching: true,
  didInvalidate: true,
  lastUpdated: &#39;xxxxxxx&#39;
};
</code></pre>
<h4 id="五、redux-thunk-中间件"><a href="#五、redux-thunk-中间件" class="headerlink" title="五、redux-thunk 中间件"></a>五、redux-thunk 中间件</h4><p>异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？</p>
<p>奥妙就在 Action Creator 之中。Action Creator（动作生成器）的例子：</p>
<pre><code class="react">const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; {
  dispatch(requestPosts(postTitle));
  return fetch(`/some/API/${postTitle}.json`)
    .then(response =&gt; response.json())
    .then(json =&gt; dispatch(receivePosts(postTitle, json)));
  };
};

// 使用方法一
store.dispatch(fetchPosts(&#39;reactjs&#39;));
// 使用方法二
store.dispatch(fetchPosts(&#39;reactjs&#39;)).then(() =&gt;
  console.log(store.getState())
);
</code></pre>
<p><code>fetchPosts</code>是一个Action Creator（动作生成器），返回一个函数。这个函数执行后，先发出一个Action（<code>requestPosts(postTitle)</code>），然后进行异步操作。拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ <code>receivePosts(postTitle, json)</code>）。</p>
<p>有几个地方需要注意。</p>
<blockquote>
<p>（1）<code>fetchPosts</code>返回了一个函数，而普通的 Action Creator 默认返回一个对象。</p>
<p>（2）返回的函数的参数是<code>dispatch</code>和<code>getState</code>这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。</p>
<p>（3）在返回的函数之中，先发出一个 Action（<code>requestPosts(postTitle)</code>），表示操作开始。</p>
<p>（4）异步操作结束之后，再发出一个 Action（<code>receivePosts(postTitle, json)</code>），表示操作结束。</p>
</blockquote>
<p>这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由<code>store.dispatch</code>方法发送的。而<code>store.dispatch</code>方法正常情况下，参数只能是对象，不能是函数。这时，就要使用中间件<a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="external"><code>redux-thunk</code></a>。</p>
<pre><code class="react">import { createStore, applyMiddleware } from &#39;redux&#39;;
import thunk from &#39;redux-thunk&#39;;
import reducer from &#39;./reducers&#39;;

// Note: this API requires redux@&gt;=3.1.0
const store = createStore(
  reducer,
  applyMiddleware(thunk)
);
</code></pre>
<p>上面代码使用<code>redux-thunk</code>中间件，改造<code>store.dispatch</code>，使得后者可以接受函数作为参数。</p>
<p>因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用<code>redux-thunk</code>中间件改造<code>store.dispatch</code>。</p>
<h4 id="六、redux-promise-中间件"><a href="#六、redux-promise-中间件" class="headerlink" title="六、redux-promise 中间件"></a>六、redux-promise 中间件</h4><p>另一种异步操作的解决方案，就是让 Action Creator 返回一个 Promise 对象。这就需要使用<code>redux-promise</code>中间件。</p>
<pre><code class="react">import { createStore, applyMiddleware } from &#39;redux&#39;;
import promiseMiddleware from &#39;redux-promise&#39;;
import reducer from &#39;./reducers&#39;;

const store = createStore(
  reducer,
  applyMiddleware(promiseMiddleware)
);
</code></pre>
<p>这个中间件使得<code>store.dispatch</code>方法可以接受 Promise 对象作为参数。这时，Action Creator 有两种写法。写法一，返回值是一个 Promise 对象。</p>
<pre><code class="react">const fetchPosts = 
  (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) {
     dispatch(requestPosts(postTitle));
     return fetch(`/some/API/${postTitle}.json`)
       .then(response =&gt; {
         type: &#39;FETCH_POSTS&#39;,
         payload: response.json()
       });
});
</code></pre>
<p>写法二，Action 对象的<code>payload</code>属性是一个 Promise 对象。这需要从<a href="https://github.com/acdlite/redux-actions" target="_blank" rel="external"><code>redux-actions</code></a>模块引入<code>createAction</code>方法，并且写法也要变成下面这样。</p>
<pre><code class="react">import { createAction } from &#39;redux-actions&#39;;

class AsyncApp extends Component {
  componentDidMount() {
    const { dispatch, selectedPost } = this.props
    // 发出同步 Action
    dispatch(requestPosts(selectedPost));
    // 发出异步 Action
    dispatch(createAction(
      &#39;FETCH_POSTS&#39;, 
      fetch(`/some/API/${postTitle}.json`)
        .then(response =&gt; response.json())
    ));
  }
</code></pre>
<p>上面代码中，第二个<code>dispatch</code>方法发出的是异步 Action，只有等到操作结束，这个 Action 才会实际发出。注意，<code>createAction</code>的第二个参数必须是一个 Promise 对象。</p>
<p><code>redux-promise</code>的<a href="https://github.com/acdlite/redux-promise/blob/master/src/index.js" target="_blank" rel="external">源码</a></p>
<pre><code class="react">export default function promiseMiddleware({ dispatch }) {
  return next =&gt; action =&gt; {
    if (!isFSA(action)) {
      return isPromise(action)
        ? action.then(dispatch)
        : next(action);
    }

    return isPromise(action.payload)
      ? action.payload.then(
          result =&gt; dispatch({ ...action, payload: result }),
          error =&gt; {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          }
        )
      : next(action);
  };
}
</code></pre>
<p>从上面代码可以看出，如果 Action 本身是一个 Promise，它 resolve 以后的值应该是一个 Action 对象，会被<code>dispatch</code>方法送出（<code>action.then(dispatch)</code>），但 reject 以后不会有任何动作；如果 Action 对象的<code>payload</code>属性是一个 Promise 对象，那么无论 resolve 和 reject，<code>dispatch</code>方法都会发出 Action。</p>
<h3 id="React-Redux-的用法"><a href="#React-Redux-的用法" class="headerlink" title="React-Redux 的用法"></a>React-Redux 的用法</h3><blockquote>
<p>为了方便使用，Redux 的作者封装了一个 React 专用的库 <a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">React-Redux</a>这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 React-Redux。</p>
</blockquote>
<h4 id="一、UI-组件"><a href="#一、UI-组件" class="headerlink" title="一、UI 组件"></a>一、UI 组件</h4><p>React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。</p>
<p>UI 组件有以下几个特征。</p>
<ul>
<li>只负责 UI 的呈现，不带有任何业务逻辑</li>
<li>没有状态（即不使用<code>this.state</code>这个变量）</li>
<li>所有数据都由参数（<code>this.props</code>）提供</li>
<li>不使用任何 Redux 的 API</li>
</ul>
<pre><code class="react">const Title =
  value =&gt; &lt;h1&gt;{value}&lt;/h1&gt;;
</code></pre>
<p>因为不含有状态，UI 组件又称为”纯组件”，即它纯函数一样，纯粹由参数决定它的值。</p>
<h4 id="二、容器组件"><a href="#二、容器组件" class="headerlink" title="二、容器组件"></a>二、容器组件</h4><p>容器组件的特征恰恰相反。</p>
<ul>
<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>
<li>带有内部状态</li>
<li>使用 Redux 的 API</li>
</ul>
<p>总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</p>
<p>如果一个组件既有 UI 又有业务逻辑，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p>
<p>React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</p>
<h4 id="三、connect"><a href="#三、connect" class="headerlink" title="三、connect()"></a>三、connect()</h4><p>React-Redux 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<pre><code class="react">import { connect } from &#39;react-redux&#39;
const VisibleTodoList = connect()(TodoList);
</code></pre>
<p>因为没有定义业务逻辑，上面这个容器组件毫无意义。为了定义业务逻辑，需要给出下面两方面的信息。</p>
<blockquote>
<p>（1）输入逻辑：外部的数据（即<code>state</code>对象）如何转换为 UI 组件的参数</p>
<p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p>
</blockquote>
<p><code>connect</code>方法的完整 API 如下。</p>
<pre><code class="react">import { connect } from &#39;react-redux&#39;

const VisibleTodoList = connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoList)
</code></pre>
<p><code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h4 id="四、mapStateToProps"><a href="#四、mapStateToProps" class="headerlink" title="四、mapStateToProps()"></a>四、mapStateToProps()</h4><p>它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。</p>
<p>作为函数，<code>mapStateToProps</code>执行后应该返回一个对象，里面的每一个键值对就是一个映射。</p>
<pre><code class="react">const mapStateToProps = (state) =&gt; {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
</code></pre>
<p>面代码中，<code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。这个对象有一个<code>todos</code>属性，代表 UI 组件的同名参数，后面的<code>getVisibleTodos</code>也是一个函数，可以从<code>state</code>算出 <code>todos</code> 的值。</p>
<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<pre><code class="react">// 容器组件的代码
//    &lt;FilterLink filter=&quot;SHOW_ALL&quot;&gt;
//      All
//    &lt;/FilterLink&gt;

const mapStateToProps = (state, ownProps) =&gt; {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}
</code></pre>
<p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p>
<p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
<h4 id="五、mapDispatchToProps"><a href="#五、mapDispatchToProps" class="headerlink" title="五、mapDispatchToProps()"></a>五、mapDispatchToProps()</h4><p><code>mapDispatchToProps</code>是用来建立 UI 组件的参数到<code>store.dispatch</code>方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code>（容器组件的<code>props</code>对象）两个参数。</p>
<pre><code class="react">const mapDispatchToProps = (
  dispatch,
  ownProps
) =&gt; {
  return {
    onClick: () =&gt; {
      dispatch({
        type: &#39;SET_VISIBILITY_FILTER&#39;,
        filter: ownProps.filter
      });
    }
  };
}
</code></pre>
<p>从上面代码可以看到，<code>mapDispatchToProps</code>作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说</p>
<pre><code class="react">const mapDispatchToProps = {
  onClick: (filter) =&gt; {
    type: &#39;SET_VISIBILITY_FILTER&#39;,
    filter: filter
  };
}
</code></pre>
<h4 id="六、-lt-Provider-gt-组件"><a href="#六、-lt-Provider-gt-组件" class="headerlink" title="六、&lt;Provider&gt; 组件"></a>六、<code>&lt;Provider&gt;</code> 组件</h4><p><code>connect</code>方法生成容器组件以后，需要让容器组件拿到<code>state</code>对象，才能生成 UI 组件的参数。</p>
<p>一种解决方法是将<code>state</code>对象作为参数，传入容器组件。但是，这样做比较麻烦，尤其是容器组件可能在很深的层级，一级级将<code>state</code>传下去就很麻烦。</p>
<p>React-Redux 提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code>。</p>
<pre><code class="react">import { Provider } from &#39;react-redux&#39;
import { createStore } from &#39;redux&#39;
import todoApp from &#39;./reducers&#39;
import App from &#39;./components/App&#39;

let store = createStore(todoApp);

render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
)
</code></pre>
<p><code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。它的原理是<code>React</code>组件的<a href="https://facebook.github.io/react/docs/context.html" target="_blank" rel="external"><code>context</code></a>属性，请看源码。</p>
<pre><code class="react">class Provider extends Component {
  getChildContext() {
    return {
      store: this.props.store
    };
  }
  render() {
    return this.props.children;
  }
}

Provider.childContextTypes = {
  store: React.PropTypes.object
}
</code></pre>
<p>上面代码中，<code>store</code>放在了上下文对象<code>context</code>上面。然后，子组件就可以从<code>context</code>拿到<code>store</code>，样例代码大致如下。</p>
<pre><code class="react">class VisibleTodoList extends Component {
  componentDidMount() {
    const { store } = this.context;
  }

  render() {
    const props = this.props;
    const { store } = this.context;
    const state = store.getState();
    // ...
  }
}
</code></pre>
<p><code>React-Redux</code>自动生成的容器组件的代码，就类似上面这样，从而拿到<code>store</code>。</p>
<h4 id="七、实例：计数器-1"><a href="#七、实例：计数器-1" class="headerlink" title="七、实例：计数器"></a>七、实例：计数器</h4><p>一个计数器组件，它是一个纯的 UI 组件。</p>
<pre><code class="react">class Counter extends Component {
  render() {
    const { value, onIncreaseClick } = this.props
    return (
      &lt;div&gt;
        &lt;span&gt;{value}&lt;/span&gt;
        &lt;button onClick={onIncreaseClick}&gt;Increase&lt;/button&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>这个 UI 组件有两个参数：<code>value</code>和<code>onIncreaseClick</code>。前者需要从<code>state</code>计算得到，后者需要向外发出 Action。</p>
<p>定义<code>value</code>到<code>state</code>的映射，以及<code>onIncreaseClick</code>到<code>dispatch</code>的映射。</p>
<pre><code class="react">function mapStateToProps(state) {
  return {
    value: state.count
  }
}

function mapDispatchToProps(dispatch) {
  return {
    onIncreaseClick: () =&gt; dispatch(increaseAction)
  }
}

// Action Creator
const increaseAction = { type: &#39;increase&#39; }
</code></pre>
<p>然后，使用<code>connect</code>方法生成容器组件。</p>
<pre><code class="react">const App = connect(
  mapStateToProps,
  mapDispatchToProps
)(Counter)
</code></pre>
<p>定义这个组件的 Reducer</p>
<pre><code class="react">// Reducer
function counter(state = { count: 0 }, action) {
  const count = state.count
  switch (action.type) {
    case &#39;increase&#39;:
      return { count: count + 1 }
    default:
      return state
  }
}
</code></pre>
<p>最后，生成<code>store</code>对象，并使用<code>Provider</code>在根组件外面包一层</p>
<pre><code class="react">
import { loadState, saveState } from &#39;./localStorage&#39;;

const persistedState = loadState();
const store = createStore(
  todoApp,
  persistedState
);

store.subscribe(throttle(() =&gt; {
  saveState({
    todos: store.getState().todos,
  })
}, 1000))

ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre>
<p>概括</p>
<pre><code class="react">// 1.React component: 独立
// 2.Action:3 相对独立
// 3.Reducer:2 相对独立
// 4.Store:3
// 5.Map Redux state to component props:1
// 6.Map Redux actions to component props:1,2
// 7.Connected Component:5+6,1
</code></pre>
<h4 id="八、React-Router-路由库"><a href="#八、React-Router-路由库" class="headerlink" title="八、React-Router 路由库"></a>八、React-Router 路由库</h4><p>使用<code>React-Router</code>的项目，与其他项目没有不同之处，也是使用<code>Provider</code>在<code>Router</code>外面包一层，毕竟<code>Provider</code>的唯一功能就是传入<code>store</code>对象。</p>
<pre><code class="react">const Root = ({ store }) =&gt; (
  &lt;Provider store={store}&gt;
    &lt;Router&gt;
      &lt;Route path=&quot;/&quot; component={App} /&gt;
    &lt;/Router&gt;
  &lt;/Provider&gt;
);
</code></pre>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之AJAX]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8BAJAX/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>AJAX问题在面试中必问。但其实又很简单。本文介绍一些手写代码。</p>
<p>面试的AJAX部分，需要掌握：</p>
<blockquote>
<ul>
<li>能手写，知道一些重要参数</li>
</ul>
</blockquote>
<p>TODO：</p>
<blockquote>
<ul>
<li>补充fetch等并对比</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之AJAX"><a href="#面试重点之AJAX" class="headerlink" title="面试重点之AJAX"></a>面试重点之AJAX</h1><h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p>
<h2 id="XMLHttpRequest对象的常用方法和属性"><a href="#XMLHttpRequest对象的常用方法和属性" class="headerlink" title="XMLHttpRequest对象的常用方法和属性"></a>XMLHttpRequest对象的常用方法和属性</h2><p><strong>方法</strong></p>
<p><code>open(“method”,”URL”)</code> 建立对服务器的调用，第一个参数是HTTP请求方式可以为GET，POST或任何服务器所支持的您想调用的方式。第二个参数是请求页面的URL。</p>
<p><code>send()</code>方法，发送具体请求</p>
<p><code>abort()</code>方法，停止当前请求</p>
<p><strong>属性</strong></p>
<p><code>readyState</code>属性：请求的状态，有5个可取值</p>
<ul>
<li>0=未初始化</li>
<li>1=正在加载</li>
<li>2=已加载</li>
<li>3=交互中</li>
<li>4=完成</li>
</ul>
<p><code>responseText</code>属性：服务器的响应，表示为一个串</p>
<p><code>reponseXML</code> 属性：服务器的响应，表示为XML</p>
<p><code>status</code>属性：服务器的HTTP状态码，200对应ok，400对应error</p>
<h2 id="原生js-ajax实现"><a href="#原生js-ajax实现" class="headerlink" title="原生js ajax实现"></a>原生js ajax实现</h2><pre><code class="javascript">$(&#39;#send&#39;).click(function(){
    //请求的5个阶段，对应readyState的值
        //0: 未初始化，send方法未调用；
        //1: 正在发送请求，send方法已调用；
        //2: 请求发送完毕，send方法执行完毕；
        //3: 正在解析响应内容；
        //4: 响应内容解析完毕；
    var data = &#39;name=yang&#39;;
    var xhr = new XMLHttpRequest();   //创建一个ajax对象
    xhr.onreadystatechange = function(event){    //对ajax对象进行监听
        if(xhr.readyState == 4){    //4表示解析完毕
            if(xhr.status == 200){    //200为正常返回
                console.log(xhr)
            }
        }
    };
    xhr.open(&#39;POST&#39;,&#39;url&#39;,true);    //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步
    xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);    //可有可无
    xhr.send(data);        //发送
});
</code></pre>
<h2 id="jquery-ajax实现"><a href="#jquery-ajax实现" class="headerlink" title="jquery ajax实现"></a>jquery ajax实现</h2><pre><code class="javascript">$.ajax({
    url:&#39;/comm/test1.php&#39;,
    type:&#39;POST&#39;, //GET
    async:true,    //或false,是否异步
    data:{
        name:&#39;yang&#39;,age:25
    },
    timeout:5000,    //超时时间
    dataType:&#39;json&#39;,    //返回的数据格式：json/xml/html/script/jsonp/text
    beforeSend:function(xhr){
        console.log(xhr)
        console.log(&#39;发送前&#39;)
    },
    success:function(data,textStatus,jqXHR){
        console.log(data)
        console.log(textStatus)
        console.log(jqXHR)
    },
    error:function(xhr,textStatus){
        console.log(&#39;错误&#39;)
        console.log(xhr)
        console.log(textStatus)
    },
    complete:function(){
        console.log(&#39;结束&#39;)
    }
})
</code></pre>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> AJAX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之跨域]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8B%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>跨域问题已经在面试中必问甚至手写。</p>
<p>面试的跨域部分，需要掌握以下：</p>
<blockquote>
<ul>
<li>每种实现过，并知道有哪些细节和坑</li>
</ul>
</blockquote>
<p>TODO：</p>
<blockquote>
<ul>
<li>贴实现代码</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之跨域"><a href="#面试重点之跨域" class="headerlink" title="面试重点之跨域"></a>面试重点之跨域</h1><h2 id="跨域方式"><a href="#跨域方式" class="headerlink" title="跨域方式"></a>跨域方式</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>script标签src属性中的链接却可以访问跨域的js脚本，</p>
<p>一般后端设置callback ，前端给后台接口中传一个callback 就可以。</p>
<p>JSONP 原理是加载一个 script，并执行一段回调 JS ，因为加载 JS 不需要遵循同源策略。使用这种技术服务器会接受回调函数名作为请求参数，并将JSON数据填充进回调函数中去。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>$.ajax</strong></p>
<pre><code class="javascript">$.ajax({  
        url:&quot;&quot;,  
        type:&quot;get&quot;,  
        dataType:&quot;jsonp&quot;,
          jsonp: &quot;callback&quot;,//服务端用于接收callback调用的function名的参数【后台接受什么参数，我们就传什么参数】我们上面设置是callback
        success:function(data){},
        error:function(XMLHttpRequest, textStatus, errorThrown){}  
    });
</code></pre>
<h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>无法发送post请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>使用比较方便；它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；</li>
<li>兼容性更好，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>在请求完毕后可以通过调用callback的方式回传结果。</li>
</ul>
<h3 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2.document.domain"></a>2.document.domain</h3><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p><a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 和 <a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a> </p>
<pre><code class="javascript">document.domain = &#39;damonare.cn&#39;;//设置成主域
document.domain = &#39;damonare.cn&#39;;//在iframe载入这个页面也设置document.domain
</code></pre>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。</li>
<li>如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</li>
</ol>
<h3 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h3><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>CORS要前后端同时做配置。</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>纯js的ajax请求。</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest(); //ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
xhr.open(&quot;￼GET&quot;, &quot;/haorooms&quot;,true);
xhr.send();
</code></pre>
<p>以上的haorooms是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest();//ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
xhr.open(&quot;￼GET&quot;, &quot;http://www.haorooms.com/CORS&quot;,true);
xhr.send();
</code></pre>
<p>当然，你也可以用jquery的ajax进行。</p>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>PHP：只需要使用如下的代码设置即可。</p>
<pre><code class="php"> header(&quot;Access-Control-Allow-Origin:http://www.haorooms.com&quot;);
</code></pre>
<h3 id="4-window-name"><a href="#4-window-name" class="headerlink" title="4.window.name"></a>4.window.name</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的</p>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>1.在应用页面（a.com/app.html）中创建一个iframe，把其src指向数据页面（b.com/data.html）。</p>
<pre><code class="html">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.google.com/iframe.html&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>2.在应用页面（a.com/app.html）中监听iframe的onload事件，在此事件中设置这个iframe的src指向本地域的代理文件（代理文件和应用页面在同一域下，所以可以相互通信）。</p>
<pre><code class="javascript">var iframe = document.getElementById(&#39;iframe&#39;);
var data = &#39;&#39;;

iframe.onload = function() {
    iframe.onload = function(){
        data = iframe.contentWindow.name;
    }
    iframe.src = &#39;about:blank&#39;;
};
</code></pre>
<p>3.获取数据以后销毁这个iframe，释放内存；</p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    iframe.contentWindow.document.write(&#39;&#39;);
    iframe.contentWindow.close();
    document.body.removeChild(iframe);
&lt;/script&gt;
</code></pre>
<h3 id="5-HTML5的window-postMessage"><a href="#5-HTML5的window-postMessage" class="headerlink" title="5.HTML5的window.postMessage"></a>5.HTML5的window.postMessage</h3><p>MessageEvent对象有三个重要属性：data用于获取数据，source用于获取发送消息的窗口对象，origin用于获取发送消息的源。</p>
<h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>A页面通过postMessage方法发送消息：</p>
<pre><code class="javascript">window.onload = function() {  
    var ifr = document.getElementById(&#39;ifr&#39;);  
    var targetOrigin = &quot;http://www.google.com&quot;;  
    ifr.contentWindow.postMessage(&#39;hello world!&#39;, targetOrigin);  
};
</code></pre>
<p>B页面通过message事件监听并接受消息:</p>
<pre><code class="javascript">var onmessage = function (event) {  
  var data = event.data;//消息  
  var origin = event.origin;//消息来源地址  
  var source = event.source;//源Window对象  
  if(origin==&quot;http://www.baidu.com&quot;){  
    console.log(data);//hello world!  
  }  
};  
if (typeof window.addEventListener != &#39;undefined&#39;) {  
  window.addEventListener(&#39;message&#39;, onmessage, false);  
} else if (typeof window.attachEvent != &#39;undefined&#39;) {  
  //for ie  
  window.attachEvent(&#39;onmessage&#39;, onmessage);  
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之异步]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8B%E5%BC%82%E6%AD%A5/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>异步问题在面试中必问。本文只介绍JS异步基础原理。</p>
<p>面试的异步部分，需要掌握以下：</p>
<blockquote>
<ul>
<li>异步实现原理</li>
<li>几种常用异步机制的实现</li>
</ul>
</blockquote>
<p>TODO：</p>
<blockquote>
<ul>
<li>其他几种异步待补充</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之异步"><a href="#面试重点之异步" class="headerlink" title="面试重点之异步"></a>面试重点之异步</h1><h2 id="JS异步原理-事件-队列"><a href="#JS异步原理-事件-队列" class="headerlink" title="JS异步原理(事件,队列)"></a>JS异步原理(事件,队列)</h2><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><ul>
<li>JS执行时会形成调用栈,调用一个函数时,返回地址、参数、本地变量都会被推入栈中,如果当前正在运行的函数中调用另外一个函数,则该函数相关内容也会被推入栈顶.该函数执行完毕,则会被弹出调用栈.变量也随之弹出,由于复杂类型值存放于堆中,因此弹出的只是指针,他们的值依然在堆中,由GC决定回收.</li>
<li>尾调用:指某个函数的最后一步是调用另一个函数。由调用栈可知,调用栈中有a函数,如果a函数调用b函数,则b函数也随之入栈,此时栈中就会有两个函数.但是如果b函数是a函数最后一步,并且不需保留外层函数调用记录,即a函数调用位置变量等都不需要用到,则该调用栈中会只保留b函数,这就叫做”尾调用优化”（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是”尾调用优化”的意义。</li>
</ul>
<h3 id="事件循环-event-loop-和任务队列-task-queue"><a href="#事件循环-event-loop-和任务队列-task-queue" class="headerlink" title="事件循环(event loop)和任务队列(task queue)"></a>事件循环(event loop)和任务队列(task queue)</h3><ul>
<li>JS的异步机制由事件循环和任务队列构成.JS本身是单线程语言,所谓异步依赖于浏览器或者操作系统等完成. JavaScript 主线程拥有一个执行栈以及一个任务队列，主线程会依次执行代码，当遇到函数时，会先将函数入栈，函数运行完毕后再将该函数出栈，直到所有代码执行完毕。</li>
<li>遇到异步操作（例如：setTimeout, AJAX）时，异步操作会由浏览器(OS)执行，浏览器会在这些任务完成后，将事先定义的回调函数推入主线程的任务队列(task queue)中,当主线程的执行栈清空之后会读取task queue中的回调函数,当task queue被读取完毕之后,主线程接着执行,从而进入一个无限的循环,这就是事件循环.</li>
</ul>
<h3 id="Microtask-与-Macrotask"><a href="#Microtask-与-Macrotask" class="headerlink" title="Microtask 与 Macrotask"></a>Microtask 与 Macrotask</h3><ul>
<li>一个浏览器环境（unit of related similar-origin browsing contexts.）只能有一个事件循环（Event loop），而一个事件循环可以多个任务队列（Task queue），每个任务都有一个任务源（Task source）。例如,客户端可能实现了一个包含鼠标键盘事件的任务队列，还有其他的任务队列，而给鼠标键盘事件的任务队列更高优先级，例如75%的可能性执行它。这样就能保证流畅的交互性，而且别的任务也能执行到了。但是，同一个任务队列中的任务必须按先进先出的顺序执行。多个任务队列，是为了方便控制优先级。任务队列是一个先进先出的队列.</li>
<li>macrotask 和 microtask 是异步任务的两种分类。在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，执行完毕后取出 microtask 队列中的所有任务顺序执行；之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。</li>
<li>全部代码(script)是一个macrotask,js先执行一个macrotask,执行过程中遇到(setTimeout, setInterval, setImmediate等)异步操作则创建一个macrotask,遇到(process.nextTick, Promises等)创建一个microtask,这两个queue分别被挂起.执行栈为空时开始处理macrotask,完成后处理microtask,直到该microtask全部执行完,然后继续主线程调用栈.</li>
</ul>
<p>注:每一次事件循环（one cycle of the event loop），只处理一个 (macro)task。待该 macrotask 完成后，所有的 microtask 会在同一次循环中处理。处理这些 microtask 时，还可以将更多的 microtask 入队，它们会一一执行，直到整个 microtask 队列处理完。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 异步 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端面试重点]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>前端面试一定要准备，准备不只是为了面试，让自己的知识线串成网才是重点，工作的技术可能很杂乱，由于大概率的定向工作导致技术点也会偏重一块而忽略一些东西。</p>
<p>本文是按照我个人面试的一些经历，总结的关于前端基础部分的一些面试比重，可以有重点的去针对，这些大部分也都是工作中的重点。</p>
<p>关于框架、架构部分，由于本人经历尚浅，这部分大都只有一些面试的概念，会附在文末。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="HTML-C"><a href="#HTML-C" class="headerlink" title="HTML(C)"></a>HTML(C)</h2><h3 id="HTML基础-C"><a href="#HTML基础-C" class="headerlink" title="HTML基础(C)"></a>HTML基础(C)</h3><h4 id="标准-C"><a href="#标准-C" class="headerlink" title="标准(C)"></a>标准(C)</h4><ul>
<li>结构、表现、行为</li>
</ul>
<h4 id="内核-C"><a href="#内核-C" class="headerlink" title="内核(C)"></a>内核(C)</h4><ul>
<li><p>渲染引擎和JS引擎</p>
</li>
<li><p>Trident内核：IE; Gecko内核：FireFox;Presto、Blink内核内核：Opera；Webkit内核：Safari，Chrome</p>
</li>
</ul>
<h4 id="语义化-C"><a href="#语义化-C" class="headerlink" title="语义化(C)"></a>语义化(C)</h4><p>header、footer、aside、article</p>
<ul>
<li>有利于seo</li>
<li>方便其他设备监听 屏幕阅读设备 盲人阅读器</li>
<li>方便团队协作开发</li>
</ul>
<h3 id="标准模式与兼容模式-C"><a href="#标准模式与兼容模式-C" class="headerlink" title="标准模式与兼容模式(C)"></a>标准模式与兼容模式(C)</h3><h3 id="加载顺序-C"><a href="#加载顺序-C" class="headerlink" title="加载顺序(C)"></a>加载顺序(C)</h3><ul>
<li>html需要等head中所有的js和css加载完成后才会开始绘制，但是html不需要等待放在body最后的js下载执行就会开始绘制,因此将js放在body的最后面，可以避免资源阻塞</li>
<li>defer</li>
</ul>
<h2 id="H5-C"><a href="#H5-C" class="headerlink" title="H5(C)"></a>H5(C)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>SGML、XML、HTML关系(C)</li>
<li>页面结构: <code>&lt;header&gt;、&lt;footer&gt;、&lt;nav&gt;</code>(C)</li>
</ul>
<ul>
<li>新的 API(C)</li>
</ul>
<h3 id="多媒体-C"><a href="#多媒体-C" class="headerlink" title="多媒体(C)"></a>多媒体(C)</h3><ul>
<li>音频(C)</li>
<li>视频(C)</li>
<li>其他媒体标签(C)</li>
</ul>
<h3 id="拖放-C"><a href="#拖放-C" class="headerlink" title="拖放(C)"></a>拖放(C)</h3><h3 id="Canvas-amp-SVG-B"><a href="#Canvas-amp-SVG-B" class="headerlink" title="Canvas &amp; SVG(B)"></a>Canvas &amp; SVG(B)</h3><ul>
<li>简单介绍</li>
<li>对比</li>
</ul>
<h3 id="地理定位-C"><a href="#地理定位-C" class="headerlink" title="地理定位(C)"></a>地理定位(C)</h3><h3 id="Web存储-B"><a href="#Web存储-B" class="headerlink" title="Web存储(B)"></a>Web存储(B)</h3><ul>
<li>本地存储和cookies区别(B)</li>
<li>API</li>
</ul>
<h3 id="应用缓存-C"><a href="#应用缓存-C" class="headerlink" title="应用缓存(C)"></a>应用缓存(C)</h3><h3 id="Web-Workers-C"><a href="#Web-Workers-C" class="headerlink" title="Web Workers (C)"></a>Web Workers (C)</h3><ul>
<li>API</li>
</ul>
<h3 id="服务器发送事件-C"><a href="#服务器发送事件-C" class="headerlink" title="服务器发送事件(C)"></a>服务器发送事件(C)</h3><ul>
<li>API</li>
</ul>
<h3 id="WebSQL-C"><a href="#WebSQL-C" class="headerlink" title="WebSQL(C)"></a>WebSQL(C)</h3><h3 id="History-C"><a href="#History-C" class="headerlink" title="History(C)"></a>History(C)</h3><ul>
<li>History API</li>
</ul>
<h3 id="表单元素-C"><a href="#表单元素-C" class="headerlink" title="表单元素(C)"></a>表单元素(C)</h3><ul>
<li>keygen 元素</li>
<li>表单属性</li>
<li>datalist</li>
<li>表单元素</li>
<li>输出元素</li>
</ul>
<h2 id="CSS-B"><a href="#CSS-B" class="headerlink" title="CSS(B)"></a>CSS(B)</h2><h3 id="布局-A"><a href="#布局-A" class="headerlink" title="布局(A)"></a>布局(A)</h3><h4 id="流动布局"><a href="#流动布局" class="headerlink" title="流动布局"></a>流动布局</h4><ul>
<li>垂直水平居中实现</li>
</ul>
<h4 id="浮动布局-A"><a href="#浮动布局-A" class="headerlink" title="浮动布局(A)"></a>浮动布局(A)</h4><ul>
<li>清除浮动(A)</li>
</ul>
<h4 id="绝对定位布局-A"><a href="#绝对定位布局-A" class="headerlink" title="绝对定位布局(A)"></a>绝对定位布局(A)</h4><ul>
<li>static</li>
<li>relative</li>
<li>fixed</li>
<li>absolute</li>
</ul>
<h4 id="Flex布局-B"><a href="#Flex布局-B" class="headerlink" title="Flex布局(B)"></a>Flex布局(B)</h4><ul>
<li>justify-content、align-items</li>
</ul>
<h4 id="响应式布局-A"><a href="#响应式布局-A" class="headerlink" title="响应式布局 (A)"></a>响应式布局 (A)</h4><h3 id="盒子模型-B"><a href="#盒子模型-B" class="headerlink" title="盒子模型(B)"></a>盒子模型(B)</h3><ul>
<li>IE盒模型和W3C盒模型</li>
</ul>
<h3 id="定位机制-C"><a href="#定位机制-C" class="headerlink" title="定位机制(C)"></a>定位机制(C)</h3><ul>
<li>标准文档流</li>
<li>浮动</li>
<li>绝对定位</li>
</ul>
<h3 id="选择器-C"><a href="#选择器-C" class="headerlink" title="选择器(C)"></a>选择器(C)</h3><ul>
<li>分类</li>
<li>优先级</li>
</ul>
<h3 id="CSS3-C"><a href="#CSS3-C" class="headerlink" title="CSS3(C)"></a>CSS3(C)</h3><h3 id="兼容性-C"><a href="#兼容性-C" class="headerlink" title="兼容性(C)"></a>兼容性(C)</h3><ul>
<li>内外补丁不同</li>
<li>上下margin重合</li>
<li>IE6双倍边距</li>
</ul>
<h3 id="Hack-C"><a href="#Hack-C" class="headerlink" title="Hack(C)"></a>Hack(C)</h3><ul>
<li>IE条件注释法</li>
<li>CSS属性前缀法</li>
<li>选择器前缀法</li>
</ul>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="表达式与运算符"><a href="#表达式与运算符" class="headerlink" title="表达式与运算符 (?)"></a>表达式与运算符 (?)</h3><h3 id="继承-A"><a href="#继承-A" class="headerlink" title="继承(A)"></a>继承(A)</h3><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><ul>
<li>父类原型对象没法继承的</li>
</ul>
<h4 id="原型链式继承"><a href="#原型链式继承" class="headerlink" title="原型链式继承"></a>原型链式继承</h4><ul>
<li>引用类型会共享</li>
<li>构造子类型无法向超类型构造函数传参</li>
</ul>
<h4 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h4><ul>
<li>两次调用父类构造函数</li>
<li>子类继承父类的属性，第二次一组在子类实例上，第一次一组在子类原型上（在子类原型上创建不必要的多余的属性）效率低 </li>
</ul>
<h3 id="上下文-B"><a href="#上下文-B" class="headerlink" title="上下文(B)"></a>上下文(B)</h3><h4 id="this-B"><a href="#this-B" class="headerlink" title="this(B)"></a>this(B)</h4><ul>
<li>this 永远指向最后调用它的那个对象</li>
<li>箭头函数的 this 始终指向函数定义时的 this，而非执行时。(最近一层非箭头函数的 this，否则为undefined)</li>
</ul>
<h4 id="call-apply-bind-B"><a href="#call-apply-bind-B" class="headerlink" title="call apply bind(B)"></a>call apply bind(B)</h4><ul>
<li>bind方法的返回值是函数, 要手动去调用</li>
<li>区别</li>
</ul>
<h3 id="闭包-A"><a href="#闭包-A" class="headerlink" title="闭包(A)"></a>闭包(A)</h3><ul>
<li>闭包定义</li>
<li>应用场景</li>
<li>闭包问题</li>
</ul>
<h3 id="面向对象-B"><a href="#面向对象-B" class="headerlink" title="面向对象(B)"></a>面向对象(B)</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="私有属性-B"><a href="#私有属性-B" class="headerlink" title="私有属性(B)"></a>私有属性(B)</h4><h3 id="内存泄漏-B"><a href="#内存泄漏-B" class="headerlink" title="内存泄漏(B)"></a>内存泄漏(B)</h3><h4 id="js的回收机制"><a href="#js的回收机制" class="headerlink" title="js的回收机制"></a>js的回收机制</h4><ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h4 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h4><ul>
<li>全局变量</li>
<li>闭包</li>
<li>超出DOM引用</li>
<li>被遗忘的定时器或者回调</li>
</ul>
<h3 id="数据类型-B"><a href="#数据类型-B" class="headerlink" title="数据类型(B)"></a>数据类型(B)</h3><h4 id="String-C"><a href="#String-C" class="headerlink" title="String(C)"></a>String(C)</h4><ul>
<li>String()能实现 toString()，可以对 null 和undefined进行操作</li>
</ul>
<h4 id="包装对象-C"><a href="#包装对象-C" class="headerlink" title="包装对象(C)"></a>包装对象(C)</h4><ul>
<li>每次使用都创建一次，然后销毁。这个临时对象就是包装对象</li>
</ul>
<h4 id="类型转换-B"><a href="#类型转换-B" class="headerlink" title="类型转换(B)"></a>类型转换(B)</h4><ul>
<li>对象转为字符串：toString + valueOf</li>
<li>对象转为数字：valueOf + toString</li>
<li>在”显示“相关操作中会优先调用toString方法，而在运算相关操作中会优先调用valueOf方法</li>
</ul>
<h4 id="判断数据类型-B"><a href="#判断数据类型-B" class="headerlink" title="判断数据类型(B)"></a>判断数据类型(B)</h4><ul>
<li>typeof运算符</li>
<li>instanceof操作符</li>
</ul>
<h3 id="JSON-C"><a href="#JSON-C" class="headerlink" title="JSON(C)"></a>JSON(C)</h3><h4 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h4><ul>
<li>字符串转对象: JSON.parse</li>
<li>对象转字符串: JSON.stringify</li>
<li>数组转字符串:  JSON.stringify($(array))</li>
<li>字符串转数组</li>
</ul>
<h3 id="http-B"><a href="#http-B" class="headerlink" title="http(B)"></a>http(B)</h3><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ul>
<li>三次握手</li>
</ul>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><ul>
<li>GET, POST, PUT, DELETE, HEAD, TRACE, CONNECTs</li>
</ul>
<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><p>HTTP响应同样可分为Header和Body</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><h4 id="HTTP消息报头"><a href="#HTTP消息报头" class="headerlink" title="HTTP消息报头"></a>HTTP消息报头</h4><h5 id="普通报头"><a href="#普通报头" class="headerlink" title="普通报头"></a>普通报头</h5><ul>
<li>Cache-Control</li>
<li>Date</li>
<li>Connection</li>
</ul>
<h5 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h5><ul>
<li>Accept</li>
<li>Accept-Encoding</li>
<li>Host</li>
</ul>
<h5 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h5><ul>
<li>Location</li>
<li>Server</li>
</ul>
<h5 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h5><ul>
<li>Content-Encoding</li>
<li>Content-Type</li>
<li>Last-Modified</li>
<li>Expires</li>
</ul>
<h4 id="Cookie-A"><a href="#Cookie-A" class="headerlink" title="Cookie(A)"></a>Cookie(A)</h4><h5 id="流程-A"><a href="#流程-A" class="headerlink" title="流程(A)"></a>流程(A)</h5><ul>
<li>客户端第一次没有Cookie</li>
<li>服务器端生成Cookie，响应报文Set-Cookie</li>
<li>客户端请求报文加入Cookie</li>
<li>服务器端对比Cookie</li>
</ul>
<h3 id="原型和原型链-B-？"><a href="#原型和原型链-B-？" class="headerlink" title="原型和原型链(B)？"></a>原型和原型链(B)？</h3><h5 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h5><ul>
<li>Array.<strong>proto</strong> === Function.prototype Array是通过new Function创建出来的</li>
<li>Array.prototype.<strong>proto</strong> === Object.prototype 所有的内建对象都是由Object()创建而来</li>
</ul>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h5><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><ul>
<li>会把父类的prototype赋值给新对象的<code>__proto__</code>属性</li>
</ul>
<h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><ul>
<li>实例对象的constructor属性指向其构造函数</li>
<li><code>F.prototype.constructor === F;</code></li>
<li><code>Object.constructor === Function;</code> </li>
<li><code>Function.constructor === Function;</code></li>
</ul>
<h3 id="事件机制-A"><a href="#事件机制-A" class="headerlink" title="事件机制(A)"></a>事件机制(A)</h3><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><h5 id="标准事件流"><a href="#标准事件流" class="headerlink" title="标准事件流"></a>标准事件流</h5><h5 id="IE中事件流"><a href="#IE中事件流" class="headerlink" title="IE中事件流"></a>IE中事件流</h5><h5 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h5><h5 id="跨浏览器注册事件"><a href="#跨浏览器注册事件" class="headerlink" title="跨浏览器注册事件"></a>跨浏览器注册事件</h5><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul>
<li>简单， 跨浏览器</li>
<li>多次注册覆盖，默认在冒泡阶段</li>
</ul>
<h4 id="DOM2"><a href="#DOM2" class="headerlink" title="DOM2"></a>DOM2</h4><ul>
<li>多次注册，执行顺序与注册顺序一致</li>
</ul>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul>
<li>currentTarget, target, preventDefault, stopPropagation</li>
</ul>
<h4 id="事件委托-A"><a href="#事件委托-A" class="headerlink" title="事件委托(A)"></a>事件委托(A)</h4><h3 id="跨域-A"><a href="#跨域-A" class="headerlink" title="跨域(A)"></a>跨域(A)</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><h4 id="JSONP-A"><a href="#JSONP-A" class="headerlink" title="JSONP(A)"></a>JSONP(A)</h4><ul>
<li>callback+script标签src</li>
<li>代码</li>
</ul>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h4><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><ul>
<li>前端：url变化</li>
<li>后端：Access-Control-Allow-Origin</li>
</ul>
<h4 id="H5的window-postMessage"><a href="#H5的window-postMessage" class="headerlink" title="H5的window.postMessage"></a>H5的window.postMessage</h4><ul>
<li>message + postMessage</li>
</ul>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><h3 id="Ajax-A"><a href="#Ajax-A" class="headerlink" title="Ajax(A)"></a>Ajax(A)</h3><p>原理(A)</p>
<ul>
<li>send方法内部创建了新的http请求线程，浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> ，添加到 <code>任务队列</code> 的末尾</li>
</ul>
<h3 id="安全-C"><a href="#安全-C" class="headerlink" title="安全(C)"></a>安全(C)</h3><h4 id="CA工作原理"><a href="#CA工作原理" class="headerlink" title="CA工作原理"></a>CA工作原理</h4><ul>
<li>A:准备明文，准备摘要，私钥对数字信息进行数字签名，生成密文，用公钥对DES密钥进行加密</li>
<li>B:用私钥对DES密钥解密，解密文，用公钥解密数字签名，对比信息摘要和信息</li>
</ul>
<h4 id="XSS-B"><a href="#XSS-B" class="headerlink" title="XSS(B)"></a>XSS(B)</h4><ul>
<li>是什么</li>
<li>防范<ul>
<li>输入编码过滤：转义 + 过滤</li>
<li>输出编码过滤：编码和转义</li>
<li>设置http-only，避免攻击脚本读取cookie</li>
</ul>
</li>
</ul>
<h4 id="CSRF-B"><a href="#CSRF-B" class="headerlink" title="CSRF(B)"></a>CSRF(B)</h4><ul>
<li>原理</li>
<li>预防<ul>
<li>HTTP 头中自定义属性并验证</li>
<li>CSRF token</li>
<li>cookie中加入hash随机数</li>
</ul>
</li>
</ul>
<h1 id="基础进阶"><a href="#基础进阶" class="headerlink" title="基础进阶"></a>基础进阶</h1><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="let-const-B"><a href="#let-const-B" class="headerlink" title="let/const(B)"></a>let/const(B)</h3><ul>
<li>块级作用域语句</li>
<li>不会造成声明提升：报错ReferenceError</li>
</ul>
<h3 id="块级立即执行函数-C"><a href="#块级立即执行函数-C" class="headerlink" title="块级立即执行函数(C)"></a>块级立即执行函数(C)</h3><h3 id="箭头函数-B"><a href="#箭头函数-B" class="headerlink" title="箭头函数(B)"></a>箭头函数(B)</h3><p>注意点（this的固定化）</p>
<ol>
<li><strong>this的指向是定义时所在的对象</strong>，而不是使用时所在的对象</li>
<li>不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误</li>
<li>不能够使用arguments对象</li>
<li>不能使用yield命令</li>
</ol>
<h3 id="字符串拓展-C"><a href="#字符串拓展-C" class="headerlink" title="字符串拓展(C)"></a>字符串拓展(C)</h3><ul>
<li>.includes( ), .repeat( ), .contains(), .startsWith(), .endsWith()</li>
<li>字符串模板字面量</li>
</ul>
<h3 id="数组的拓展-C"><a href="#数组的拓展-C" class="headerlink" title="数组的拓展(C)"></a>数组的拓展(C)</h3><ul>
<li>Array.from()</li>
<li>find()和findIndex()</li>
<li>fill()使用给定值</li>
</ul>
<h3 id="Maps-B"><a href="#Maps-B" class="headerlink" title="Maps(B)"></a>Maps(B)</h3><ul>
<li>entries()，keys()和values()用于遍历数组</li>
</ul>
<h3 id="解构-C"><a href="#解构-C" class="headerlink" title="解构(C)"></a>解构(C)</h3><h3 id="Modules-C"><a href="#Modules-C" class="headerlink" title="Modules(C)"></a>Modules(C)</h3><ul>
<li>export</li>
<li>import</li>
</ul>
<h3 id="参数默认值-C"><a href="#参数默认值-C" class="headerlink" title="参数默认值(C)"></a>参数默认值(C)</h3><h3 id="Rest-C"><a href="#Rest-C" class="headerlink" title="Rest(C)"></a>Rest(C)</h3><h3 id="Class-C"><a href="#Class-C" class="headerlink" title="Class(C)"></a>Class(C)</h3><ul>
<li>语法</li>
</ul>
<h3 id="Object-assign-C"><a href="#Object-assign-C" class="headerlink" title="Object.assign() (C)"></a>Object.assign() (C)</h3><h3 id="Symbol-C"><a href="#Symbol-C" class="headerlink" title="Symbol(C)"></a>Symbol(C)</h3><h3 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise(A)"></a>Promise(A)</h3><h3 id="Proxy-B"><a href="#Proxy-B" class="headerlink" title="Proxy(B)"></a>Proxy(B)</h3><h3 id="ASYNC-AWAIT-A"><a href="#ASYNC-AWAIT-A" class="headerlink" title="ASYNC/AWAIT(A)"></a>ASYNC/AWAIT(A)</h3><h3 id="Generator-B"><a href="#Generator-B" class="headerlink" title="Generator(B)"></a>Generator(B)</h3><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><blockquote>
<p>需要的：</p>
<ul>
<li>实现原理、源码</li>
<li>对一些实现的思考</li>
</ul>
</blockquote>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="通信流程-A"><a href="#通信流程-A" class="headerlink" title="通信流程(A)"></a>通信流程(A)</h3><h3 id="双向绑定原理-A"><a href="#双向绑定原理-A" class="headerlink" title="双向绑定原理(A)"></a>双向绑定原理(A)</h3><h3 id="渲染机制-A"><a href="#渲染机制-A" class="headerlink" title="渲染机制(A)"></a>渲染机制(A)</h3><h3 id="事件处理-B"><a href="#事件处理-B" class="headerlink" title="事件处理(B)"></a>事件处理(B)</h3><h3 id="生命周期-A"><a href="#生命周期-A" class="headerlink" title="生命周期(A)"></a>生命周期(A)</h3><h3 id="Vuex-B"><a href="#Vuex-B" class="headerlink" title="Vuex(B)"></a>Vuex(B)</h3><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><blockquote>
<p>需要的：</p>
<ul>
<li>关注优化，方案选型思考</li>
<li>实现原理</li>
<li>对一些规则的思考</li>
</ul>
</blockquote>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2>]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之ES6]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8BES6/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ES6问题在面试中是重中之重。我感觉是比较难的，如果仅仅是使用，那倒很轻松，但是其中会问实现、原理等，涉及的东西很多。</p>
<p>面试的ES6部分，需要掌握：</p>
<blockquote>
<ul>
<li>掌握每个概念存在的意义，是为了解决什么类型问题</li>
<li>掌握每个概念的实现原理，ES5怎么写</li>
<li>掌握每个概念的一些使用上的坑和技巧</li>
</ul>
</blockquote>
<p>TODO：</p>
<blockquote>
<ul>
<li>提到的概念深入细化</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之ES6"><a href="#面试重点之ES6" class="headerlink" title="面试重点之ES6"></a>面试重点之ES6</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>let/const</li>
<li>立即执行函数</li>
<li>箭头函数</li>
<li>字符串拓展</li>
<li>字符串模板字面量</li>
<li>数组的拓展</li>
<li>Maps</li>
<li>Object</li>
<li>for…of循环</li>
<li>解构</li>
<li>Modules</li>
<li>参数默认值</li>
<li>Class</li>
<li>Object.assign()</li>
<li>Symbol</li>
<li>Promise</li>
</ul>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：</p>
<pre><code class="javascript">f1().then(f2);
f1().then(f2).then(f3);
f1().then(f2).fail(f3);
</code></pre>
<p>如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。</p>
<p>API:</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt;
    reject(new Error(&#39;Failed to fulfill Promise&#39;)))
        .catch(reason =&gt; console.log(reason));
</code></pre>
<p>这里有两个处理函数，<strong>resolve</strong>（当Promise执行成功完毕时调用的回调函数） 和 <strong>reject</strong> （当Promise执行不接受时调用的回调函数）</p>
<p><strong>Promises的好处</strong>：</p>
<ul>
<li>大量嵌套错误处理回调函数会使代码变得难以阅读理解。使用Promises，我们可以通过清晰的路径将错误事件让上传递，并且适当地处理它们。</li>
</ul>
<p>此外，Promise处理后的值，无论是解决（resolved）还是拒绝（rejected）的结果值，都是不可改变的。</p>
<h3 id="1-什么是promise对象，它能干什么？"><a href="#1-什么是promise对象，它能干什么？" class="headerlink" title="1. 什么是promise对象，它能干什么？"></a>1. 什么是promise对象，它能干什么？</h3><p><strong>Promise</strong> 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算.。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
<p><strong>Promise</strong> 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的 promise 对象来替代原返回值。</p>
<p><strong>Promise</strong> 对象有以下几种状态:</p>
<ul>
<li><em>pending</em>: 表示一个初始状态, 非 fulfilled 或 rejected。</li>
<li><em>fulfilled</em>: 成功的操作。</li>
<li><em>rejected</em>: 失败的操作。</li>
</ul>
<p>每一个异步任务都会返回一个Promise对象，该对象有一个then方法，允许指定回调函数。可以根据Promise对象的状态相应的去执行对应的回调函数。</p>
<h3 id="2-常用的API"><a href="#2-常用的API" class="headerlink" title="2. 常用的API"></a>2. 常用的API</h3><h4 id="1-Promise-prototype-then"><a href="#1-Promise-prototype-then" class="headerlink" title="1.Promise.prototype.then()"></a>1.Promise.prototype.then()</h4><p>它的作用是为promise实例添加状态改变时的回调函数。</p>
<p>then()方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的promise实例。</p>
<p>then方法的第二个参数一般不推荐写。有以下两个原因：</p>
<ul>
<li>由于是链式操作，这个then方法之后还可能会有其他操作，如果此时把错误捕捉的函数放在后面方法前边的话，并且之后再无错误捕获方法，then之后的错误就会捕捉不到。</li>
<li>在then方法里面，两个参数都是回调函数写了一大堆，这样结构看起来比较混乱。</li>
</ul>
<pre><code class="javascript">var p=new Promise(function(resolve, reject){
    resolve(&quot;ok&quot;);    
});
p.then(function(value){console.log(val)},
 function(err)(console.log(err))       
);
</code></pre>
<h4 id="2-Promise-prototype-catch"><a href="#2-Promise-prototype-catch" class="headerlink" title="2.Promise.prototype.catch()"></a>2.Promise.prototype.catch()</h4><p>这个方法是.then(null,rejection)的别名，这也能看出这个方法是专门只能用来捕获错误信息，用于指定发生错误时的回调函数。</p>
<p>要注意一下几点：</p>
<ul>
<li>当promise状态已经变成resolved的时候，再抛出错误时是无效的。</li>
<li>尽量将catch方法写在链式操作的最后。<strong>错误会一直冒泡到最后，catch放在最后会捕捉到所有错误。</strong></li>
<li>当没有使用catch方法指定错误处理函数的回调函数时，promise对象里面抛出的错误不会传递到外层的代码。</li>
</ul>
<h4 id="3-Promise-resolve"><a href="#3-Promise-resolve" class="headerlink" title="3. Promise.resolve()"></a>3. Promise.resolve()</h4><p>这个方法的作用就是将现有的对象转化为Promise对象，进而可以执行这些方法。</p>
<pre><code class="javascript">Promise.resolve(&quot;foo&quot;);
</code></pre>
<h4 id="4-Promise-all"><a href="#4-Promise-all" class="headerlink" title="4. Promise.all()"></a>4. Promise.all()</h4><p>这个方法用于将多个promise实例，包装成一个新的promise实例。</p>
<pre><code class="javascript">var p=Promise.all([p1,p2,p3]);
</code></pre>
<p>要注意一下两点：</p>
<ul>
<li>只有当p1,p2,p3状态都变为fulfilled之后，p的状态才会变为fulfilled。</li>
<li>只要p1.p2,p3中有任意一个状态变为rejected，p的状态就会变为rejected。</li>
</ul>
<h3 id="3-实现异步编程的原理"><a href="#3-实现异步编程的原理" class="headerlink" title="3. 实现异步编程的原理"></a>3. 实现异步编程的原理</h3><p>Promise对象相当于是一个状态机，在其内部使用resolve方法，使其由初始状态变为成功时的fulfilled状态或者执行失败后的rejected状态。这时内部的工作就完成了，开始由外部监听其内部的状态的改变，调用then()方法（catch()方法相当于then内部的第二个参数方法）对应的状态调用对应的处理函数。</p>
<h2 id="箭头函数需要注意的地方"><a href="#箭头函数需要注意的地方" class="headerlink" title="箭头函数需要注意的地方"></a>箭头函数需要注意的地方</h2><p>当要求动态上下文的时候，就不能够使用箭头函数。也就是this的固定化</p>
<ol>
<li>在使用=&gt;定义函数的时候，<strong>this的指向是定义时所在的对象</strong>，而不是使用时所在的对象</li>
<li>不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误</li>
<li>不能够使用arguments对象</li>
<li>不能使用yield命令</li>
</ol>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>使用 Proxy 的好处是：对象只需关注于核心逻辑，一些非核心的逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 Proxy 来做。从而达到关注点分离，降级对象复杂度的目的。</p>
<p>Proxy用于修改某些操作的默认行为，用来代理有些行为。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<pre><code class="javascript">var engineer = { name: &#39;Joe Sixpack&#39;, salary: 50 };

var interceptor = {
  set: function (receiver, property, value) {
    console.log(property, &#39;is changed to&#39;, value);
    receiver[property] = value;
  }
};

engineer = Proxy(engineer, interceptor);
engineer.salary = 60;    //会触发处理器
</code></pre>
<p><strong>（1）get(target, propKey, receiver)</strong></p>
<p>拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</p>
<p>最后一个参数<code>receiver</code>是一个对象，可选，参见下面<code>Reflect.get</code>的部分。</p>
<p><strong>（2）set(target, propKey, value, receiver)</strong></p>
<p>拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p>
<p><strong>（3）has(target, propKey)</strong></p>
<p>拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p>
<p><strong>（4）deleteProperty(target, propKey)</strong></p>
<p>拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p>
<p><strong>（5）ownKeys(target)</strong></p>
<p>拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</p>
<p><strong>（6）getOwnPropertyDescriptor(target, propKey)</strong></p>
<p>拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p>
<p><strong>（7）defineProperty(target, propKey, propDesc)</strong></p>
<p>拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p>
<p><strong>（8）preventExtensions(target)</strong></p>
<p>拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p>
<p><strong>（9）getPrototypeOf(target)</strong></p>
<p>拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p>
<p><strong>（10）isExtensible(target)</strong></p>
<p>拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p>
<p><strong>（11）setPrototypeOf(target, proto)</strong></p>
<p>拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<p><strong>（12）apply(target, object, args)</strong></p>
<p>拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p>
<p><strong>（13）construct(target, args)</strong></p>
<p>拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</p>
<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>异步编程的方法</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。异步操作需要暂停的地方，都用 yield 语句注明。</p>
<p>Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。</p>
<pre><code class="javascript">function* gen(x){
  var y = yield x + 2;
  return y;
}

var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
</code></pre>
<p><strong>Case</strong></p>
<pre><code class="javascript">var fetch = require(&#39;node-fetch&#39;);

function* gen(){
  var url = &#39;https://api.github.com/users/github&#39;;
  var result = yield fetch(url);
  console.log(result.bio);
}
</code></pre>
<pre><code class="javascript">var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
</code></pre>
<p>一句话说，next方法参数的作用，是覆盖掉上一个yield语句的值。</p>
<p>带参数跟不带参数的区别是，带参数的情况，首先第一步就是将上一个yield语句重置为参数值，然后再照常执行剩下的语句。<strong>总之，区别就是先有一步先重置值，接下来其他全都一样。</strong></p>
<h2 id="ES7的Async-Await"><a href="#ES7的Async-Await" class="headerlink" title="ES7的Async/Await"></a>ES7的Async/Await</h2><pre><code class="javascript">var sleep = function (time) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            resolve();
        }, time);
    })
};

var start = async function () {
    // 在这里使用起来就像同步代码那样直观
    console.log(&#39;start&#39;);
    await sleep(3000);
    console.log(&#39;end&#39;);
};

start();
</code></pre>
<ul>
<li>async 表示<code>这是一个async函数</code>，<code>await只能用在这个函数里面</code>。</li>
<li>await 表示在这里<code>等待promise返回结果</code>了，再继续执行。</li>
<li>await 后面跟着的<code>应该是一个promise对象</code></li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>await等待的虽然是promise对象，但不必写<code>.then(..)</code>，直接可以得到返回值。</p>
<p>await看起来就像是同步代码，所以可以理所当然的写在<code>for</code>循环里，不必担心以往需要<code>闭包</code>才能解决的问题。</p>
<p>值得注意的是，<code>await</code>必须在<code>async函数的上下文中</code>的。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之事件委托]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>事件委托问题在面试中必问。本文介绍基础的原理。</p>
<p>面试的跨域部分，需要掌握以下：</p>
<blockquote>
<ul>
<li>委托在JS的实现原理</li>
<li>委托在框架中的实现，是否会有一些JS中残存的问题，是否优化</li>
</ul>
</blockquote>
<p>TODO：</p>
<blockquote>
<ul>
<li>细化总结</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之事件委托"><a href="#面试重点之事件委托" class="headerlink" title="面试重点之事件委托"></a>面试重点之事件委托</h1><h2 id="事件委托或是事件代理详解"><a href="#事件委托或是事件代理详解" class="headerlink" title="事件委托或是事件代理详解"></a>事件委托或是事件代理详解</h2><h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；<strong>如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p>
<h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p>事件委托是利用事件的<strong>冒泡原理</strong>来实现的</p>
<h3 id="事件委托怎么实现"><a href="#事件委托怎么实现" class="headerlink" title="事件委托怎么实现"></a>事件委托怎么实现</h3><p><strong>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源</strong>，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，<strong>标准浏览器用ev.target，IE浏览器用event.srcElement</strong>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p>
<pre><code class="javascript">window.onload = function(){
  var oUl = document.getElementById(&quot;ul1&quot;);
  oUl.onclick = function(ev){
    var ev = ev || window.event;
    var target = ev.target || ev.srcElement;
    if(target.nodeName.toLowerCase() == &#39;li&#39;){
      //...
    }
  }
}
</code></pre>
<p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><h3 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h3><p>捕获期间还是冒泡期间，true：捕获，false：冒泡<br>target.addEventListener(type, listener, useCapture);  </p>
<p>//在某一个元素上撤销已注册的事件。这里强调的是:这里的函数必须与已注册的函数是同一个函数！<br>target.removeEventListener(type, listener, useCapture);</p>
<h3 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h3><p>target.attachEvent(type, listener);<br>target.detachEvent(type,listener);   //参数与注册参数相对应。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 事件委托 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之Vue]]></title>
      <url>/2018/01/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8BVue/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文是我为了应付面试的产物，针对性强不怕没的说，但如实说我一点皮毛还不懂。</p>
<p>为自己加个TODO：</p>
<ul>
<li>阅读源码，实现一套双向绑定和渲染。</li>
<li>补充本文的一些细节+渲染+Vuex部分，写的很乱，其实是自己不懂乱copy</li>
</ul>
<p>面试的框架部分，需要掌握以下：</p>
<blockquote>
<ul>
<li>实现原理、源码</li>
<li>对一些实现的思考</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="面试重点之Vue"><a href="#面试重点之Vue" class="headerlink" title="面试重点之Vue"></a>面试重点之Vue</h1><h2 id="Vue通信"><a href="#Vue通信" class="headerlink" title="Vue通信"></a>Vue通信</h2><h3 id="vue父子组件通信"><a href="#vue父子组件通信" class="headerlink" title="vue父子组件通信"></a>vue父子组件通信</h3><h4 id="子-gt-父：-emit"><a href="#子-gt-父：-emit" class="headerlink" title="子 -&gt; 父：$emit"></a>子 -&gt; 父：$emit</h4><pre><code class="vue">// 父组件
&lt;single-address @edit-address=&quot;editAddress&quot;&gt;&lt;/single-address&gt;

// 子组件
methods: {
 editAddress () {
  this.$emit(&#39;edit-address&#39;, false)
 }
}
</code></pre>
<h4 id="父-gt-子：props"><a href="#父-gt-子：props" class="headerlink" title="父 -&gt; 子：props"></a>父 -&gt; 子：props</h4><pre><code class="javascript">// 父组件
&lt;one-address :addressitems=&quot;addressitems&quot;&gt;&lt;/one-address&gt;

// 子组件
&lt;div&gt;{{ addressitems.partment }}{{ addressitems.address }}&lt;/div&gt;
export default {
  props: {
    addressitems: Object
  }
}
</code></pre>
<h3 id="非父子组件"><a href="#非父子组件" class="headerlink" title="非父子组件"></a>非父子组件</h3><pre><code class="javascript">var bus = new Vue()
// 触发组件 A 中的事件
bus.$emit(&#39;id-selected&#39;, 1)
// 在组件 B 创建的钩子中监听事件
bus.$on(&#39;id-selected&#39;, function (id) {
 console.log(id)
})
</code></pre>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>Methods 并不是创建自定义函数的唯一方式。也可以使用 <code>watch</code> 。</p>
<p>两者的区别是 methods 适合小的、同步的计算，而 <code>watch</code> 对于多任务、异步或者响应数据变化时的开销大的操作是有利的。我经常在动画中使用 watch 。</p>
<h2 id="组件，Props，Slots"><a href="#组件，Props，Slots" class="headerlink" title="组件，Props，Slots"></a>组件，Props，Slots</h2><p>从父组件向子组件传递数据的方式称为 <strong>props</strong>。</p>
<p>我们也可以向 props 中添加验证，这和 React 中的 <code>PropTypes</code> 类似。</p>
<h3 id="Slots"><a href="#Slots" class="headerlink" title="Slots"></a>Slots</h3><p>重用组件，并用相同的数据或功能填充它们</p>
<p>你也可以使用具名 slot 。如果一个组件中有两个 slot， 可以通过添加 name 属性区分它们</p>
<h2 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h2><h3 id="1-什么是vue生命周期？"><a href="#1-什么是vue生命周期？" class="headerlink" title="1.什么是vue生命周期？"></a>1.什么是vue生命周期？</h3><p>答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。2、vue生命周期的作用是什么？<br>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<h3 id="2-vue生命周期总共有几个阶段？"><a href="#2-vue生命周期总共有几个阶段？" class="headerlink" title="2. vue生命周期总共有几个阶段？"></a>2. vue生命周期总共有几个阶段？</h3><p>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<h3 id="3-第一次页面加载会触发哪几个钩子？"><a href="#3-第一次页面加载会触发哪几个钩子？" class="headerlink" title="3. 第一次页面加载会触发哪几个钩子？"></a>3. 第一次页面加载会触发哪几个钩子？</h3><p>答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>
<h3 id="4-DOM-渲染在-哪个周期中就已经完成？"><a href="#4-DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="4. DOM 渲染在 哪个周期中就已经完成？"></a>4. DOM 渲染在 哪个周期中就已经完成？</h3><p>答：DOM 渲染在 mounted 中就已经完成了。</p>
<h3 id="5-简单描述每个周期具体适合哪些场景？"><a href="#5-简单描述每个周期具体适合哪些场景？" class="headerlink" title="5. 简单描述每个周期具体适合哪些场景？"></a>5. 简单描述每个周期具体适合哪些场景？</h3><p>答：生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom</p>
<h3 id="5-生命周期钩子"><a href="#5-生命周期钩子" class="headerlink" title="5. 生命周期钩子"></a>5. 生命周期钩子</h3><p>可以使用的钩子有： <code>beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy</code>, <code>destroyed</code> 。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul>
<li><strong>Getters</strong> 可以在模板中静态的显示数据。换句话说，getters 可以读取数据，但不能改变状态。</li>
<li><strong>Mutations</strong> 允许更新状态，但永远是同步的。Mutations 是 store 中改变状态数据的唯一方式。</li>
<li><strong>Actions</strong> 允许异步更新状态，但是需要使用一个已经存在的 mutation 。如果你需要以特定的顺序同时执行不同的 mutations 会非常有用。</li>
</ul>
<p><code>store.js</code>：</p>
<pre><code class="javascript">export const store = new Vuex.Store({
  state: {
    counter: 0
  },
  // 展示内容, 无法改变状态
  getters: {
    tripleCounter: state =&gt; {
      return state.counter * 3;
    }
  },
  // 改变状态
  //mutations 永远是同步的
  mutations: {
    // 显示传递的载荷 payload, 用 num 表示
    increment: (state, num) =&gt; {
      state.counter += num;
    }
  }, 
  // 提交 mutation, 这是异步的
  actions: {
    // 显示传递的载荷 payload, 用 asynchNum ( 一个对象 )表示
    asyncDecrement: ({ commit }, asyncNum) =&gt; {
      setTimeout(() =&gt; {
        // asyncNum 对象可以是静态值
        commit(&#39;decrement&#39;, asyncNum.by);
      }, asyncNum.duration);
    }
  }
});
</code></pre>
<h2 id="双向数据绑定原理是什么？"><a href="#双向数据绑定原理是什么？" class="headerlink" title="双向数据绑定原理是什么？"></a>双向数据绑定原理是什么？</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>这是 ES5 的特性，通过在 setter/getter，在属性被访问和修改时通知变化。比如 vue 就是用的这个特性。</p>
<p>vue.js 是采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<pre><code class="javascript">function declar(obj){
   var rwprop = 0;
   Object.defineProperty(obj, &quot;rwprop&quot;, {
        get : () =&gt; rwprop // getter
   });
   return obj
}

var a = {};

a = declar(a);

a.rwprop = 1 // 调用了setter
console.log(a.rwprop) // 调用了getter
</code></pre>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p><strong>第一步：需要observe的数据对象进行递归遍历</strong>，包括子属性对象的属性，都加上 <code>setter</code>和<code>getter</code>。这样的话，给这个对象的某个值赋值，就会触发<code>setter</code>，那么就能监听到了数据变化</p>
<p><strong>第二步：compile解析模板指令</strong>，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p><strong>第三步：Watcher订阅者是Observer和Compile之间通信的桥梁</strong>，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<p><strong>第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者</strong>，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<h4 id="1-实现-observer"><a href="#1-实现-observer" class="headerlink" title="1. 实现 observer"></a>1. 实现 observer</h4><p>思路：我们知道Object.defineProperty的特性了，我们就利用它的set和get。。我们将要observe的对象，通过递归，将它所有的属性，包括子属性的属性，都给加上set和get，这样的话，给这个对象的某个属性赋值，就会触发set</p>
<pre><code class="javascript">export default class  Observer{
  constructor(value) {
    this.value = value
    this.walk(value)
  }
  //递归。。让每个字属性可以observe
  walk(value){
    Object.keys(value).forEach(key=&gt;this.convert(key,value[key]))
  }
  convert(key, val){
    defineReactive(this.value, key, val)
  }
}

export function defineReactive (obj, key, val) {
  var childOb = observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: ()=&gt;val,
    set:newVal=&gt; {      
     childOb = observe(newVal)//如果新赋值的值是个复杂类型。再递归它，加上set/get。。
     }
  })
}

export function observe (value, vm) {
  if (!value || typeof value !== &#39;object&#39;) {
    return
  }
  return new Observer(value)
}
</code></pre>
<p>所以，我们是不是应该写一个消息－订阅器呢？这样的话，一触发set方法，我们就发一个通知出来，然后，订阅这个消息的，就会怎样？。。。对咯。。收到消息。。。触发回调。</p>
<h4 id="2-消息－订阅器"><a href="#2-消息－订阅器" class="headerlink" title="2. 消息－订阅器"></a>2. 消息－订阅器</h4><p>维护一个数组，这个数组，就放订阅着属性订阅器，一旦触发notify，订阅者就调用自己的update方法</p>
<pre><code class="javascript">export function defineReactive (obj, key, val) {
  var dep = new Dep()
  var childOb = observe(val)

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: ()=&gt;{
      // 说明这是watch 引起的
      if(Dep.target){
        dep.addSub(Dep.target)
      }
      return val
    },
    set:newVal=&gt; {
      var value =  val
      if (newVal === value) {
        return
      }
      val = newVal
      childOb = observe(newVal)
      dep.notify()
    }
  })
}
</code></pre>
<p>谁是订阅者。。对，是Watcher。。一旦 <code>dep.notify()</code>就遍历订阅者，也就是Watcher，并调用他的<code>update()</code>方法</p>
<h4 id="3-实现一个-Watcher"><a href="#3-实现一个-Watcher" class="headerlink" title="3. 实现一个 Watcher"></a>3. 实现一个 Watcher</h4><pre><code class="javascript">export default class Watcher {
  constructor(vm, expOrFn, cb) {
    this.cb = cb
    this.vm = vm
    //此处简化.要区分fuction还是expression,只考虑最简单的expression
    this.expOrFn = expOrFn
    this.value = this.get()
  }
  update(){
    this.run()
  }
  run(){
    const  value = this.get()
    if(value !==this.value){
      this.value = value
      this.cb.call(this.vm)
    }
  }
  get(){
    Dep.target = this
    //此处简化。。要区分fuction还是expression
    const value = this.vm._data[this.expOrFn]
    Dep.target = null
    return value
  }
}
</code></pre>
<h4 id="4-实现一个-Vue"><a href="#4-实现一个-Vue" class="headerlink" title="4. 实现一个 Vue"></a>4. 实现一个 Vue</h4><pre><code class="javascript">export default class Vue {
  constructor (options={}) {
    //这里简化了。。其实要merge
    this.$options=options
    //这里简化了。。其实要区分的
    let data = this._data=this.$options.data
    Object.keys(data).forEach(key=&gt;this._proxy(key))
    observe(data,this)
  }


  $watch(expOrFn, cb, options){
    new Watcher(this, expOrFn, cb)
  }

  _proxy(key) {
    var self = this
    Object.defineProperty(self, key, {
      configurable: true,
      enumerable: true,
      get: function proxyGetter () {
        return self._data[key]
      },
      set: function proxySetter (val) {
        self._data[key] = val
      }
    })
  }
}
</code></pre>
<h2 id="Vue2-原理浅谈"><a href="#Vue2-原理浅谈" class="headerlink" title="Vue2 原理浅谈"></a>Vue2 原理浅谈</h2><ul>
<li>输入了数据状态，输出视图（我们不关心中间的过程，它们均由框架帮助我们实现）；</li>
<li>数据变化侦测，从而re-render视图。</li>
<li>数据变化侦测分为<code>系统不可感知数据变化</code>和<code>系统可感知数据变化</code></li>
<li>系统不可感知数据变化：React就是通过setState发信号告诉系统有可能数据变了,然后通过virtual dom diff去渲染视图，angular则是有一个脏值检查流程，遍历比对</li>
<li>系统可感知数据变化：通过观察者模式，使用Observable (可观察对象)，Observer (观察者)(或者是watcher)去订阅</li>
</ul>
<p>上者<code>系统不可感知数据变化</code>,粒度粗，有时候还得手动优化（比如pureComponet和shouldComponentUpdate)去跳过一些数据不会更新的视图从而提升性能</p>
<p>下者<code>系统可感知数据变化</code>,粒度细，但是绑定大量观察者，有大量的依赖追踪的内存开销</p>
<p><strong>Vue2</strong>，它采用了折中粒度的方式，粒度到组件级别上，由watcher订阅数据，当数据变化我们可以得知哪个组件数据变了，然后采用virtual dom diff的方式去更新相应组件。</p>
<h3 id="数据响应原理"><a href="#数据响应原理" class="headerlink" title="数据响应原理"></a>数据响应原理</h3><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><blockquote>
<p>app.message如何拿到vue data中的message?</p>
</blockquote>
<p>其实也是跟<code>Object.defineProperty</code>有关，Vue在初始化数据的时候会遍历data代理这些数据，其实就是用<code>Object.defineProperty</code>多加了一层的访问</p>
<h4 id="观察者模式（Observer-Watcher-Dep"><a href="#观察者模式（Observer-Watcher-Dep" class="headerlink" title="观察者模式（Observer, Watcher, Dep)"></a>观察者模式（Observer, Watcher, Dep)</h4><ul>
<li>Observer类主要用于给Vue的数据<code>defineProperty</code>增加getter/setter方法，并且在getter/setter中收集依赖或者通知更新</li>
<li>Watcher类来用于观察数据（或者表达式）变化然后执行回调函数（其中也有收集依赖的过程），主要用于$watch API和指令上</li>
<li>Dep类就是一个可观察对象，可以有不同指令订阅它（它是多播的）</li>
</ul>
<p>观察者模式,跟发布／订阅模式有点像，区别是发布和订阅以及发布后调度订阅者的操作都是由中心统一完成，但是观察者模式则没有这样的中心</p>
<h5 id="如何实现观察者模式呢？"><a href="#如何实现观察者模式呢？" class="headerlink" title="如何实现观察者模式呢？"></a>如何实现观察者模式呢？</h5><blockquote>
<p>怎么实现订阅</p>
</blockquote>
<p>Dep由于是可以被多个Watcher所订阅的，所以它拥有着订阅者数组，订阅了它，就把Watcher放入数组即可</p>
<pre><code class="javascript">class Dep {
  constructor () {
    this.subs = []
  }
  notify () {
    const subs = this.subs.slice()
    for (let i = 0; i &lt; subs.length; i++) {
        subs[i].update()
    }
  }
  addSub (sub) {
    this.subs.push(sub)
  }
}

class Watcher {
  constructor () {
  }
  update () {
  }
}

let dep = new Dep()
dep.addSub(new Watcher()) // Watcher订阅了依赖
</code></pre>
<blockquote>
<p>怎么通知notify</p>
</blockquote>
<p>把每一个数据当成一个Dep实例，然后setter的时候去notify就行了，所以我们可以在defineProperty中new Dep()，通过闭包setter就可以取到Dep实例</p>
<blockquote>
<p>怎么让我的Watcher实例订阅到这个Dep实例</p>
</blockquote>
<p>从get里面做手脚，在get中是可以取到这个Dep实例的，所以可以在执行watch操作的时候，执行获取数值，触发getter去收集依赖</p>
<p>在new Watcher的时候会执行一个求值的操作，然后因为标记了这个Watcher触发的，所以收集了依赖，也就是观察者订阅了依赖</p>
<blockquote>
<p>case</p>
</blockquote>
<pre><code class="javascript">const vm = new Vue({
  data: {
    msg: 1,
  }
})
vm.$watch(&quot;msg&quot;, () =&gt; console.log(&quot;msg变了&quot;));
vm.msg = 2; //输出「变了」
</code></pre>
<ul>
<li>首先是new Vue遍历了数据，给数据defineProperty加上了getter/setter方法</li>
<li>我们<code>new Watcher(vm, &#39;msg&#39;, () =&gt; console.log(&quot;msg变了&quot;))</code>,首先标记了全局变量Dep.target = 该Watcher实例，然后执行msg的get操作，触发到了它的getter，然后dep成功获取到它的订阅者，放入它的订阅者数组，最后我们将Dep.target = null</li>
<li>最后设置vm.msg = 2,触发到了setter,闭包中的dep.notify,遍历订阅者数组，执行相应的回调操作。</li>
</ul>
<h3 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h3><p>第一部分其实就是各种正则了，对左右开闭标签的匹配以及属性的收集，通过栈的形式，不断出栈入栈去匹配以及更换父节点，最后生成一个对象，包含children,children又包含children的对象</p>
<p>第二部分则是以第一部分为基础，根据节点类型找出一些静态的节点并标记</p>
<p>第三部分就是生成render函数代码了</p>
<p>知道了<code>vm._render()</code>创建了vnode返回，接下来就是<code>vm._update</code>了</p>
<h4 id="数据到视图的整体流程"><a href="#数据到视图的整体流程" class="headerlink" title="数据到视图的整体流程"></a>数据到视图的整体流程</h4><p>所以到这里我们就可以得出一个数据到视图的整体流程的结论了</p>
<ul>
<li>在组件级别，vue会执行一个new Watcher</li>
<li>new Watcher首先会有一个求值的操作，它的求值就是执行一个函数，这个函数会执行render，其中可能会有编译模板成render函数的操作，然后生成vnode(virtual dom)，再将virtual dom应用到视图中</li>
<li>其中将virtual dom应用到视图中（这里涉及到diff后文会讲），一定会对其中的表达式求值(比如,我们肯定会取到它的值再去渲染的），这里会触发到相应的getter操作完成依赖的收集</li>
<li>当数据变化的时候，就会notify到这个组件级别的Watcher,然后它还会去求值，从而重新收集依赖，并且重新渲染视图</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2017/12/31/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文整理JS 的数组方法，按照定义和使用两种分类整理，ES6后的数组相关和一些奇淫巧技待补充</p>
<a id="more"></a>
<h1 id="数组篇"><a href="#数组篇" class="headerlink" title="数组篇"></a>数组篇</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><ul>
<li>用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</li>
<li>返回一个字符串。</li>
</ul>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><ul>
<li>末尾添加新的元素</li>
<li>返回的是数组新的长度。</li>
</ul>
<h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><ul>
<li>删除数组最后一个元素。</li>
<li>返回该元素</li>
</ul>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><ul>
<li>把数组中的第一个元素删除。注意，不创建新数组，而是直接修改原来的数组。</li>
<li>返回第一个元素的值</li>
</ul>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><ul>
<li>参数顺序添加到数组的头部。它直接修改了数组，而不是创建一个新的数组。</li>
<li>返回的是新数组的长度。 </li>
</ul>
<h4 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h4><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><ul>
<li>对反转数组项的顺序</li>
<li>返回值是经过排序之后的数组</li>
</ul>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><ul>
<li>按升序排列数组。比较字符串</li>
<li>返回值是经过排序之后的数组</li>
</ul>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><ul>
<li>连接两个或多个数组</li>
<li>不会改变现有的数组，而仅仅会返回被连接数组的一个副本</li>
</ul>
<h5 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="slice(start,end)"></a>slice(start,end)</h5><ul>
<li>start 规定从何处开始选取。end 是数组片断结束处的数组下标（不包括）。</li>
<li>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
</ul>
<h5 id="splice-index-howmany-element1-…-elementX"><a href="#splice-index-howmany-element1-…-elementX" class="headerlink" title="splice((index,howmany,element1,…..,elementX)"></a>splice((index,howmany,element1,…..,elementX)</h5><ul>
<li>用于插入、删除或替换数组的元素。splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</li>
<li>返回值：返回的是含有被删除的元素的数组。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><pre><code class="javascript">var arrayObj = new Array();　//创建一个数组
var arrayObj = new Array([size]);　//创建一个数组并指定长度，注意不是上限，是长度
var arrayObj = new Array([element0[, element1[, ...[, elementN]]]]);　创建一个数组并赋值
</code></pre>
<blockquote>
<p>要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变。</p>
</blockquote>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><h5 id="push–添加到尾"><a href="#push–添加到尾" class="headerlink" title="push–添加到尾"></a>push–添加到尾</h5><pre><code class="javascript">arrayObj.push([item1 [item2 [. . . [itemN ]]]]);
</code></pre>
<h5 id="unshift–添加到头"><a href="#unshift–添加到头" class="headerlink" title="unshift–添加到头"></a>unshift–添加到头</h5><pre><code class="javascript">arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);
</code></pre>
<h5 id="splice–插入到指定位置"><a href="#splice–插入到指定位置" class="headerlink" title="splice–插入到指定位置"></a>splice–插入到指定位置</h5><pre><code class="javascript">arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);
</code></pre>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><h5 id="pop–移除尾"><a href="#pop–移除尾" class="headerlink" title="pop–移除尾"></a>pop–移除尾</h5><pre><code class="javascript">arrayObj.pop();
</code></pre>
<h5 id="shift—移除头"><a href="#shift—移除头" class="headerlink" title="shift—移除头"></a>shift—移除头</h5><pre><code class="javascript">arrayObj.shift();
</code></pre>
<h5 id="splice–删除指定位置指定数量"><a href="#splice–删除指定位置指定数量" class="headerlink" title="splice–删除指定位置指定数量"></a>splice–删除指定位置指定数量</h5><pre><code class="javascript">arrayObj.splice(deletePos,deleteCount);
</code></pre>
<h4 id="截取和合并"><a href="#截取和合并" class="headerlink" title="截取和合并"></a>截取和合并</h4><h5 id="slice–截取"><a href="#slice–截取" class="headerlink" title="slice–截取"></a>slice–截取</h5><pre><code class="javascript">arrayObj.slice(start, [end]);
</code></pre>
<h5 id="concat–合并"><a href="#concat–合并" class="headerlink" title="concat–合并"></a>concat–合并</h5><pre><code class="javascript">arrayObj.concat([item1[, item2[, . . . [,itemN]]]]);
</code></pre>
<h4 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h4><h5 id="slice–新数组"><a href="#slice–新数组" class="headerlink" title="slice–新数组"></a>slice–新数组</h5><pre><code class="javascript">arrayObj.slice(0);
</code></pre>
<h5 id="concat–新数组"><a href="#concat–新数组" class="headerlink" title="concat–新数组"></a>concat–新数组</h5><pre><code class="javascript">arrayObj.concat();
</code></pre>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="reverse–反转"><a href="#reverse–反转" class="headerlink" title="reverse–反转"></a>reverse–反转</h5><pre><code class="javascript">arrayObj.reverse();
</code></pre>
<h5 id="sort–排序"><a href="#sort–排序" class="headerlink" title="sort–排序"></a>sort–排序</h5><pre><code class="javascript">arrayObj.sort();
</code></pre>
<h4 id="字符串化"><a href="#字符串化" class="headerlink" title="字符串化"></a>字符串化</h4><h5 id="join—拼接"><a href="#join—拼接" class="headerlink" title="join—拼接"></a>join—拼接</h5><pre><code class="javascript">arrayObj.join(separator);
</code></pre>
<blockquote>
<p>toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用</p>
</blockquote>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><blockquote>
<p>TODO</p>
</blockquote>
<p>for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。</p>
<p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p>
<pre><code class="javascript">arr.forEach((value, index) =&gt; {  
     console.log(value);  
});
</code></pre>
<h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h3><pre><code class="javascript">&#39;abc123&#39;.split(&#39;&#39;).reverse().join(&#39;&#39;)
</code></pre>
<h3 id="打平嵌套数组"><a href="#打平嵌套数组" class="headerlink" title="打平嵌套数组"></a>打平嵌套数组</h3><blockquote>
<p>[1, [2, [3], 4], 5] =&gt; [1, 2, 3, 4, 5]</p>
</blockquote>
<pre><code class="javascript">// 我现场写的代码：
const arr = [1,[2,[3],4],5]
function flatten(arr) {
    for (let i in arr) {
        if (Array.isArray(arr[i])) {
            arr.splice(i, 1, ...flatten(arr[i]))
        }
    }
    return arr
}
flatten(arr)

// 偶然发现 arr.toString() 或 arr.join() =&gt; &#39;1,2,3,4,5&#39;
// 于是可以写的简便些
const arr = [1,[2,[3],4],5]
arr.join()
    .split(&#39;,&#39;)
    .map(it =&gt; Number(it))

// 网上搜了下，还可以这么写。。。
const arr = [1, [2, [3], 4], 5]
JSON.parse(`[${arr}]`)
</code></pre>
<h3 id="打印数组全排列"><a href="#打印数组全排列" class="headerlink" title="打印数组全排列"></a>打印数组全排列</h3><blockquote>
<p>[1,2,3] =&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
</blockquote>
<pre><code class="javascript">// 没有明确的遍历界限时都使用递归吧，实际应用场景，若非尾递归形式需要考虑是否可能栈溢出。
// 采用递归需要重点考虑参数及返回值的设定，本例使用有副作用的方式实现，这样实现逻辑上比较好理解，只有当满足条件时添加一条排列，递归中的返回值用起来总感觉头晕。。
function allRange (arr, path, res) {
    if (!arr.length) {
        res.push(path)
        return
    }
    arr.forEach((v, idx) =&gt; {
        const t = arr.slice()
        const p = path.slice()
        t.splice(idx, 1)
        p.push(v)
        allRange(t, p, res)
    })
}
var a = [1, 2, 3, 4]
const b = []
allRange(a, [], b)
console.log(b)
</code></pre>
<h3 id="寻找两个有序数组最小相同元素"><a href="#寻找两个有序数组最小相同元素" class="headerlink" title="寻找两个有序数组最小相同元素"></a>寻找两个有序数组最小相同元素</h3><pre><code class="javascript">const a = [1, 2, 5, 9, 10]
const b = [3, 4, 6, 9, 10]

function findElement (a, b) {
    let i = j = 0
    while (i &lt; a.length || j &lt; b.length) {
        if (a[i] === b[j]) {
            return a[i]
        } else if (a[i] &gt; b[j]) {
            j ++
        } else if (a[i] &lt; b[j]) {
            i ++
        }
    }
    return null
}

console.log(findElement(a, b))
// =&gt; 9
// 看到这个题目第一想法是 遍历第一个数组，二分法查找第二个。经面试官提醒，采用游标，更加简单易懂。
</code></pre>
<h3 id="有序二维数组寻找某元素坐标"><a href="#有序二维数组寻找某元素坐标" class="headerlink" title="有序二维数组寻找某元素坐标"></a>有序二维数组寻找某元素坐标</h3><pre><code class="javascript">const data = [[1, 2, 5, 9, 10],
              [12, 22, 35, 49, 51],
              [61, 62, 75, 79, 81]]

const len = data[0].length
function findOffset (e, a, b) {
    if (a &gt; b) return null 

    const offset = (b - a) / 2 + a

    // 映射位置偏移到坐标
    const x = offset % len
    const y = ~~(offset / len)

    if (data[y][x] === e) {
        return [x, y]
    } else if (e &gt; data[y][x]) {
        return findOffset(e, offset + 1, b)
    } else {
        return findOffset(e, a, offset - 1)
    }
}
findOffset(75, 0, len * data.length - 1)
// =&gt; [2, 2]

// 看到这个题目第一想法是打平数组使用indexOf得到下标，再根据data[0].length映射到二维数组的坐标，只需要几行代码就能解决。
// 本题考的是二分查找，相对一维数组，多了一个通过偏移量映射坐标的过程。
</code></pre>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPC项目框架研究]]></title>
      <url>/2017/12/21/%E9%A1%B9%E7%9B%AE/IPC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>简单总结一下项目框架的一些实践</p>
<a id="more"></a>
<h2 id="从MVC到前后端分离"><a href="#从MVC到前后端分离" class="headerlink" title="从MVC到前后端分离"></a>从MVC到前后端分离</h2><h3 id="MVC模式的优点与不足"><a href="#MVC模式的优点与不足" class="headerlink" title="MVC模式的优点与不足"></a>MVC模式的优点与不足</h3><p>传统MVC至少有以下三点不足：</p>
<ol>
<li>每次请求必须经过“控制器-&gt;模型-&gt;视图”这个流程，用户才能看到最终的展现的界面，这个过程似乎有些复杂。</li>
<li>实际上视图是依赖于模型的，换句话说，如果没有模型，视图也无法呈现出最终的效果。</li>
<li>渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。</li>
</ol>
<p>REST前端关注界面展现，后端关注业务逻辑，</p>
<p>虽然REST看起来还是很简单的，实际上我们往往需要提供一个REST框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。</p>
<h3 id="REST的实现"><a href="#REST的实现" class="headerlink" title="REST的实现"></a>REST的实现</h3><p>REST的实现，主要是一个框架搭建的过程</p>
<h4 id="统一请求结构"><a href="#统一请求结构" class="headerlink" title="统一请求结构"></a>统一请求结构</h4><p>对于ajax请求，采用自定义的GET、POST、DELETE、MODIFY、ADD字段进行处理。这边特别要注意MODIFY和ADD字段，这两个字段使用非常频繁，也对其的响应做了完整的封装，顾名思义，如果配置需要增加一个字段或修改一个字段，使用MODIFY和ADD能得到显著的语义化的效果，并且在Control的Lua脚本也会自动对其做一套代码请求格式和内容的审核。比如如果是不可写的值，那么有rw属性标示，对其进行MODIFY操作会直接返回指定错误码。</p>
<h4 id="统一响应结构"><a href="#统一响应结构" class="headerlink" title="统一响应结构"></a>统一响应结构</h4><p>首先，返回的JSON响应结构是统一的，前端可以直接对其做一套模版的解析，直接拿到其中的callback数据。其中，错误吗直接在第一层json中展示，data的json层级按照协议标准（参考通用标准制定）可以得到一个经验化的解析方式。</p>
<h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>在lua中做了序列化和反序列化的操作，收到json会直接判断是否是一个格式正确的json，是否包含上述的五种头，如果包含，进行解包，lua自带序列化和反序列化的函数</p>
<h4 id="统一处理模式"><a href="#统一处理模式" class="headerlink" title="统一处理模式"></a>统一处理模式</h4><p>lua中不是对每个原包做解析处理，这样效率太低，也不利于工业生产。我们的做法是如果是请求静态资源，在服务器端就进行处理，不需要传入lua，如果是动态json请求，那么上述也有说过，根据业务逻辑分为GET、POST、DELETE、MODIFY、ADD，这五种情况可以解决绝大部分的需求，并且符合REST的思想。在lua层收到了这个包，lua直接会走一遍流程，这个流程是一个dispatch的过程，详细来说是进行拆包，根据请求的动作进行分发，每种动作都会有安全策略，同时也会对请求的模块进行自定义安全策略检查，然后分发到处理函数。</p>
<p>处理函数相当于接收A对象，然后返回B对象，其中请求字段的模块和函数都已经具名，所以这块也是被统一处理了，结果就非常简单，只要完成这个函数逻辑就可以了，完成后返回的对象会自动组包返回成json格式</p>
<h4 id="支持参数验证"><a href="#支持参数验证" class="headerlink" title="支持参数验证"></a>支持参数验证</h4><p>这一点在统一处理模式中有提及，有两层处理，一是统一处理，根据请求类型、根据请求报文的type字段可以做统一处理，比如如果是number，会有一个min和max的设定，二是对具体的一些项做特殊处理，</p>
<h4 id="处理异常行为"><a href="#处理异常行为" class="headerlink" title="处理异常行为"></a>处理异常行为</h4><p>如果参数不合法或是返回的格式不符合预期，那么会中断并返回err_code来对应具体的问题，前后端实现一套err_code，并在前端进行了一个翻译的过程。</p>
<h4 id="提供安全机制"><a href="#提供安全机制" class="headerlink" title="提供安全机制"></a>提供安全机制</h4><p>这块内容相对多一点，比如说敏感字段过滤、token防范csrf等。</p>
<p>对于token校验流程：</p>
<ol>
<li>当用户登录成功后，在服务端生成一个token，并将其放入内存中，同时将该token返回到客户端。</li>
<li>在客户端中将返回的token写入cookie中，并且每次请求时都将token随请求头一起发送到服务端。</li>
<li>提供一个AOP切面，用于拦截所有的Controller方法，在切面中判断token的有效性。</li>
<li>当登出时，只需清理掉cookie中的token即可，服务端token可设置过期时间，使其自行移除。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Diary_2017.12.21]]></title>
      <url>/2017/12/21/%E7%94%9F%E6%B4%BB/Diary_2017.12.21/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>12.21，周四，晴</p>
<a id="more"></a>
<p>面试到了尾声，反思自己的不足，大部分是在项目上吃了亏。其实项目不仅仅是web方向，对于一整套的服务器框架也是参与实现并很清楚，然而可能更多的关注点不在上面，也没怎么提及，现在想想其实这块不就是封装层吗。</p>
<p>趁着清晨，简单的回顾了一下项目的前后端分离实践，希望能对以后的工作有帮助。</p>
<p>走出公交车，回顾一下最近面试的感觉，蓦然一种天很蓝我很累世间两种人，一种是我一种是其他人的感受。仿佛我的双肩扛着一根金箍棒，逆着人流往上走。此刻我就是孙悟空，是永远无法成为齐天大圣的孙悟空。</p>
<p><img src="http://t1.aixinxi.net/o_1c1s9m27890a1vs1skpsp2uoda.jpeg-w.jpg" alt=""></p>
<p>你看，那个人好像一条狗哎</p>
<p><img src="http://t1.aixinxi.net/o_1c1s9na3mqn43i5a3lvp1hc2a.jpeg-w.jpg" alt=""></p>
<p>十年前看周星驰大话西游，可以笑的没心没肺，而现在看着看着不知不觉就流泪了，想要救紫霞，就必须要打败牛魔王，想要打败牛魔王，就必须要变成孙悟空，想要变成孙悟空，就必须要忘掉七情六欲，看似简单，难的就是那一转身，正所谓不戴金箍，如何救你，戴了金箍，如何爱你，正如现实生活中，假如一个人不工作，如何供你，其实每一个人以前都是那个无忧无虑的至尊宝，只是随着年龄的增长，不得不戴上紧箍咒，拿起金箍棒，成为孙悟空，从而要去承担起所有的责任，再也回不到从前的至尊宝，《大话西游》的结尾有句话，“你看那个人，好奇怪哟，像一条狗”。像条狗的人 是放弃了人间的男女情欢、无欲无念、兢兢业业走在西天取经路上的至尊宝。他如你我这般，收起了脾气火气不再任性淘气，只为梦想奔波</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随感 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Diary_2017.12.20]]></title>
      <url>/2017/12/20/%E7%94%9F%E6%B4%BB/Diary_2017.12.20/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>12.20，周三，晴</p>
<a id="more"></a>
<p>短暂的求职之旅，也即将到达尾声。这期间收获的不仅仅是offer，更多的是一种心态的转变与成长。</p>
<p>在大学的日子也学，也不是很努力。在工作的两年努力，也没什么方向。而这一周多的时间，让我收获的是方向的认知和自我驱动力。知道自己要做什么，知道自己怎么做最好，努力去做的更好，也许一些东西都不明确，但我愿意去尝试去学，去珍惜时间。</p>
<p>调整作息，自我驱动，把学习看成一种享受，总结和研究作为一种乐趣，反而视频游戏索然无味，这在以前是完全做不到的，只能说早点撕破伪装，直面淋漓的现实，早点自愈并自我驱动，早点踏上一条承担责任的道路，勇敢的走下去，痛并快乐着。</p>
<p>尝试了几家面试，对自己的不足有了比较清晰的认识。收offer不一定是自己的实力多高，也可能是一半运气的帮助。但我相信如果实力可以凌驾于运气，那么这一定不是什么困难事。接下来就是要把握工作的机会，感恩公司，为了公司和自己的发展，努力的工作与提高，早日达到实力可以凌驾于运气的那一天。</p>
<p>再写点什么吧，说说自己怎么去学技术的一点理解</p>
<p>[看文档] 最快的学习方法。我的想法是不要细读空想看demo，快速通读一遍，有一个直观的理解，然后对比项目的框架平台，看看具体的使用细节，考虑是否可以优化，没用到的文档内容是否有价值，是否可以应用到项目中，能否解决现有的一些问题。 </p>
<p>[读源码] 深入研究的唯一途径。读源码有几大好处，一是可以对底层的实现有个更深刻的理解，知道这东西是这么做的，为什么要这么做，二是对功能有个清晰的认识，知道这个实现应用在这个地方合适，在那个地方不合适，有什么优点或缺陷，三是一种思想的传承与归纳，也许实现细节不同，但是好的思想可以总结和归纳，有利于对这门技术有更深刻的认识。</p>
<p>[做东西] 折腾这件事，其实是必不可少的。学习的一个很大的弊端是，看的文档多，但是做的东西少，知道API，但没有用过，以为自己会了，其实然并卵。折腾其实是一个踩坑的过程，也就一定要做笔记，分析思考总结，记录哪些坑，怎么走最优。这是一个经验化的东西，不怕踩的坑多，就怕一马平川，做完反而没太多收获。</p>
<p>其他一些学习的策略，比如深度和广度，我的理解是：</p>
<p>如果未找到兴趣方向，可以适当开发广度，多一点认识，多挖掘一点兴趣</p>
<p>如果找到了兴趣方向，那么就要适时摒弃广度，把兴趣点挖深，吃透这个点，思想、实现、优化，然后跟踪后续的一个发展，这其实是非常有价值的。挖深的一个好处是，类似的方向的思想是相同的，比如几种设计模式，面向对象的思想，经典的算法，不同语言都有涉及，大牛完全可以举一反三，事半功倍的去学习，而不是广度学习的囫囵吞枣。</p>
<p>反正，加油。</p>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随感 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面试重点之手写代码]]></title>
      <url>/2017/12/16/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>总结前端面试常见的一些手写代码。</p>
<a id="more"></a>
<h1 id="面试重点之手写代码"><a href="#面试重点之手写代码" class="headerlink" title="面试重点之手写代码"></a>面试重点之手写代码</h1><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h4><p>组合是指组合借用构造函数和原型链继承两种方式。</p>
<pre><code class="javascript">//2.原型连继承和借用构造函数 组合实现继承 （组合继承解决原型链继承的引用类型原型属性被实例共享问题）  
function father(name) {  
  this.faName = &#39;father&#39;;  
}  
father.prototype.getfaName = function() {  
  console.log(this.faName);  
};  
function child(args) {  
  this.chName = &#39;child&#39;;  
  father.apply(this,[]); //第二次调用父类构造函数  
}  
child.prototype = new father(); //第一次调用父类构造函数  
child.prototype.constructor = child;  
child.prototype.getchName = function() {  
  console.log(this.chName);  
};  
/* 
缺点：1.两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部） 
     2.子类继承父类的属性，第二次一组在子类实例上，第一次一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低 
*/
</code></pre>
<h4 id="ES6继承"><a href="#ES6继承" class="headerlink" title="ES6继承"></a>ES6继承</h4><pre><code class="javascript">class Parent {
}
class Child1 extends Parent {
    constructor(x, y, colors) {
         super(x, y); // 调用父类的constructor(x, y)
         this.colors = colors;
    }
    toString() {
         return this.colors + &#39; &#39; + super.toString(); 
    }
}
</code></pre>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><h4 id="验证是否是数组（前提是toString-方法没有被重写过）"><a href="#验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="验证是否是数组（前提是toString()方法没有被重写过）"></a>验证是否是数组（前提是toString()方法没有被重写过）</h4><pre><code class="javascript">functionisArray(obj){ 
    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ;
}
</code></pre>
<h4 id="数组之间追加"><a href="#数组之间追加" class="headerlink" title="数组之间追加"></a>数组之间追加</h4><pre><code class="javascript">var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; 
var array2 = [&quot;Doe&quot; , 555 , 100]; 
Array.prototype.push.apply(array1, array2); 
/* array1 值为  [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */
</code></pre>
<h4 id="给每一个-log-消息添加一个”-app-”的前辍"><a href="#给每一个-log-消息添加一个”-app-”的前辍" class="headerlink" title="给每一个 log 消息添加一个”(app)”的前辍"></a>给每一个 log 消息添加一个”(app)”的前辍</h4><pre><code class="javascript">function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift(&#39;(app)&#39;);
  console.log.apply(console, args);
};
</code></pre>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><pre><code class="javascript">Function.prototype.bind = function (oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1), 
      fToBind = this, 
      fNOP = function () {},
      fBound = function () {
        return fToBind.apply(
          this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>当使用<code>new</code>去调用构造函数时，相当于执行了</p>
<pre><code class="javascript">var o = {};
o.__proto__ = F.prototype;
F.call(o);
</code></pre>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><pre><code class="javascript">$.ajax({  
  url:&quot;&quot;,  
  type:&quot;get&quot;,  
  dataType:&quot;jsonp&quot;,
  jsonp: &quot;callback&quot;,//服务端用于接收callback调用的function名的参数【后台接受什么参数，我们就传什么参数】我们上面设置是callback
  success:function(data){},
  error:function(XMLHttpRequest, textStatus, errorThrown){}  
});
</code></pre>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix:after {
  content:&quot;.&quot;; 
  display:block; 
  height:0; 
  visibility:hidden; 
  clear:both; }
.clearfix { *zoom:1; }
</code></pre>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><h4 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h4><pre><code class="javascript">$.ajax({
    url:&#39;/comm/test1.php&#39;,
    type:&#39;POST&#39;, //GET
    async:true,    //或false,是否异步
    data:{
        name:&#39;yang&#39;,age:25
    },
    timeout:5000,    //超时时间
    dataType:&#39;json&#39;,    //返回的数据格式：json/xml/html/script/jsonp/text
    beforeSend:function(xhr){
        console.log(xhr)
        console.log(&#39;发送前&#39;)
    },
    success:function(data,textStatus,jqXHR){
        console.log(data)
        console.log(textStatus)
        console.log(jqXHR)
    },
    error:function(xhr,textStatus){
        console.log(&#39;错误&#39;)
        console.log(xhr)
        console.log(textStatus)
    },
    complete:function(){
        console.log(&#39;结束&#39;)
    }
})
</code></pre>
<h4 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h4><pre><code class="javascript">$(&#39;#send&#39;).click(function(){
    //请求的5个阶段，对应readyState的值
        //0: 未初始化，send方法未调用；
        //1: 正在发送请求，send方法已调用；
        //2: 请求发送完毕，send方法执行完毕；
        //3: 正在解析响应内容；
        //4: 响应内容解析完毕；
    var data = &#39;name=yang&#39;;
    var xhr = new XMLHttpRequest();   //创建一个ajax对象
    xhr.onreadystatechange = function(event){    //对ajax对象进行监听
        if(xhr.readyState == 4){    //4表示解析完毕
            if(xhr.status == 200){    //200为正常返回
                console.log(xhr)
            }
        }
    };
    xhr.open(&#39;POST&#39;,&#39;url&#39;,true);    //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步
    xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);    //可有可无
    xhr.send(data);        //发送
});
</code></pre>
<p>###ES6 class</p>
<pre><code class="javascript">class Animal {
    constructor () {
        this.type = &#39;animal&#39;
    }
    says(say) {
        console.log(this.type + &#39;says&#39; + say)
    }
}
 let animal = new Animal()
 animal.says(&#39;hello&#39;) // animal says hello

 class Cat extends Animal {
     constructor() {
         super()
         this.type = &#39;cat&#39;
     }
 }
 let cat = new Cat()
 cat.says(&#39;hello&#39;) // cat says hello
</code></pre>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>方法一：利用indexOf方法；</p>
<pre><code class="javascript">var aa=[1,3,5,4,3,3,1,4]
function arr(arr) {
  var result=[]
  for(var i=0; i&lt;arr.length; i++){
    if(result.indexOf(arr[i])==-1){
      result.push(arr[i])
    }
  }
  console.log(result)
}      
arr(aa)
</code></pre>
<p>方法二：es6 set</p>
<p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p>
<pre><code class="javascript">var arr=[1,2,3,4,4,4,5,6,7,7,7,8,9,9,9,9,0,0,0,12];
var arr2=[...new Set(arr)];
console.log(arr2);
</code></pre>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON实现"><a href="#JSON实现" class="headerlink" title="JSON实现"></a>JSON实现</h4><pre><code>var cloneObj = JSON.parse(JSON.stringify(obj));
</code></pre><p>坏处也显而易见，这会抛弃对象的constructor，也就是深复制之后，无论这个对象原本的构造函数是什么，在深复制之后都会变成Object。</p>
<h4 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h4><pre><code class="javascript">function getType(obj){
  //tostring会返回对应不同的标签的构造函数
  var toString = Object.prototype.toString;
  var map = {
    &#39;[object Boolean]&#39;  : &#39;boolean&#39;, 
    &#39;[object Number]&#39;   : &#39;number&#39;, 
    &#39;[object String]&#39;   : &#39;string&#39;, 
    &#39;[object Function]&#39; : &#39;function&#39;, 
    &#39;[object Array]&#39;    : &#39;array&#39;, 
    &#39;[object Date]&#39;     : &#39;date&#39;, 
    &#39;[object RegExp]&#39;   : &#39;regExp&#39;, 
    &#39;[object Undefined]&#39;: &#39;undefined&#39;,
    &#39;[object Null]&#39;     : &#39;null&#39;, 
    &#39;[object Object]&#39;   : &#39;object&#39;
  };
  if(obj instanceof Element) {
    return &#39;element&#39;;
  }
  return map[toString.call(obj)];
}

function deepClone(data){
  var type = getType(data);
  var obj;

  if(type === &#39;array&#39;){
    obj = [];
  } else if(type === &#39;object&#39;){
    obj = {};
  } else {
    //不再具有下一层次
    return data;
  }

  if(type === &#39;array&#39;){
    for(var i = 0, len = data.length; i &lt; len; i++){
      obj.push(deepClone(data[i]));
    }
  } else if(type === &#39;object&#39;){
    for(var key in data){
      obj[key] = deepClone(data[key]);
    }
  }
  return obj;
}
</code></pre>
<p>对于function类型，这里是直接赋值的，还是共享一个内存值。这是因为函数更多的是完成某些功能，有个输入值和返回值，而且对于上层业务而言更多的是完成业务功能，并不需要真正将函数深拷贝。</p>
<h3 id="获取URL参数"><a href="#获取URL参数" class="headerlink" title="获取URL参数,"></a>获取URL参数,</h3><blockquote>
<p>JS获取URL参数,返回数组,直接调用 </p>
</blockquote>
<pre><code class="javascript">function GetUrlPars(){
var url=location.search;
var theRequest = new Object();
if(url.indexOf(&quot;?&quot;)!=-1)
{
   var str = url.substr(1);
   strs = str.split(&quot;&amp;&quot;);
   for(var i=0;i&lt;strs.length;i++)
  {
      var sTemp = strs[i].split(&quot;=&quot;);
      theRequest[sTemp[0]]=(sTemp[1]);
  }
}
return theRequest;
}
var mYRequest = GetUrlPars();
var 参数1值 =  mYRequest[&quot;参数1&quot;];
</code></pre>
<h3 id="实现一个简单的观察者模式"><a href="#实现一个简单的观察者模式" class="headerlink" title="实现一个简单的观察者模式"></a>实现一个简单的观察者模式</h3><p>略</p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><blockquote>
<p>O(nlogn) + 不稳定</p>
</blockquote>
<pre><code class="javascript">function quickSort(arr){
  if(arr.length&lt;=1){return arr;}
  var pivotIndex=Math.floor(arr.length/2);
  var pivot=arr.splice(pivotIndex,1)[0];
  var left=[];
  var right=[];
  for(var i=0;i&lt;arr.length;i++){
    if(arr[i]&lt;pivot){
      left.push(arr[i]);
    }else{
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot],quickSort(right));
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试攻略 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Diary_2017.12.15]]></title>
      <url>/2017/12/16/%E7%94%9F%E6%B4%BB/Diary_2017.12.15/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>从今天开始，开始记日记。目的是：</p>
<ul>
<li>记录学习方向，总结成长历程，调整战术</li>
<li>一段时间，三天or一周，回顾和总结，调整战略</li>
</ul>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随感 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JQuery]]></title>
      <url>/2017/12/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/JQuery/JQuery/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>jquery知识点整理。</p>
<p>jquery ajax没整理。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id=""><a href="#" class="headerlink" title="$()"></a>$()</h2><p>$()函数是JQuery函数的别名</p>
<p>$()函数用于将任何对象包裹成jQuery对象</p>
<h2 id="jQuery入口函数与Js入口函数的区别"><a href="#jQuery入口函数与Js入口函数的区别" class="headerlink" title="jQuery入口函数与Js入口函数的区别"></a>jQuery入口函数与Js入口函数的区别</h2><p>js入口函数指的是：window.onload = function(){};</p>
<p>jQuery入口函数是：$(document).ready()</p>
<table>
<thead>
<tr>
<th>window.onload</th>
<th></th>
<th>$(document).ready()</th>
</tr>
</thead>
<tbody>
<tr>
<td>必须等待网页中所有的内容加载完毕后（包括图片）才能执行</td>
<td>执行时机</td>
<td>网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完</td>
</tr>
<tr>
<td>不能同时编写多个 ，出现多次会存在事件覆盖的问题。</td>
<td>编写个数</td>
<td>能同时编写多个</td>
</tr>
<tr>
<td>无</td>
<td>简化写法</td>
<td>$(document).ready(function(){});可以简写成$(function(){});</td>
</tr>
<tr>
<td>很差</td>
<td>兼容性</td>
<td>好</td>
</tr>
</tbody>
</table>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul>
<li>ID选择器：#</li>
<li>类选择器： .</li>
<li>标签选择器： element</li>
</ul>
<h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><ul>
<li>后代选择器：空格</li>
<li>子代选择器：&gt;</li>
</ul>
<h3 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h3><p>索引号为index：<strong>:eq(index)</strong></p>
<p>索引号为奇数：<strong>:odd</strong></p>
<p>索引号为偶数：<strong>:even</strong></p>
<h2 id="jQuery操作"><a href="#jQuery操作" class="headerlink" title="jQuery操作"></a>jQuery操作</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>查找指定元素的所有后代元素（子子孙孙）：find(selector)</p>
<p>查找指定元素的直接子元素（亲儿子元素）：children()</p>
<p>查找所有兄弟元素（不包括自己）：siblings()</p>
<p>查找父元素（亲的）：parent()</p>
<p>查找指定元素的第index个元素，index是索引号，从0开始：eq(index)</p>
<h3 id="选择网页元素"><a href="#选择网页元素" class="headerlink" title="选择网页元素"></a>选择网页元素</h3><pre><code class="javascript">$(&#39;a:first&#39;)//选择网页中第一个a元素  
$(&#39;tr:odd&#39;)//选择表格的奇数行  
$(&#39;#myForm :input&#39;)//选择表单中的input元素  
$(&#39;div:visible&#39;) //选择可见的div元素  
$(&#39;div:gt(2)&#39;)//选择所有的div元素，除了前三个  
$(&#39;div:animated&#39;)//选择当前处于动画状态的div元素
</code></pre>
<h3 id="改变结果集"><a href="#改变结果集" class="headerlink" title="改变结果集"></a>改变结果集</h3><pre><code class="javascript">$(&#39;div&#39;).has(&#39;p&#39;); //选择包含p元素的div元素  
$(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素  
$(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素  
$(&#39;div&#39;).first(); //选择第1个div元素  
$(&#39;div&#39;).eq(5); //选择第6个div元素  
$(&#39;div&#39;).next(&#39;p&#39;); //选择div元素后面的第一个p元素  
$(&#39;div&#39;).parent(); //选择div元素的父元素  
$(&#39;div&#39;).closest(&#39;form&#39;); //选择离div最近的那个form父元素  
$(&#39;div&#39;).children(); //选择div的所有子元素  
$(&#39;div&#39;).siblings(); //选择div的同级元素
</code></pre>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p>.end()：回到最近的一个”破坏性”操作之前。如果之前没有破坏性操作，则返回一个空集。所谓的”破坏性”就是指任何改变所匹配的jQuery元素的操作。</p>
<h3 id="元素的操作：取值和赋值"><a href="#元素的操作：取值和赋值" class="headerlink" title="元素的操作：取值和赋值"></a>元素的操作：取值和赋值</h3><p>常见的取值和赋值函数如下：</p>
<ol>
<li>html() 返回或设置被选元素的内容 (inner HTML)    </li>
<li>text() 取出或设置text内容      </li>
<li><strong>attr()</strong> 取出或设置某个属性的值    </li>
<li>width() 取出或设置某个元素的宽度    </li>
<li>height() 取出或设置某个元素的高度  </li>
<li>val() 取出或设置html内容 取出某个表单元素的值  </li>
<li>css() 设置css样式</li>
</ol>
<p>需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。</p>
<h3 id="元素的操作：移动"><a href="#元素的操作：移动" class="headerlink" title="元素的操作：移动"></a>元素的操作：移动</h3><ol>
<li>.insertAfter()和.after()：在现存元素的外部，从后面插入元素  </li>
<li>.insertBefore()和.before()：在现存元素的外部，从前面插入元素  </li>
<li>.appendTo()和.append()：在现存元素的内部，从后面插入元素  </li>
<li>.prependTo()和.prepend()  ：在现存元素的内部，从前面插入元素</li>
</ol>
<h3 id="元素的操作：复制、删除和创建"><a href="#元素的操作：复制、删除和创建" class="headerlink" title="元素的操作：复制、删除和创建"></a>元素的操作：复制、删除和创建</h3><p>复制元素使用.clone()</p>
<p>删除元素使用.remove()和.detach()。两者的区别在于，<strong>前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。</strong></p>
<p>清空元素内容（但是不删除该元素）使用.empty()。</p>
<h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><p> $.trim() 去除字符串两端的空格。<br> $.each() 遍历一个数组或对象。<br> $.inArray() 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。<br> $.grep() 返回数组中符合某种标准的元素。<br> $.extend() 将多个对象，合并到第一个对象。<br> $.makeArray() 将对象转化为数组。<br> $.type() 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。<br> $.isArray() 判断某个参数是否为数组。<br> $.isEmptyObject() 判断某个对象是否为空（不含有任何属性）。<br> $.isFunction() 判断某个参数是否为函数。<br> $.isPlainObject() 判断某个参数是否为用”{}”或”new Object”建立的对象。<br> $.support() 判断浏览器是否支持某个特性。 </p>
<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><p> .blur() 表单元素失去焦点。<br> .change() 表单元素的值发生变化<br> .click() 鼠标单击<br> .dblclick() 鼠标双击<br> .focus() 表单元素获得焦点<br> .focusin() 子元素获得焦点<br> .focusout() 子元素失去焦点<br> .hover() 同时为mouseenter和mouseleave事件指定处理函数<br> .keydown() 按下键盘（长时间按键，只返回一个事件）<br> .keypress() 按下键盘（长时间按键，将返回多个事件）<br> .keyup() 松开键盘<br> .load() 元素加载完毕<br> .mousedown() 按下鼠标<br> .mouseenter() 鼠标进入（进入子元素不触发）<br> .mouseleave() 鼠标离开（离开子元素不触发）<br> .mousemove() 鼠标在元素内部移动<br> .mouseout() 鼠标离开（离开子元素也触发）<br> .mouseover() 鼠标进入（进入子元素也触发）<br> .mouseup() 松开鼠标<br> .ready() DOM加载完成<br> .resize() 浏览器窗口的大小发生改变<br> .scroll() 滚动条的位置发生变化<br> .select() 用户选中文本框中的内容<br> .submit() 用户递交表单<br> .toggle() 根据鼠标点击的次数，依次运行多个函数<br> .unload()  用户离开页面  </p>
<p><strong>特别的</strong></p>
<ul>
<li>.bind()：以上这些事件在jQuery内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件</li>
<li>.one()：只想让事件运行一次</li>
<li>.unbind()：解除事件绑定</li>
</ul>
<p>所有的事件处理函数，都可以接受一个事件对象(event object)作为参数，这个事件对象有一些很有用的属性和方法：</p>
<p>event.pageX 事件发生时，鼠标距离网页左上角的水平距离 　　<br>event.pageY 事件发生时，鼠标距离网页左上角的垂直距离<br>event.type 事件的类型（比如click） 　　<br>event.which 按下了哪一个键 　　<br>event.data在事件对象上绑定数据，然后传入事件处理函数 　　<br>event.target 事件针对的网页元素<br>event.preventDefault() 阻止事件的默认行为（比如点击链接，会自动打开新页面）<br>event.stopPropagation() 停止事件向上层元素冒泡</p>
<p>有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。</p>
<pre><code class="javascript">$(&#39;a&#39;).click();
$(&#39;a&#39;).trigger(&#39;click&#39;);
</code></pre>
<h3 id="特殊效果"><a href="#特殊效果" class="headerlink" title="特殊效果"></a>特殊效果</h3><p>.fadeIn() 淡入<br>.fadeOut() 淡出<br>.fadeTo() 调整透明度<br>.hide() 隐藏元素<br>.show() 显示元素<br>.slideDown() 向下展开<br>.slideUp() 向上卷起<br>.slideToggle() 依次展开或卷起某个元素<br>.toggle() 依次展示或隐藏某个元素</p>
<p>除了.show()和.hide()，所有其他特效的默认执行时间都是400ms(毫秒)，但是你可以改变这个设置。</p>
<p>更复杂的特效，可以用.animate()自定义。</p>
<p>.stop()和.delay()用来停止或延缓特效的执行。</p>
<p>$.fx.off如果设置为true，则关闭所有网页特效。</p>
<p>几个常见的筛选选择器：</p>
<p>filter()：筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式</p>
<pre><code class="javascript">//保留子元素中不含有ol的元素。
//&lt;p&gt;&lt;ol&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;&lt;p&gt;How are you?&lt;/p&gt;
$(&quot;p&quot;).filter(function(index) {
 return $(&quot;ol&quot;, this).length == 0;
});
//&lt;p&gt;How are you?&lt;/p&gt;
</code></pre>
<p>silce()：选取一个匹配的子集</p>
<pre><code class="javascript">//选择第一个p元素
//&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;
$(&quot;p&quot;).slice(0, 1).wrapInner(&quot;&lt;b&gt;&lt;/b&gt;&quot;);
//&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-jQuery对象和DOM对象的相互转换"><a href="#Case1-jQuery对象和DOM对象的相互转换" class="headerlink" title="Case1.jQuery对象和DOM对象的相互转换"></a>Case1.jQuery对象和DOM对象的相互转换</h2><pre><code class="javascript">var btn = document.getElementById(“btnShow”);
var $btn = $(“#btnShow”); // $btn就是一个jQuery对象

//DOM对象转换成jQuery对象
var $btn1 = $(btn);

//jQuery对象转换成DOM对象
var btn1 = $btn[0]; 
var btn2 = $btn.get(0);
</code></pre>
<h2 id="Case2-如何找到所有-HTML-select-标签的选中项？"><a href="#Case2-如何找到所有-HTML-select-标签的选中项？" class="headerlink" title="Case2.如何找到所有 HTML select 标签的选中项？"></a>Case2.如何找到所有 HTML select 标签的选中项？</h2><pre><code class="javascript">$(&#39;[name=NameOfSelectedTag] :selected&#39;)
</code></pre>
<h2 id="Case3-jQuery-里的-each-是什么函数？你是如何使用它的？"><a href="#Case3-jQuery-里的-each-是什么函数？你是如何使用它的？" class="headerlink" title="Case3. jQuery 里的 each() 是什么函数？你是如何使用它的？"></a>Case3. jQuery 里的 each() 是什么函数？你是如何使用它的？</h2><p>each() 函数就像是 Java 里的一个 Iterator，它允许你遍历一个元素集合。你可以传一个函数给 each() 方法，被调用的 jQuery 对象会在其每个元素上执行传入的函数。</p>
<pre><code class="javascript">$(&#39;[name=NameOfSelectedTag] :selected&#39;).each(function(selected) {
    alert($(selected).text());
});
</code></pre>
<h2 id="Case4-this-和-this-关键字在-jQuery-中有何不同？"><a href="#Case4-this-和-this-关键字在-jQuery-中有何不同？" class="headerlink" title="Case4.$(this) 和 this 关键字在 jQuery 中有何不同？"></a>Case4.$(this) 和 this 关键字在 jQuery 中有何不同？</h2><p>$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法</p>
<p>而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。</p>
<h2 id="Case5-你如何使用jQuery来提取一个HTML-标记的属性-例如-链接的href"><a href="#Case5-你如何使用jQuery来提取一个HTML-标记的属性-例如-链接的href" class="headerlink" title="Case5.你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href?"></a>Case5.你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href?</h2><pre><code class="javascript">$(&#39;a&#39;).each(function(){
   alert($(this).attr(&#39;href&#39;));
});
</code></pre>
<h2 id="Case6-jQuery中-detach-和-remove-方法的区别是什么"><a href="#Case6-jQuery中-detach-和-remove-方法的区别是什么" class="headerlink" title="Case6.jQuery中 detach() 和 remove() 方法的区别是什么?"></a>Case6.jQuery中 detach() 和 remove() 方法的区别是什么?</h2><p>尽管 detach() 和 remove() 方法都被用来移除一个DOM元素, 两者之间的主要不同在于 detach() 会保持对过去被解除元素的跟踪, 因此它可以被取消解除, 而 remove() 方法则会保持过去被移除对象的引用. </p>
<h2 id="Case7-你如何利用jQuery来向一个元素中添加和移除CSS类"><a href="#Case7-你如何利用jQuery来向一个元素中添加和移除CSS类" class="headerlink" title="Case7.你如何利用jQuery来向一个元素中添加和移除CSS类?"></a>Case7.你如何利用jQuery来向一个元素中添加和移除CSS类?</h2><p>利用 addClass() 和 removeClass() 这两个 jQuery 方法。</p>
<h2 id="Case8-使用-CDN-加载-jQuery-库的主要优势是什么"><a href="#Case8-使用-CDN-加载-jQuery-库的主要优势是什么" class="headerlink" title="Case8.使用 CDN 加载 jQuery 库的主要优势是什么 ?"></a>Case8.使用 CDN 加载 jQuery 库的主要优势是什么 ?</h2><ul>
<li>节省服务器带宽</li>
<li>更快的下载速度</li>
<li>只需要下载一次。如果浏览器已经从同一个CDN下载类相同的 jQuery 版本, 那么它就不会再去下载它一次.</li>
</ul>
<h2 id="Case9-jQuery-get-和-jQuery-ajax-方法之间的区别是什么"><a href="#Case9-jQuery-get-和-jQuery-ajax-方法之间的区别是什么" class="headerlink" title="Case9.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?"></a>Case9.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?</h2><p>ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。get() 方法是一个只获取一些数据的专门化方法。</p>
<h3 id="Case10-要是在一个-jQuery-事件处理程序里返回了-false-会怎样？"><a href="#Case10-要是在一个-jQuery-事件处理程序里返回了-false-会怎样？" class="headerlink" title="Case10. 要是在一个 jQuery 事件处理程序里返回了 false 会怎样？"></a>Case10. 要是在一个 jQuery 事件处理程序里返回了 false 会怎样？</h3><p>通常用于阻止事件向上冒泡。</p>
<h3 id="Case11-哪种方式更高效：document-getElementbyId-“myId”-还是-“-myId”-？"><a href="#Case11-哪种方式更高效：document-getElementbyId-“myId”-还是-“-myId”-？" class="headerlink" title="Case11. 哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？"></a>Case11. 哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？</h3><p>第一种，因为它直接调用了 JavaScript 引擎。</p>
<h2 id="Case12-当CDN上的jQuery文件不可用时，该怎么办？"><a href="#Case12-当CDN上的jQuery文件不可用时，该怎么办？" class="headerlink" title="Case12.当CDN上的jQuery文件不可用时，该怎么办？"></a>Case12.当CDN上的jQuery文件不可用时，该怎么办？</h2><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; language=&quot;Javascript&quot; src=&quot;http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.1.min.js &quot;&gt;&lt;/script&gt;

&lt;script type=&#39;text/javascript&#39;&gt;//&lt;![CDATA[
if (typeof jQuery == &#39;undefined&#39;) {
document.write(unescape(&quot;%3Cscript src=&#39;/Script/jquery-1.4.1.min.js&#39; type=&#39;text/javascript&#39; %3E%3C/script%3E&quot;));
}//]]&gt;
&lt;/script&gt;
</code></pre>
<h2 id="Case13-jQuery中的Delegate-函数有什么作用？"><a href="#Case13-jQuery中的Delegate-函数有什么作用？" class="headerlink" title="Case13.jQuery中的Delegate()函数有什么作用？"></a>Case13.jQuery中的Delegate()函数有什么作用？</h2><p>delegate()会在以下两个情况下使用到：</p>
<ol>
<li>如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：</li>
</ol>
<pre><code class="javascript">$(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function(){
    $(this).hide();
});
</code></pre>
<p>2、当元素在当前页面中不可用时，可以使用delegate()</p>
<h2 id="Case14-jQuery编码和解码URL？"><a href="#Case14-jQuery编码和解码URL？" class="headerlink" title="Case14.jQuery编码和解码URL？"></a>Case14.jQuery编码和解码URL？</h2><p>encodeURIComponent(url) and decodeURIComponent(url)</p>
<h3 id="Case15-如何用jQuery禁用浏览器的前进后退按钮？"><a href="#Case15-如何用jQuery禁用浏览器的前进后退按钮？" class="headerlink" title="Case15. 如何用jQuery禁用浏览器的前进后退按钮？"></a>Case15. 如何用jQuery禁用浏览器的前进后退按钮？</h3><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;
$(document).ready(function() {
     window.history.forward(1);    // 原理就是产生一个“前进”的动作，以抵消后退功能
     //OR
     window.history.forward(-1);
});
&lt;/script&gt;
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jb51.net/article/85471.htm" target="_blank" rel="external">jQuery基础知识点总结(必看)</a></li>
<li><a href="http://www.jb51.net/article/54745.htm" target="_blank" rel="external">jquery学习总结（超级详细）</a></li>
<li><a href="http://www.cnblogs.com/mehjb/p/6095230.html" target="_blank" rel="external">最常见的 20 个 jQuery 面试问题及答案</a></li>
<li><a href="http://www.cnblogs.com/vanone/p/5257157.html" target="_blank" rel="external">jQuery经典面试题及答案精选</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6-cheatsheet]]></title>
      <url>/2017/12/04/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/ES6/ES6%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ES6参考手册。</p>
<a id="more"></a>
<h1 id="es6-cheatsheet"><a href="#es6-cheatsheet" class="headerlink" title="es6-cheatsheet"></a>es6-cheatsheet</h1><p>这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><p>[TOC]</p>
<h2 id="var-versus-let-const"><a href="#var-versus-let-const" class="headerlink" title="var versus let / const"></a>var versus let / const</h2><blockquote>
<p>除了 <code>var</code> 以外，我们现在多了两个新的标识符来声明变量的存储，它们就是 <code>let</code> 和 <code>const</code>。<br>不同于 <code>var</code> ，<code>let</code> 和 <code>const</code> 语句不会造成声明提升。<br>关于声明提升，可以看另一篇转发文章<a href="janet.github.io/">javascript变量声明提升(hoisting)</a></p>
</blockquote>
<p>一个 <code>var</code> 的例子:</p>
<pre><code class="javascript">var snack = &#39;Meow Mix&#39;;

function getFood(food) {
    if (food) {
        var snack = &#39;Friskies&#39;;
        return snack;
    }
    return snack;
}

getFood(false); // undefined
</code></pre>
<p>让我们再观察下面语句中，使用 <code>let</code> 替换了 <code>var</code> 后的表现：</p>
<pre><code class="javascript">let snack = &#39;Meow Mix&#39;;

function getFood(food) {
    if (food) {
        let snack = &#39;Friskies&#39;;
        return snack;
    }
    return snack;
}

getFood(false); // &#39;Meow Mix&#39;
</code></pre>
<blockquote>
<p><strong>注意</strong>：<code>let</code> 和 <code>const</code> 是块级作用域语句。所以在语句块以外引用这些变量时，会造成引用错误 <code>ReferenceError</code>。</p>
<p><strong>最佳实践</strong>: 在重构老代码时，<code>var</code> 声明需要格外的注意。在创建一个新项目时，使用 <code>let</code> 声明一个变量，使用 <code>const</code> 来声明一个不可改变的常量。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Replacing-IIFEs-with-Blocks"><a href="#Replacing-IIFEs-with-Blocks" class="headerlink" title="Replacing IIFEs with Blocks"></a>Replacing IIFEs with Blocks</h2><p>我们以往创建一个 <strong>立即执行函数</strong> 时，一般是在函数最外层包裹一层括号。<br>ES6支持块级作用域（更贴近其他语言），我们现在可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现，</p>
<pre><code class="javascript">(function () {
    var food = &#39;Meow Mix&#39;;
}());

console.log(food); // Reference Error
</code></pre>
<p>使用支持块级作用域的ES6的版本：</p>
<pre><code class="javascript">{
    let food = &#39;Meow Mix&#39;;
};

console.log(food); // Reference Error
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h2><blockquote>
<p>this需要总结，请参考xxx</p>
</blockquote>
<p>一些时候，我们在函数嵌套中需要访问上下文中的 <code>this</code>。比如下面的例子：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character; // Cannot read property &#39;name&#39; of undefined
    });
};
</code></pre>
<blockquote>
<p>关于map方法，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Array.prototype.map()</a></p>
</blockquote>
<p>一种通用的方式是把上下文中的 <code>this</code> 保存在一个变量里：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    var that = this; // Store the context of this
    return arr.map(function (character) {
        return that.name + character;
    });
};
</code></pre>
<p>我们也可以把 <code>this</code> 通过属性传进去：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }, this);
};
</code></pre>
<p>还可以直接使用 <code>bind</code>：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }.bind(this));
};
</code></pre>
<p>使用 <strong>箭头函数</strong>，<code>this</code> 的值不用我们再做如上几段代码的特殊处理，直接使用即可。<br>上面的代码可以重写为下面这样：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(character =&gt; this.name + character);
};
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：使用箭头函数，再也不用考虑 <code>this</code> 的问题了。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>在ES6中，标准库也被同样增强了，像字符串对象就新增了 <code>.includes()</code> 和 <code>.repeat()</code> 方法。</p>
<h3 id="includes"><a href="#includes" class="headerlink" title=".includes( )"></a>.includes( )</h3><pre><code class="javascript">var string = &#39;food&#39;;
var substring = &#39;foo&#39;;

console.log(string.indexOf(substring) &gt; -1);
</code></pre>
<p>现在，我们可以使用 <code>.includes()</code> 方法，替代以往判断内容 <code>&gt; -1</code> 的方式。<br><code>.includes()</code> 方法会极简地返回一个布尔值结果。</p>
<pre><code class="javascript">const string = &#39;food&#39;;
const substring = &#39;foo&#39;;

console.log(string.includes(substring)); // true
</code></pre>
<h3 id="repeat"><a href="#repeat" class="headerlink" title=".repeat( )"></a>.repeat( )</h3><pre><code class="javascript">function repeat(string, count) {
    var strings = [];
    while(strings.length &lt; count) {
        strings.push(string);
    }
    return strings.join(&#39;&#39;);
}
</code></pre>
<p>在ES6中，我们可以使用一个极简的方法来实现重复字符：</p>
<pre><code class="javascript">// String.repeat(numberOfRepetitions)
&#39;meow&#39;.repeat(3); // &#39;meowmeowmeow&#39;
</code></pre>
<h3 id="Template-Literals"><a href="#Template-Literals" class="headerlink" title="Template Literals"></a>Template Literals</h3><p>使用 <strong>字符串模板字面量</strong>，我可以在字符串中直接使用特殊字符，而不用转义。</p>
<pre><code class="javascript">var text = &quot;This string contains \&quot;double quotes\&quot; which are escaped.&quot;;
</code></pre>
<pre><code class="javascript">let text = `This string contains &quot;double quotes&quot; which don&#39;t need to be escaped anymore.`;
</code></pre>
<p><strong>字符串模板字面量</strong> 还支持直接插入变量，可以实现字符串与变量的直接连接输出。</p>
<pre><code class="javascript">var name = &#39;Tiger&#39;;
var age = 13;

console.log(&#39;My cat is named &#39; + name + &#39; and is &#39; + age + &#39; years old.&#39;);
</code></pre>
<p>更简单的版本：</p>
<pre><code class="javascript">const name = &#39;Tiger&#39;;
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
</code></pre>
<p>ES5中，我们要这样生成多行文本：</p>
<pre><code class="javascript">var text = (
    &#39;cat\n&#39; +
    &#39;dog\n&#39; +
    &#39;nickelodeon&#39;
);
</code></pre>
<p>或者：</p>
<pre><code class="javascript">var text = [
    &#39;cat&#39;,
    &#39;dog&#39;,
    &#39;nickelodeon&#39;
].join(&#39;\n&#39;);
</code></pre>
<p><strong>字符串模板字面量</strong> 让我们不必特别关注多行字符串中的换行转义符号，直接换行即可：</p>
<pre><code class="javascript">let text = ( `cat
dog
nickelodeon`
);
</code></pre>
<p><strong>字符串模板字面量</strong> 内部可以使用表达式，像这样：</p>
<pre><code class="javascript">let today = new Date();
let text = `The time and date is ${today.toLocaleString()}`;
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p>解构让我们可以使用非常便捷的语法，<strong>直接将数组或者对象中的值直接分别导出到多个变量中</strong>，</p>
<h3 id="Destructuring-Arrays"><a href="#Destructuring-Arrays" class="headerlink" title="Destructuring Arrays"></a>Destructuring Arrays</h3><p><strong>解构数组</strong></p>
<pre><code class="javascript">let [a, b, c, d] = [1, 2, 3, 4];

console.log(a); // 1
console.log(b); // 2
</code></pre>
<h3 id="Destructuring-Objects"><a href="#Destructuring-Objects" class="headerlink" title="Destructuring Objects"></a>Destructuring Objects</h3><p><strong>解构对象</strong></p>
<pre><code class="javascript">let luke = { occupation: &#39;jedi&#39;, father: &#39;anakin&#39; };
let {occupation, father} = luke;

console.log(occupation); // &#39;jedi&#39;
console.log(father); // &#39;anakin&#39;
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>ES6之前，浏览器端的模块化代码，我们使用像<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>这样的库，<br>在 <strong>Node.js</strong> 中，我们则使用 <a href="https://nodejs.org/api/modules.html#modules_module_require_id" target="_blank" rel="external">require</a>。<br>在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。</p>
<h3 id="Exporting-in-CommonJS"><a href="#Exporting-in-CommonJS" class="headerlink" title="Exporting in CommonJS"></a>Exporting in CommonJS</h3><pre><code class="javascript">module.exports = 1;
module.exports = { foo: &#39;bar&#39; };
module.exports = [&#39;foo&#39;, &#39;bar&#39;];
module.exports = function bar () {};
</code></pre>
<h3 id="Exporting-in-ES6"><a href="#Exporting-in-ES6" class="headerlink" title="Exporting in ES6"></a>Exporting in ES6</h3><p>在ES6中，提供了多种设置模块出口的方式，比如我们要导出一个变量，那么使用 <strong>变量名</strong> ：</p>
<pre><code class="javascript">export let name = &#39;David&#39;;
export let age  = 25;
</code></pre>
<p>还可以为对象 <strong>导出一个列表</strong>：</p>
<pre><code class="javascript">function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

export { sumTwo, sumThree };
</code></pre>
<p>我们也可以使用简单的一个 <code>export</code> 关键字来导出一个结果值：</p>
<pre><code class="javascript">export function sumTwo(a, b) {
    return a + b;
}

export function sumThree(a, b, c) {
    return a + b + c;
}
</code></pre>
<p>最后，我们可以 <strong>导出一个默认出口</strong>：</p>
<pre><code class="javascript">function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

let api = {
    sumTwo,
    sumThree
};

export default api;

/*
 * 与以下的语句是对等的:
 * export { api as default };
 */
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：总是在模块的 <strong>最后</strong> 使用 <code>export default</code> 方法。<br>它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。<br>更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。<br>坚持这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。</p>
</blockquote>
<h3 id="Importing-in-ES6"><a href="#Importing-in-ES6" class="headerlink" title="Importing in ES6"></a>Importing in ES6</h3><p>ES6提供了好几种模块的导入方式。我们可以单独引入一个文件：</p>
<pre><code class="javascript">import &#39;underscore&#39;;
</code></pre>
<blockquote>
<p>这里需要注意的是， <strong>整个文件的引入方式会执行该文件内的最上层代码</strong>。</p>
</blockquote>
<p>就像Python一样，我们还可以命名引用：</p>
<pre><code class="javascript">import { sumTwo, sumThree } from &#39;math/addition&#39;;
</code></pre>
<p>我们甚至可以使用 <code>as</code> 给这些模块重命名：</p>
<pre><code class="javascript">import {
    sumTwo as addTwoNumbers,
    sumThree as sumThreeNumbers
} from &#39;math/addition&#39;;
</code></pre>
<p>另外，我们能 <strong>引入所有的东西（原文：import all the things）</strong> （也称为命名空间引入）</p>
<pre><code class="javascript">import * as util from &#39;math/addition&#39;;
</code></pre>
<p>最后，我们能可以从一个模块的众多值中引入一个列表：</p>
<pre><code class="javascript">import * as additionUtil from &#39;math/addtion&#39;;
const { sumTwo, sumThree } = additionUtil;
</code></pre>
<p>像这样引用默认对象：</p>
<pre><code class="javascript">import api from &#39;math/addition&#39;;
// Same as: import { default as api } from &#39;math/addition&#39;;
</code></pre>
<p>我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的：</p>
<pre><code class="javascript">// foos.js
export { foo as default, foo1, foo2 };
</code></pre>
<p>那我们可以如此导入这个模块的值：</p>
<pre><code class="javaqscript">import foo, { foo1, foo2 } from &#39;foos&#39;;
</code></pre>
<p>我们还可以导入commonjs模块，例如React：</p>
<pre><code class="javascript">import React from &#39;react&#39;;
const { Component, PropTypes } = React;
</code></pre>
<p>更简化版本：</p>
<pre><code class="javascript">import React, { Component, PropTypes } from &#39;react&#39;;
</code></pre>
<blockquote>
<p><strong>注意</strong>：被导出的值是被 <strong>绑定的（原文：bingdings）</strong>，而不是引用。<br>所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>在ES5中，许多种方法来处理函数的 <strong>参数默认值（default values）</strong>，<strong>参数数量（indefinite arguments）</strong>，<strong>参数命名（named parameters）</strong>。<br>ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。</p>
<h3 id="Default-Parameters"><a href="#Default-Parameters" class="headerlink" title="Default Parameters"></a>Default Parameters</h3><pre><code class="javascript">function addTwoNumbers(x, y) {
    x = x || 0;
    y = y || 0;
    return x + y;
}
</code></pre>
<p>ES6中，我们可以简单为函数参数启用默认值：</p>
<pre><code class="javascript">function addTwoNumbers(x=0, y=0) {
    return x + y;
}
</code></pre>
<h3 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h3><p>ES5中，遇到参数数量不确定时，我们只能如此处理：</p>
<pre><code class="javascript">function logArguments() {
    for (var i=0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    }
}
</code></pre>
<p>使用 <strong>rest</strong> 操作符，我们可以给函数传入一个不确定数量的参数列表：</p>
<pre><code class="javascript">function logArguments(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
</code></pre>
<h3 id="Named-Parameters"><a href="#Named-Parameters" class="headerlink" title="Named Parameters"></a>Named Parameters</h3><p>命名函数<br>ES5中，当我们要处理多个 <strong>命名参数</strong> 时，通常会传入一个 <strong>选项对象</strong> 的方式，这种方式被jQuery采用。</p>
<pre><code class="javascript">function initializeCanvas(options) {
    var height = options.height || 600;
    var width  = options.width  || 400;
    var lineStroke = options.lineStroke || &#39;black&#39;;
}
</code></pre>
<p>我们可以利用上面提到的新特性 <strong>解构</strong> ，来完成与上面同样功能的函数：</p>
<pre><code class="javascript">function initializeCanvas(
    { height=600, width=400, lineStroke=&#39;black&#39;}) {
        // ...
    }
    // Use variables height, width, lineStroke here
</code></pre>
<p>如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了：</p>
<pre><code class="javascript">function initializeCanvas(
    { height=600, width=400, lineStroke=&#39;black&#39;} = {}) {
        // ...
    }
</code></pre>
<h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入：</p>
<pre><code class="javascript">Math.max(...[-1, 100, 9001, -32]); // 9001
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样：</p>
<pre><code class="javascript">function Person(name, age, gender) {
    this.name   = name;
    this.age    = age;
    this.gender = gender;
}

Person.prototype.incrementAge = function () {
    return this.age += 1;
};
</code></pre>
<p>继承父类的子类需要这样：</p>
<pre><code class="javascript">function Personal(name, age, gender, occupation, hobby) {
    Person.call(this, name, age, gender);
    this.occupation = occupation;
    this.hobby = hobby;
}

Personal.prototype = Object.create(Person.prototype);
Personal.prototype.constructor = Personal;
Personal.prototype.incrementAge = function () {
    return Person.prototype.incrementAge.call(this) += 20;
};
</code></pre>
<p>ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类：</p>
<pre><code class="javascript">class Person {
    constructor(name, age, gender) {
        this.name   = name;
        this.age    = age;
        this.gender = gender;
    }

    incrementAge() {
      this.age += 1;
    }
}
</code></pre>
<p>继承父类的子类只要简单的使用 <code>extends</code> 关键字就可以了：</p>
<pre><code class="javascript">class Personal extends Person {
    constructor(name, age, gender, occupation, hobby) {
        super(name, age, gender);
        this.occupation = occupation;
        this.hobby = hobby;
    }

    incrementAge() {
        super.incrementAge();
        this.age += 20;
        console.log(this.age);
    }
}
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：ES6新的类语法把我们从晦涩难懂的实现和原型操作中解救出来，这是个非常适合初学者的功能，而且能让我们写出更干净整洁的代码。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols在ES6版本之前就已经存在了，但现在我们拥有一个公共的接口来直接使用它们。<br>Symbols是不可更改的（immutable）并且唯一的（unique），它可用作任何hash数据类型中的键。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol( )"></a>Symbol( )</h3><p>调用 <code>Symbol()</code> 或者 <code>Symbol(描述文本)</code> 会创建一个唯一的、在全局中不可以访问的Symbol对象。<br>一个 <code>Symbol()</code> 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。<br>例如，如果你想给 <code>React.Component</code> 这个类添加一个 <code>refreshComponent</code> 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做：</p>
<pre><code class="javascript">const refreshComponent = Symbol();

React.Component.prototype[refreshComponent] = () =&gt; {
    // do something
}
</code></pre>
<h3 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h3><p>使用 <code>Symbol.for(key)</code> 也是会创建一个不可改变的Symbol对象，但区别于上面的创建方法，这个对象是在全局中可以被访问到的。<br>两次相同的 <code>Symbol.for(key)</code> 调用会返回相同的Symbol实例。</p>
<p><strong>提示</strong>：这并不同于 <code>Symbol(description)</code>。</p>
<pre><code class="javascript">Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;) // false
Symbol.for(&#39;foo&#39;) === Symbol(&#39;foo&#39;) // false
Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;) // true
</code></pre>
<p>Symbols常用的一个使用场景，尤其是使用 <code>Symbol.for(key)</code> 方法，是用于实现代码间的互操作。<br>在你的代码中，通过在包含一些已知接口的第三方库的对象参数中查找Symbol成员，你可以实现这种互操作。<br>例如：</p>
<pre><code class="javascript">function reader(obj) {
    const specialRead = Symbol.for(&#39;specialRead&#39;);
    if (obj[specialRead]) {
        const reader = obj[specialRead]();
        // do something with reader
    } else {
        throw new TypeError(&#39;object cannot be read&#39;);
    }
}
</code></pre>
<p>之后在另一个库中：</p>
<pre><code class="javascript">const specialRead = Symbol.for(&#39;specialRead&#39;);

class SomeReadableType {
    [specialRead]() {
        const reader = createSomeReaderFrom(this);
        return reader;
    }
}
</code></pre>
<blockquote>
<p><strong>注意</strong>：关于Symbol互操作的使用，一个值得一提的例子是<code>Symbol.iterable</code> 。<code>Symbol.iterable</code>存在ES6的所有可枚举对象中：数组（Arrays）、字符串（strings）、生成器（Generators）等等。当它作为一个方法被调用时，它将会返回一个带有枚举接口的对象。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><strong>Maps</strong> 是一个JavaScript中很重要（迫切需要）的数据结构。<br>在ES6之前，我们创建一个 <strong>hash</strong> 通常是使用一个对象：</p>
<pre><code class="javascript">var map = new Object();
map[key1] = &#39;value1&#39;;
map[key2] = &#39;value2&#39;;
</code></pre>
<p>但是，这样的代码无法避免函数被特别的属性名覆盖的意外情况：</p>
<pre><code class="javascript">&gt; getOwnProperty({ hasOwnProperty: &#39;Hah, overwritten&#39;}, &#39;Pwned&#39;);
&gt; TypeError: Property &#39;hasOwnProperty&#39; is not a function
</code></pre>
<p><strong>Maps</strong> 让我们使用 <code>set</code>，<code>get</code> 和 <code>search</code> 操作数据。</p>
<pre><code class="javascript">let map = new Map();
&gt; map.set(&#39;name&#39;, &#39;david&#39;);
&gt; map.get(&#39;name&#39;); // david
&gt; map.has(&#39;name&#39;); // true
</code></pre>
<p>Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。</p>
<pre><code class="javascript">let map = new Map([
    [&#39;name&#39;, &#39;david&#39;],
    [true, &#39;false&#39;],
    [1, &#39;one&#39;],
    [{}, &#39;object&#39;],
    [function () {}, &#39;function&#39;]
]);

for (let key of map.keys()) {
    console.log(typeof key);
    // &gt; string, boolean, number, object, function
}
</code></pre>
<blockquote>
<p><strong>提示</strong>：当使用 <code>map.get()</code> 判断值是否相等时，非基础类型比如一个函数或者对象，将不会正常工作。<br>有鉴于此，还是建议使用字符串，布尔和数字类型的数据类型。</p>
</blockquote>
<p>我们还可以使用 <code>.entries()</code> 方法来遍历整个map对象：</p>
<pre><code class="javascript">for (let [key, value] of map.entries()) {
    console.log(key, value);
}
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="WeakMaps"><a href="#WeakMaps" class="headerlink" title="WeakMaps"></a>WeakMaps</h2><p>在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定：</p>
<pre><code class="javascript">class Person {
    constructor(age) {
        this._age = age;
    }

    _incrementAge() {
        this._age += 1;
    }
}
</code></pre>
<p>在一个开源项目中，命名规则很难维持得一直很好，这样经常会造成一些困扰。<br>此时，我们可以选择使用WeakMaps来替代Maps来存储我们的数据：</p>
<pre><code class="javascript">let _age = new WeakMap();
class Person {
    constructor(age) {
        _age.set(this, age);
    }

    incrementAge() {
        let age = _age.get(this) + 1;
        _age.set(this, age);
        if (age &gt; 50) {
            console.log(&#39;Midlife crisis&#39;);
        }
    }
}
</code></pre>
<p>使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 <code>Reflect.ownKeys()</code>：</p>
<pre><code class="javascript">&gt; const person = new Person(50);
&gt; person.incrementAge(); // &#39;Midlife crisis&#39;
&gt; Reflect.ownKeys(person); // []
</code></pre>
<p>一个使用WeakMaps存储数据更实际的例子，是存储与DOM元素相关联的数据，而这不会对DOM元素本身产生污染：</p>
<pre><code class="javascript">let map = new WeakMap();
let el  = document.getElementById(&#39;someElement&#39;);

// Store a weak reference to the element with a key
map.set(el, &#39;reference&#39;);

// Access the value of the element
let value = map.get(el); // &#39;reference&#39;

// Remove the reference
el.parentNode.removeChild(el);
el = null;

value = map.get(el); // undefined
</code></pre>
<p>上面的例子中，一旦对象被垃圾回收器给销毁了，WeakMaps会自动的把这个对象所对应的键值对数据同时销毁。</p>
<blockquote>
<p><strong>提示</strong>：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的。使用WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。<br>通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常有效的。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promises让我们把多缩进难看的代码（回调地狱）：</p>
<pre><code class="javascript">func1(function (value1) {
    func2(value1, function (value2) {
        func3(value2, function (value3) {
            func4(value3, function (value4) {
                func5(value4, function (value5) {
                    // Do something with value 5
                });
            });
        });
    });
});
</code></pre>
<p>写成这样：</p>
<pre><code class="javascript">func1(value1)
    .then(func2)
    .then(func3)
    .then(func4)
    .then(func5, value5 =&gt; {
        // Do something with value 5
    });
</code></pre>
<p>在ES6之前，我们使用<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a> 或者<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a>。现在我们有了原生版本的 Promises：</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt;
    reject(new Error(&#39;Failed to fulfill Promise&#39;)))
        .catch(reason =&gt; console.log(reason));
</code></pre>
<p>这里有两个处理函数，<strong>resolve</strong>（当Promise执行成功完毕时调用的回调函数） 和 <strong>reject</strong> （当Promise执行不接受时调用的回调函数）</p>
<blockquote>
<p><strong>Promises的好处</strong>：大量嵌套错误处理回调函数会使代码变得难以阅读理解。<br>使用Promises，我们可以通过清晰的路径将错误事件让上传递，并且适当地处理它们。<br>此外，Promise处理后的值，无论是解决（resolved）还是拒绝（rejected）的结果值，都是不可改变的。</p>
</blockquote>
<p>下面是一些使用Promises的实际例子：</p>
<pre><code class="javascript">var request = require(&#39;request&#39;);

return new Promise((resolve, reject) =&gt; {
  request.get(url, (error, response, body) =&gt; {
    if (body) {
        resolve(JSON.parse(body));
      } else {
        resolve({});
      }
  });
});
</code></pre>
<p>我们还可以使用 <code>Promise.all()</code> 来 <strong>并行化</strong> 的处理一组异步的操作。</p>
<pre><code class="javascript">let urls = [
  &#39;/api/commits&#39;,
  &#39;/api/issues/opened&#39;,
  &#39;/api/issues/assigned&#39;,
  &#39;/api/issues/completed&#39;,
  &#39;/api/issues/comments&#39;,
  &#39;/api/pullrequests&#39;
];

let promises = urls.map((url) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    $.ajax({ url: url })
      .done((data) =&gt; {
        resolve(data);
      });
  });
});

Promise.all(promises)
  .then((results) =&gt; {
    // Do something with results of all our promises
 });
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><p>就像<a href="https://github.com/DrkSephy/es6-cheatsheet#promises" target="_blank" rel="external">Promises</a>如何让我们避免<a href="http://callbackhell.com/" target="_blank" rel="external">回调地狱</a>一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。<br>Generators实际上是支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external">暂停运行</a>，随后根据上一步的返回值再继续运行的一种函数。</p>
<p>下面代码是一个使用generators函数的简单例子：</p>
<pre><code class="javascript">function* sillyGenerator() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var generator = sillyGenerator();
&gt; console.log(generator.next()); // { value: 1, done: false }
&gt; console.log(generator.next()); // { value: 2, done: false }
&gt; console.log(generator.next()); // { value: 3, done: false }
&gt; console.log(generator.next()); // { value: 4, done: false }
</code></pre>
<p>就像上面的例子，当<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" target="_blank" rel="external">next</a>运行时，它会把我们的generator向前“推动”，同时执行新的表达式。<br>我们能利用Generators来像书写同步代码一样书写异步代码。</p>
<pre><code class="javascript">// Hiding asynchronousity with Generators

function request(url) {
    getJSON(url, function(response) {
        generator.next(response);
    });
}
</code></pre>
<p>这里我们写个generator函数将要返回我们的数据：</p>
<pre><code class="javascript">function* getData() {
    var entry1 = yield request(&#39;http://some_api/item1&#39;);
    var data1  = JSON.parse(entry1);
    var entry2 = yield request(&#39;http://some_api/item2&#39;);
    var data2  = JSON.parse(entry2);
}
</code></pre>
<p>借助于 <code>yield</code>，我们可以保证 <code>entry1</code> 确实拿到数据并转换后再赋值给 <code>data1</code>。</p>
<p>当我们使用generators来像书写同步代码一样书写我们的异步代码逻辑时，没有一种清晰简单的方式来处理期间可能会产生的错误或者异常。在这种情况下，我们可以在我们的generator中引入Promises来处理，就像下面这样：</p>
<pre><code class="javascript">function request(url) {
    return new Promise((resolve, reject) =&gt; {
        getJSON(url, resolve);
    });
}
</code></pre>
<p>我们再写一个函数，其中使用 <code>next</code> 来步进我们的generator的同时，再利用我们上面的 <code>request</code> 方法来产生（yield）一个Promise。</p>
<pre><code class="javascript">function iterateGenerator(gen) {
    var generator = gen();
    var ret;
    (function iterate(val) {
        ret = generator.next();
        if(!ret.done) {
            ret.value.then(iterate);
        }
    })();
}
</code></pre>
<p>在Generator中引入了Promises后，我们就可以通过Promise的 <code>.catch</code> 和 <code>reject</code> 来捕捉和处理错误了。<br>使用了我们新版的Generator后，新版的调用就像老版本一样简单可读（译者注：有微调）：</p>
<pre><code class="javascript">iterateGenerator(function* getData() {
    var entry1 = yield request(&#39;http://some_api/item1&#39;);
    var data1  = JSON.parse(entry1);
    var entry2 = yield request(&#39;http://some_api/item2&#39;);
    var data2  = JSON.parse(entry2);
});
</code></pre>
<p>在使用Generator后，我们可以重用我们的老版本代码实现，以此展示了Generator的力量。<br>当使用Generators和Promises后，我们可以像书写同步代码一样书写异步代码的同时优雅地解决了错误处理问题。<br>此后，我们实际上可以开始利用更简单的一种方式了，它就是<a href="https://github.com/DrkSephy/es6-cheatsheet#async-await" target="_blank" rel="external">async-await</a>。</p>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h2><p><code>async await</code> 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子：</p>
<pre><code class="javascript">var request = require(&#39;request&#39;);

function getJSON(url) {
  return new Promise(function(resolve, reject) {
    request(url, function(error, response, body) {
      resolve(body);
    });
  });
}

async function main() {
  var data = await getJSON();
  console.log(data); // NOT undefined!
}

main();
</code></pre>
<p>它们看上去和Generators很像。我（作者）强烈推荐使用 <code>async await</code> 来替代Generators + Promises的写法。<br><a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" target="_blank" rel="external">这里</a>是个很好的学习资源，让我们学习和使用这项ES7中的新功能。</p>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue源码阅读]]></title>
      <url>/2017/12/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/Vue/Vue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>TODO：整理的很乱，需要细化并补充完整</p>
<a id="more"></a>
<h1 id="Vue源码阅读"><a href="#Vue源码阅读" class="headerlink" title="Vue源码阅读"></a>Vue源码阅读</h1><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><h4 id="为什么会有Virtual-DOM"><a href="#为什么会有Virtual-DOM" class="headerlink" title="为什么会有Virtual DOM?"></a>为什么会有Virtual DOM?</h4><p>DOM操作都是很慢 &gt;&gt; 因为DOM的属性太多，可能触发重排的操作很多</p>
<p>Virtual DOM：操作js对象，然后最后把这个对象再一起转换成真正的DOM就行了，所以就变成 代码 =&gt; Virtual DOM( 一个特殊的js对象） =&gt; DOM</p>
<h4 id="什么是Virtual-DOM"><a href="#什么是Virtual-DOM" class="headerlink" title="什么是Virtual DOM"></a>什么是Virtual DOM</h4><p>一个特殊的js对象</p>
<pre><code class="javascript">export class VNode {
  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array&lt;VNode&gt;,
    text?: string,
    ...
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    ...
  }
}
</code></pre>
<h4 id="Virtual-DOM算法"><a href="#Virtual-DOM算法" class="headerlink" title="Virtual DOM算法"></a>Virtual DOM算法</h4><ul>
<li>首先是js对象（Virtual DOM）描述树（<code>vm._render</code>)，转换dom插入(第一次渲染）</li>
<li>状态变化，生成新的js对象（Virtual DOM），比对新旧对象</li>
<li>将变更应用到DOM上，并保存新的js对象（Virtual DOM），重复第二步操作</li>
</ul>
<p>用js对象描述树(生成Virtual DOM），Vue中就是先转成AST生成code,然后通过$creatElement通过Vnode的那种形式生成Virtual DOM (<code>vm._render的操作</code>)</p>
<p><code>vm._update</code>（其实就是Virtual DOM算法的后两步）</p>
<pre><code class="javascript">function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    if (vm._isMounted) {...}
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(...)
    } else {
      // updates
      vm.$el = vm.__patch__(...)
    }
}
</code></pre>
<p><code>vm.__patch__</code>，其实它就是Virtual DOM Diff的核心</p>
<h5 id="Virtual-DOM-Diff"><a href="#Virtual-DOM-Diff" class="headerlink" title="Virtual DOM Diff"></a>Virtual DOM Diff</h5><p>patch函数</p>
<pre><code class="javascript">function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      // 老节点不存在，直接创建元素
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue, parentElm, refElm)
    } else {
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {
        // patch existing root node
        // 新节点和老节点相同，则给老节点打补丁
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
      } else {
        // ... 省略ssr代码
        // replacing existing element
        // 新节点和老节点相同，直接替换老节点
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )
      }
    }
    // ...省略代码
    return vnode.elm
  }
</code></pre>
<p>所以patch大概做下面几件事</p>
<ul>
<li>判断老节点存不存在<ul>
<li>不存在则为首次渲染，直接创建元素</li>
<li>存在的话则sameVnode使用判断根节点是否相同<ul>
<li>相同则使用patchVnode给老节点打补丁</li>
<li>不相同则使用新节点直接替换老节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于sameVnode判断，其实就是简单比较了几个属性判断</p>
<pre><code class="javascript">function sameVnode (a, b) {
  return (
    a.key === b.key &amp;&amp; (
      (
        a.tag === b.tag &amp;&amp;
        a.isComment === b.isComment &amp;&amp;
        isDef(a.data) === isDef(b.data) &amp;&amp;
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &amp;&amp;
        a.asyncFactory === b.asyncFactory &amp;&amp;
        isUndef(b.asyncFactory.error)
      )
    )
  )
}
</code></pre>
<p>patchVnode</p>
<pre><code class="javascript">function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  if (oldVnode === vnode) {
    // 新老节点相同
    return
  }
  // ... 省略代码
  if (isUndef(vnode.text)) {
    // 假如新节点没有text
    if (isDef(oldCh) &amp;&amp; isDef(ch)) {
      // 假如老节点和新节点都有子节点
      // 不相等则更新子节点
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
    } else if (isDef(ch)) {
      // 新节点有子节点，老节点没有
      // 老节点加上
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      // 老节点有子节点，新节点没有
      // 老节点移除
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      // 老节点有文本，新节点没有文本
      nodeOps.setTextContent(elm, &#39;&#39;)
    }
  } else if (oldVnode.text !== vnode.text) {
    // 假如新节点和老节点text不相等
    nodeOps.setTextContent(elm, vnode.text)
  }
  if (isDef(data)) {
    if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)
  }
}
</code></pre>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="步骤一：用JS对象模拟DOM树"><a href="#步骤一：用JS对象模拟DOM树" class="headerlink" title="步骤一：用JS对象模拟DOM树"></a>步骤一：用JS对象模拟DOM树</h3><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点</p>
<h3 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异</h3><p>两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比</p>
<h4 id="深度优先遍历，记录差异"><a href="#深度优先遍历，记录差异" class="headerlink" title="深度优先遍历，记录差异"></a>深度优先遍历，记录差异</h4><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<p>上面的<code>div</code>和新的<code>div</code>有差异，当前的标记是0，那么：</p>
<pre><code>patches[0] = [{difference}, {difference}, ...] // 用数组存储新旧节点的不同
</code></pre><h4 id="差异类型"><a href="#差异类型" class="headerlink" title="差异类型"></a>差异类型</h4><p>对 DOM 操作可能会：</p>
<ol>
<li>替换掉原来的节点，例如把上面的<code>div</code>换成了<code>section</code></li>
<li>移动、删除、新增子节点，例如上面<code>div</code>的子节点，把<code>p</code>和<code>ul</code>顺序互换</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变。</li>
</ol>
<p>对于重新排序，替代开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动</p>
<h4 id="列表对比算法"><a href="#列表对比算法" class="headerlink" title="列表对比算法"></a>列表对比算法</h4><p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="external">Edition Distance</a>），最常见的解决算法是 <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="external">Levenshtein Distance</a>，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。</p>
<h3 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上"></a>步骤三：把差异应用到真正的DOM树上</h3><p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：</p>
<pre><code class="javascript">function applyPatches (node, currentPatches) {
  currentPatches.forEach(function (currentPatch) {
    switch (currentPatch.type) {
      case REPLACE:
        node.parentNode.replaceChild(currentPatch.node.render(), node)
        break
      case REORDER:
        reorderChildren(node, currentPatch.moves)
        break
      case PROPS:
        setProps(node, currentPatch.props)
        break
      case TEXT:
        node.textContent = currentPatch.content
        break
      default:
        throw new Error(&#39;Unknown patch type &#39; + currentPatch.type)
    }
  })
}
</code></pre>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Virtual DOM 算法主要是实现上面步骤的三个函数：<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="external">element</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="external">diff</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="external">patch</a>。然后就可以实际的进行使用：</p>
<pre><code class="javascript">// 1. 构建虚拟DOM
var tree = el(&#39;div&#39;, {&#39;id&#39;: &#39;container&#39;}, [
    el(&#39;h1&#39;, {style: &#39;color: blue&#39;}, [&#39;simple virtal dom&#39;]),
    el(&#39;p&#39;, [&#39;Hello, virtual-dom&#39;]),
    el(&#39;ul&#39;, [el(&#39;li&#39;)])
])

// 2. 通过虚拟DOM构建真正的DOM
var root = tree.render()
document.body.appendChild(root)

// 3. 生成新的虚拟DOM
var newTree = el(&#39;div&#39;, {&#39;id&#39;: &#39;container&#39;}, [
    el(&#39;h1&#39;, {style: &#39;color: red&#39;}, [&#39;simple virtal dom&#39;]),
    el(&#39;p&#39;, [&#39;Hello, virtual-dom&#39;]),
    el(&#39;ul&#39;, [el(&#39;li&#39;), el(&#39;li&#39;)])
])

// 4. 比较两棵虚拟DOM树的不同
var patches = diff(tree, newTree)

// 5. 在真正的DOM元素上应用变更
patch(root, patches)
</code></pre>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年前端面试题整理汇总100题]]></title>
      <url>/2017/12/01/%E9%9D%A2%E8%AF%95/%E5%89%8D%E7%AB%AF/2017%E5%B9%B4%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%E6%B1%87%E6%80%BB100%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>计划是做一套面试集，面试是一种对自己的能力的评价，有必要在面试中发现自己的问题。</p>
<p>参考网上问题整理</p>
<a id="more"></a>
<h2 id="开放性题目"><a href="#开放性题目" class="headerlink" title="开放性题目"></a>开放性题目</h2><ol>
<li>自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。</li>
<li>项目介绍</li>
<li>如何看待前端开发？</li>
<li>平时是如何学习前端开发的？</li>
<li>未来三到五年的规划是怎样的？</li>
<li>说说你对前端架构师的理解<ol>
<li>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率； </li>
<li>带领团队完成研发工具及平台前端部分的设计、研发和维护； </li>
<li>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先 </li>
<li>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</li>
</ol>
</li>
</ol>
<ol>
<li><p>什么样的前端代码是好的</p>
<p>高复用低耦合，这样文件小，好维护，而且好扩展。</p>
</li>
</ol>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="WEB标准"><a href="#WEB标准" class="headerlink" title="WEB标准"></a>WEB标准</h3><h4 id="1-defer和async"><a href="#1-defer和async" class="headerlink" title="1. defer和async"></a>1. defer和async</h4><ul>
<li>defer并行加载js文件，会按照页面上script标签的顺序执行 </li>
<li>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li>
</ul>
<h4 id="2-说说你对语义化的理解？"><a href="#2-说说你对语义化的理解？" class="headerlink" title="2. 说说你对语义化的理解？"></a>2. 说说你对语义化的理解？</h4><ol>
<li>结构清晰</li>
<li>SEO</li>
<li>方便其他设备解析</li>
<li>便于团队开发和维护，语义化更具可读性，可以减少差异化。</li>
</ol>
<h4 id="3-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#3-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="3. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>3. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h4><ol>
<li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器以何种模式来渲染文档。</li>
<li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行。</li>
<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
<li><code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现。</li>
</ol>
<h4 id="4-你知道多少种Doctype文档类型？"><a href="#4-你知道多少种Doctype文档类型？" class="headerlink" title="4. 你知道多少种Doctype文档类型？"></a>4. 你知道多少种<code>Doctype</code>文档类型？</h4><p>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p>
<p>标准模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而包容模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<h4 id="5-HTML与XHTML——二者有什么区别"><a href="#5-HTML与XHTML——二者有什么区别" class="headerlink" title="5. HTML与XHTML——二者有什么区别"></a>5. HTML与XHTML——二者有什么区别</h4><ol>
<li>所有的标记都必须要有一个相应的结束标记</li>
<li>所有标签的元素和属性的名字都必须使用小写</li>
<li>所有的XML标记都必须合理嵌套</li>
<li>所有的属性必须用引号””括起来</li>
<li>把所有&lt;和&amp;特殊符号用编码表示</li>
<li>给所有属性赋一个值</li>
<li>不要在注释内容中使“–”</li>
<li>图片必须有说明文字</li>
</ol>
<h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="1-Web-Worker-和webSocket"><a href="#1-Web-Worker-和webSocket" class="headerlink" title="1. Web Worker 和webSocket"></a>1. Web Worker 和webSocket</h4><p>worker主线程:</p>
<ol>
<li>通过 <code>worker = new Worker( url )</code> 加载一个JS文件来创建一个worker，同时返回一个worker实例。</li>
<li>通过<code>worker.postMessage( data )</code> 方法来向worker发送数据。</li>
<li>绑定<code>worker.onmessage</code>方法来接收worker发送过来的数据。</li>
<li>可以使用 <code>worker.terminate()</code> 来终止一个worker的执行。</li>
</ol>
<p><code>WebSocket</code>是<code>Web</code>应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个<code>Html5</code>协议，<code>WebSocket</code>的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p>
<h4 id="2-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#2-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="2.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>2.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<p><strong>新特性</strong></p>
<ul>
<li>拖拽释放(Drag and drop) API</li>
<li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li>
<li>音频、视频API(audio,video)</li>
<li>画布(Canvas) API</li>
<li>地理(Geolocation) API</li>
<li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li>
<li>sessionStorage 的数据在浏览器关闭后自动删除</li>
<li>表单控件，calendar、date、time、email、url、search</li>
<li>新的技术webworker, websocket, Geolocation</li>
</ul>
<p><strong>移除的元素</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<p><strong>支持HTML5新标签</strong></p>
<ul>
<li><p>html5shim框架</p>
<pre><code class="html">&lt;!--[if lt IE 9]&gt;
&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre>
</li>
</ul>
<h4 id="3-如何实现浏览器内多个标签页之间的通信"><a href="#3-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="3.如何实现浏览器内多个标签页之间的通信?"></a>3.如何实现浏览器内多个标签页之间的通信?</h4><ul>
<li>localstorge、cookies</li>
</ul>
<h4 id="4-WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#4-WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="4. WEB应用从服务器主动推送Data到客户端有那些方式？"></a>4. WEB应用从服务器主动推送Data到客户端有那些方式？</h4><ul>
<li><p>Javascript数据推送(AJAX轮询)</p>
</li>
<li><p><code>Commet</code>：基于HTTP长连接的服务器推送技术</p>
<ul>
<li>HTTP 和JSONP方式的长轮询：把 script 标签附加到页面上以让脚本执行。</li>
<li>XHR长轮询：建议采用</li>
<li>iframe</li>
</ul>
</li>
<li><p>基于<code>WebSocket</code>的推送方案</p>
</li>
<li><p><code>SSE</code>（Server-Send Event）：服务器推送数据新方式</p>
</li>
</ul>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><h4 id="1-列举IE-与其他浏览器不一样的特性？"><a href="#1-列举IE-与其他浏览器不一样的特性？" class="headerlink" title="1. 列举IE 与其他浏览器不一样的特性？"></a>1. 列举IE 与其他浏览器不一样的特性？</h4><ul>
<li>IE支持<code>currentStyle</code>，FIrefox使用<code>getComputStyle</code></li>
<li>IE 使用<code>innerText</code>，Firefox使用<code>textContent</code></li>
<li>滤镜方面：IE:<code>filter:alpha(opacity= num)</code>；Firefox：<code>-moz-opacity:num</code></li>
<li>事件方面：IE：<code>attachEvent</code>：火狐是<code>addEventListener</code></li>
<li>鼠标位置：IE是<code>event.clientX</code>；火狐是<code>event.pageX</code></li>
<li>IE使用<code>event.srcElement</code>；Firefox使用<code>event.target</code></li>
<li>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置<code>margin:0;padding:0以及list-style:none</code></li>
<li>CSS圆角：ie7以下不支持圆角</li>
</ul>
<h4 id="2-ie各版本和chrome可以并行下载多少个资源"><a href="#2-ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="2. ie各版本和chrome可以并行下载多少个资源"></a>2. ie各版本和chrome可以并行下载多少个资源</h4><p>IE6 两个并发，其他都6个</p>
<h4 id="3-IE缓存问题"><a href="#3-IE缓存问题" class="headerlink" title="3. IE缓存问题"></a>3. IE缓存问题</h4><p>在IE浏览器下，如果请求的方法是<code>GET</code>，并且请求的<code>URL</code>不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的<code>URL</code>，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(<code>&#39;t&#39;= + new Date().getTime()</code>)</p>
<p>或者：</p>
<pre><code>open(&#39;GET&#39;,&#39;demo.php?rand=+Math.random()&#39;,true);//
</code></pre><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h4 id="1-position的值，-relative和absolute分别是相对于谁进行定位的？"><a href="#1-position的值，-relative和absolute分别是相对于谁进行定位的？" class="headerlink" title="1. position的值， relative和absolute分别是相对于谁进行定位的？"></a>1. position的值， relative和absolute分别是相对于谁进行定位的？</h4><ul>
<li><code>absolute</code> :生成绝对定位的元素， 相对于被设置成相对定位<code>relative</code>的父元素来进行定位。</li>
<li><code>fixed</code> （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</li>
<li><code>relative</code> 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>
<li><code>static</code> 默认值。没有定位，元素出现在正常的流中</li>
<li><code>sticky</code> 生成粘性定位的元素，容器的位置根据正常文档流计算得出</li>
</ul>
<h4 id="2-谈谈浮动和清除浮动"><a href="#2-谈谈浮动和清除浮动" class="headerlink" title="2. 谈谈浮动和清除浮动"></a>2. 谈谈浮动和清除浮动</h4><p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p>
<h4 id="3-display-none和visibility-hidden的区别？"><a href="#3-display-none和visibility-hidden的区别？" class="headerlink" title="3. display:none和visibility:hidden的区别？"></a>3. display:none和visibility:hidden的区别？</h4><ul>
<li>display:none  文档布局中不再给它分配空间。</li>
<li>visibility:hidden  文档布局中仍保留原来的空间。</li>
</ul>
<h4 id="4-CSS中link-和-import的区别是？"><a href="#4-CSS中link-和-import的区别是？" class="headerlink" title="4. CSS中link 和@import的区别是？"></a>4. CSS中link 和@import的区别是？</h4><ol>
<li><p>link属于HTML标签，而@import是CSS提供的;</p>
</li>
<li><p>页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</p>
</li>
</ol>
<ol>
<li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
<li>link方式的样式的权重 高于@import的权重.</li>
</ol>
<h4 id="5-position-absolute和float属性的异同"><a href="#5-position-absolute和float属性的异同" class="headerlink" title="5. position:absolute和float属性的异同"></a>5. position:absolute和float属性的异同</h4><ul>
<li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li>
<li>不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。</li>
</ul>
<h4 id="6-介绍一下box-sizing属性？"><a href="#6-介绍一下box-sizing属性？" class="headerlink" title="6. 介绍一下box-sizing属性？"></a>6. 介绍一下box-sizing属性？</h4><ul>
<li>box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。</li>
<li>content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高</li>
<li>border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content</li>
<li>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</li>
</ul>
<h4 id="7-CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？"><a href="#7-CSS-选择符有哪些？哪些属性可以继承？优先级算法如何计算？-CSS3新增伪类有那些？" class="headerlink" title="7. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？"></a>7. CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</h4><p><strong>选择符:</strong></p>
<ol>
<li>id选择器（ # myid）</li>
<li>类选择器（.myclassname）</li>
<li>标签选择器（div, h1, p）</li>
<li>相邻选择器（h1 + p）</li>
<li>子选择器（ul &gt; li）</li>
<li>后代选择器（li a）</li>
<li>通配符选择器（ * ）</li>
<li>属性选择器（a[rel = “external”]）</li>
<li>伪类选择器（a: hover, li:nth-child）</li>
</ol>
<p><strong>优先级:</strong></p>
<ul>
<li>内联样式表 &gt; ID 选择器 &gt; Class 类选择器 &gt; HTML 标签选择器</li>
</ul>
<p><strong>CSS3新增伪类：</strong></p>
<pre><code>p:first-of-type     选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type      选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type      选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)      选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked            单选框或复选框被选中。
</code></pre><h4 id="8-CSS3有哪些新特性？"><a href="#8-CSS3有哪些新特性？" class="headerlink" title="8. CSS3有哪些新特性？"></a>8. CSS3有哪些新特性？</h4><ul>
<li><p>圆角（border-radius），阴影（box-shadow），</p>
</li>
<li><p>文字特效（text-shadow、），线性渐变（gradient），旋转（transform）</p>
</li>
<li><pre><code class="css">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
</code></pre>
</li>
<li><p>增加了更多的CSS选择器  多背景 rgba</p>
</li>
</ul>
<ul>
<li><p>媒体查询，多栏布局</p>
</li>
<li><p>盒模型：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：</p>
<p>content-box（默认）</p>
<blockquote>
<p>Width = width + padding-left + padding-right + border-left + border-right<br>Height = height + padding-top + padding-bottom + border-top + border-bottom</p>
</blockquote>
<p>padding-box</p>
<blockquote>
<p>Width = width(包含padding-left + padding-right) + border-top + border-bottom</p>
<p>Height = height(包含padding-top + padding-bottom) + border-top + border-bottom</p>
</blockquote>
<p>border-box</p>
<blockquote>
<p>Width = width(包含padding-left + padding-right + border-left + border-right)<br>Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</p>
</blockquote>
</li>
</ul>
<h4 id="9-对BFC规范的理解？"><a href="#9-对BFC规范的理解？" class="headerlink" title="9. 对BFC规范的理解？"></a>9. 对BFC规范的理解？</h4><p>BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。（W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。</p>
<h4 id="10-常见兼容性问题？"><a href="#10-常见兼容性问题？" class="headerlink" title="10. 常见兼容性问题？"></a>10. 常见兼容性问题？</h4><ul>
<li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</li>
<li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</li>
<li>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。解决方案是在float的标签样式控制中加入<code>_display:inline;</code>将其转化为行内属性。(_这个符号只有ie6会识别)</li>
<li>渐进识别的方式，从总体中逐渐排除局部。</li>
</ul>
<pre><code class="css">.bb{
  background-color:#f1ee18;/*所有识别*/
  .background-color:#00deff\9; /*IE6、7、8识别*/
  +background-color:#a200ff;/*IE6、7识别*/
  _background-color:#1e0bd1;/*IE6识别*/
}
</code></pre>
<ul>
<li>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在使用html5推荐：<code>&lt;doctype html&gt;</code></li>
<li>上下margin重合问题: ie和ff都存在，有两种情况：兄弟级的块和父子级的块，以数值大的为准。解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</li>
</ul>
<h4 id="11-解释下浮动和它的工作原理？引起的问题-清除浮动的技巧"><a href="#11-解释下浮动和它的工作原理？引起的问题-清除浮动的技巧" class="headerlink" title="11. 解释下浮动和它的工作原理？引起的问题?清除浮动的技巧"></a>11. 解释下浮动和它的工作原理？引起的问题?清除浮动的技巧</h4><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p>
<p><strong>浮动元素引起的问题：</strong></p>
<ol>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li>
<li>若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>
</ol>
<p><strong>清除浮动:</strong></p>
<ol>
<li><p>空标签清除浮动。</p>
<p>这种方法是在所有浮动标签后面添加一个空标签，定义<code>clear:both</code>. 弊端就是增加了无意义标签。</p>
</li>
<li><p>overflow。</p>
<p>给包含浮动元素的父标签添加css属性 <code>overflow:auto; zoom:1;</code> zoom:1用于兼容IE6。</p>
</li>
<li><p>after伪对象。该方法只适用于非IE浏览器。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p>
<pre><code class="css">#parent:after{
  content:&quot;.&quot;;
  height:0;
  visibility:hidden;
  display:block;
  clear:both;
}
</code></pre>
</li>
</ol>
<h4 id="12-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#12-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="12. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？"></a>12. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？</h4><p>FOUC - Flash Of Unstyled Content 文档样式闪烁</p>
<pre><code class="css">&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;
</code></pre>
<p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>
<p> 解决方法: 只要在<code>&lt;head&gt;</code>之间加入一个<code>&lt;link&gt;</code>或者<code>&lt;script&gt;</code>元素就可以了。</p>
<h4 id="13-lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签"><a href="#13-lt-strong-gt-，-lt-em-gt-和-lt-b-gt-，-lt-i-gt-标签" class="headerlink" title="13. &lt;strong&gt;，&lt;em&gt;和&lt;b&gt;，&lt;i&gt;标签"></a>13. <code>&lt;strong&gt;</code>，<code>&lt;em&gt;</code>和<code>&lt;b&gt;</code>，<code>&lt;i&gt;</code>标签</h4><p><code>&lt;strong&gt;</code> 标签和 <code>&lt;em&gt;</code> 标签一样，用于强调文本，但它强调的程度更强一些。</p>
<p>em 是 斜体强调标签，更强烈强调，表示内容的强调点。</p>
<p>&lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。</p>
<p>em 和 strong 是表达要素(phrase elements)。</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-null和undefined的区别？"><a href="#1-null和undefined的区别？" class="headerlink" title="1.null和undefined的区别？"></a>1.null和undefined的区别？</h4><p>null转为数值时为0；undefined 转为数值时为<code>NaN</code>。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="1-说说你对作用域链的理解"><a href="#1-说说你对作用域链的理解" class="headerlink" title="1. 说说你对作用域链的理解"></a>1. 说说你对作用域链的理解</h4><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的。</p>
<h4 id="2-javascript对象的几种创建方式"><a href="#2-javascript对象的几种创建方式" class="headerlink" title="2. javascript对象的几种创建方式"></a>2. javascript对象的几种创建方式</h4><ol>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>混合构造函数和原型模式</li>
<li>动态原型模式</li>
<li>寄生构造函数模式</li>
<li>稳妥构造函数模式</li>
</ol>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="1-new操作符具体干了什么呢"><a href="#1-new操作符具体干了什么呢" class="headerlink" title="1. new操作符具体干了什么呢?"></a>1. new操作符具体干了什么呢?</h4><ol>
<li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li>
<li>属性和方法被加入到 this 引用的对象中。</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li>
</ol>
<pre><code class="javascript">var o = {};
o.__proto__ = F.prototype;
F.call(o);
</code></pre>
<h4 id="2-实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#2-实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="2. 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"></a>2. 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</h4><pre><code class="javascript">Object.prototype.clone = function(){
  var o = this.constructor === Array ? [] : {};
  for(var e in this){
    o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e];
  }
  return o;
}
</code></pre>
<h3 id="继承、封装、多态"><a href="#继承、封装、多态" class="headerlink" title="继承、封装、多态"></a>继承、封装、多态</h3><h4 id="1-js继承方式及其优缺点"><a href="#1-js继承方式及其优缺点" class="headerlink" title="1. js继承方式及其优缺点"></a>1. js继承方式及其优缺点</h4><p><strong>原型链继承的缺点</strong></p>
<p>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
<p><strong>借用构造函数（类式继承）</strong></p>
<p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p>
<p><strong>组合式继承</strong></p>
<p>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<h4 id="2-javascript继承的6种方法"><a href="#2-javascript继承的6种方法" class="headerlink" title="2. javascript继承的6种方法"></a>2. javascript继承的6种方法</h4><ol>
<li>原型链继承</li>
<li>借用构造函数继承</li>
<li>组合继承(原型+借用构造)</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<h3 id="Apply-call-and-bind"><a href="#Apply-call-and-bind" class="headerlink" title="Apply, call and bind"></a>Apply, call and bind</h3><h4 id="1-call-和-apply-的区别和作用？"><a href="#1-call-和-apply-的区别和作用？" class="headerlink" title="1.call() 和 apply() 的区别和作用？"></a>1.call() 和 apply() 的区别和作用？</h4><p>作用：动态改变某个类的某个方法的运行环境（执行上下文）。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="1-说说你对闭包的理解"><a href="#1-说说你对闭包的理解" class="headerlink" title="1.说说你对闭包的理解"></a>1.说说你对闭包的理解</h4><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包有三个特性：</p>
<blockquote>
<p>1.函数嵌套函数</p>
<p>2.函数内部可以引用外部的参数和变量</p>
<p>3.参数和变量不会被垃圾回收机制回收</p>
</blockquote>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><h4 id="1-怎样添加、移除、移动、复制、创建和查找节点"><a href="#1-怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="1.怎样添加、移除、移动、复制、创建和查找节点"></a>1.怎样添加、移除、移动、复制、创建和查找节点</h4><pre><code class="javascript">//创建新节点
createDocumentFragment()    //创建一个DOM片段
createElement()   //创建一个具体的元素
createTextNode()   //创建一个文本节点

//添加、移除、替换、插入
appendChild()
removeChild()
replaceChild()
insertBefore() //并没有insertAfter()

//查找
getElementsByTagName()    //通过标签名称
getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
getElementById()    //通过元素Id，唯一性
</code></pre>
<h4 id="2-document-write-的用法"><a href="#2-document-write-的用法" class="headerlink" title="2. document.write()的用法"></a>2. document.write()的用法</h4><p><code>document.write()</code>方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。</p>
<p><code>document.write</code>只能重绘整个页面。<code>innerHTML</code>可以重绘页面的一部分</p>
<h4 id="3-attribute和property的区别是什么？"><a href="#3-attribute和property的区别是什么？" class="headerlink" title="3. attribute和property的区别是什么？"></a>3. attribute和property的区别是什么？</h4><p><code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</p>
<p><code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</p>
<p>所以：对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的，</p>
<p>但是对于自定义的属性来说，他们是不同步的，</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="1-用过哪些设计模式？"><a href="#1-用过哪些设计模式？" class="headerlink" title="1. 用过哪些设计模式？"></a>1. 用过哪些设计模式？</h4><p><strong>工厂模式</strong></p>
<p>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。</p>
<p>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。</p>
<p><strong>构造函数模式</strong></p>
<p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p>
<ol>
<li>构造函数方法没有显示的创建对象 (new Object());</li>
<li>直接将属性和方法赋值给 this 对象;</li>
<li>没有 renturn 语句。</li>
</ol>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="1-如何解决跨域问题"><a href="#1-如何解决跨域问题" class="headerlink" title="1.如何解决跨域问题"></a>1.如何解决跨域问题</h4><p><strong>JSONP</strong></p>
<p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p>
<p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p>
<p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p>
<p>JSONP：json+padding（内填充），就是把JSON填充到一个盒子里</p>
<p><strong>CORS</strong></p>
<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<p><strong>document.domain跨子域</strong></p>
<p>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域</p>
<p>主域相同的使用<code>document.domain</code></p>
<p><strong>window.name</strong></p>
<p><code>window</code>对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对<code>window.name</code>都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</p>
<p>H5中<code>window.postMessage</code></p>
<p>还有flash、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="1-请你谈谈Cookie的弊端"><a href="#1-请你谈谈Cookie的弊端" class="headerlink" title="1. 请你谈谈Cookie的弊端"></a>1. 请你谈谈Cookie的弊端</h4><p><code>cookie</code>虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p>
<p>第一：每个特定的域名下最多生成20个<code>cookie</code></p>
<ol>
<li>IE6或更低版本最多20个cookie</li>
<li>IE7和之后的版本最后可以有50个cookie。</li>
<li>Firefox最多50个cookie</li>
<li>chrome和Safari没有做硬性限制</li>
</ol>
<p><code>IE</code>和<code>Opera</code> 会清理近期最少使用的<code>cookie</code>，<code>Firefox</code>会随机清理<code>cookie</code>。</p>
<p><code>cookie</code>的最大大约为<code>4096</code>字节，为了兼容性，一般不能超过<code>4095</code>字节。</p>
<p>IE 提供了一种存储可以持久化用户数据，叫做<code>userdata</code>，从<code>IE5.0</code>就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</p>
<blockquote>
<p>优点：极高的扩展性和可用性</p>
</blockquote>
<pre><code>1.通过良好的编程，控制保存在cookie中的session对象的大小。

2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。

3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。

4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。
</code></pre><blockquote>
<p>缺点：</p>
</blockquote>
<pre><code>1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.


2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</code></pre><h4 id="2-如何删除一个cookie"><a href="#2-如何删除一个cookie" class="headerlink" title="2. 如何删除一个cookie"></a>2. 如何删除一个cookie</h4><ol>
<li><p>将时间设为当前时间往前一点。</p>
<pre><code class="javascript">var date = new Date();
date.setDate(date.getDate() - 1);//真正的删除
</code></pre>
</li>
<li><p>expires的设置</p>
<pre><code class="javascript">document.cookie = &#39;user=&#39;+ encodeURIComponent(&#39;name&#39;)  + &#39;;expires = &#39; + new Date(0)
</code></pre>
<p>​</p>
</li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="1-对前端模块化的认识"><a href="#1-对前端模块化的认识" class="headerlink" title="1.对前端模块化的认识"></a>1.对前端模块化的认识</h4><p>AMD 是 <code>RequireJS</code> 在推广过程中对模块定义的规范化产出。</p>
<p>CMD 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p>
<p><code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<p><strong>CMD模块方式</strong></p>
<pre><code class="javascript">define(function(require, exports, module) {
    // 模块代码
});
</code></pre>
<h4 id="2-说说你对AMD和Commonjs的理解"><a href="#2-说说你对AMD和Commonjs的理解" class="headerlink" title="2. 说说你对AMD和Commonjs的理解"></a>2. 说说你对AMD和Commonjs的理解</h4><p><code>CommonJS</code>是服务器端模块的规范，<a href="http://lib.csdn.net/base/nodejs" target="_blank" rel="external">Node.js</a>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。</p>
<p><code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="1-浏览器本地存储"><a href="#1-浏览器本地存储" class="headerlink" title="1.浏览器本地存储"></a>1.浏览器本地存储</h4><p>在较高版本的浏览器中，<code>js</code>提供了<code>sessionStorage</code>和<code>globalStorage</code>。在<code>HTML5</code>中提供了<code>localStorage</code>来取代<code>globalStorage</code>。</p>
<p><code>html5</code>中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage</code>和<code>localStorage</code>。</p>
<p><code>sessionStorage</code>用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<h4 id="2-cookie-和session-的区别"><a href="#2-cookie-和session-的区别" class="headerlink" title="2. cookie 和session 的区别"></a>2. cookie 和session 的区别</h4><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<p> 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p>
<pre><code>考虑到安全应当使用session。
</code></pre><p> 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</p>
<pre><code> 考虑到减轻服务器性能方面，应当使用COOKIE。
</code></pre><p> 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p> 5、所以个人建议：</p>
<pre><code>将登陆信息等重要信息存放为SESSION
</code></pre><pre><code>其他信息如果需要保留，可以放在COOKIE中
</code></pre><h4 id="3-什么是Etag？"><a href="#3-什么是Etag？" class="headerlink" title="3.什么是Etag？"></a>3.什么是Etag？</h4><p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</p>
<p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 <code>200 OK</code>(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p>
<p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和<code>Etag</code></p>
<p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据<code>Etag</code>，判断文件内容自上一次请求之后，有没有发生变化</p>
<p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发<code>index.html</code>的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— <code>304 Not Modified</code>，此时浏览器就会从本地缓存中获取<code>index.html</code>的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</p>
<p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同①</p>
<p>① 只有get请求会被缓存，post请求不会</p>
<h4 id="5-Expires和Cache-Control"><a href="#5-Expires和Cache-Control" class="headerlink" title="5. Expires和Cache-Control"></a>5. Expires和Cache-Control</h4><p><code>Expires</code>要求客户端和服务端的时钟严格同步。<code>HTTP1.1</code>引入<code>Cache-Control</code>来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p>
<h4 id="6-ETag应用"><a href="#6-ETag应用" class="headerlink" title="6. ETag应用:"></a>6. ETag应用:</h4><p><code>Etag</code>由服务器端生成，客户端通过<code>If-Match</code>或者说<code>If-None-Match</code>这个条件判断请求来验证资源是否修改。常见的是使用<code>If-None-Match</code>。请求一个文件的流程可能如下：</p>
<p>====第一次请求===</p>
<pre><code>1.客户端发起 HTTP GET 请求一个文件；

2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200
</code></pre><p>====第二次请求===</p>
<pre><code>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办
</code></pre><p>答案是同时使用，也就是说在完全匹配<code>If-Modified-Since</code>和<code>If-None-Match</code>即检查完修改时间和<code>Etag</code>之后，</p>
<p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p>
<p>为什么使用Etag请求头?</p>
<p>Etag 主要为了解决 <code>Last-Modified</code> 无法解决的一些问题。</p>
<h4 id="7-讲讲304缓存的原理"><a href="#7-讲讲304缓存的原理" class="headerlink" title="7. 讲讲304缓存的原理"></a>7. 讲讲304缓存的原理</h4><p>服务器首先产生<code>ETag</code>，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>
<p>客户端请求一个页面（A）。 服务器返回页面A，并在给<code>A</code>加上一个<code>ETag</code>。 客户端展现该页面，并将页面连同<code>ETag</code>一起缓存。 客户再次请求页面<code>A</code>，并将上次请求时服务器返回的<code>ETag</code>一起传递给服务器。 服务器检查该<code>ETag</code>，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应<code>304</code>（未修改——<code>Not Modified</code>）和一个空的响应体。</p>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><h4 id="1-事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#1-事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="1. 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>1. 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><pre><code>1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。

2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；

3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`;
</code></pre><h4 id="2-请解释什么是事件代理"><a href="#2-请解释什么是事件代理" class="headerlink" title="2. 请解释什么是事件代理"></a>2. 请解释什么是事件代理</h4><p>事件代理（Event Delegation），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是<code>DOM</code>元素的事件冒泡。使用事件代理的好处是可以提高性能。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="1-Javascript垃圾回收方法"><a href="#1-Javascript垃圾回收方法" class="headerlink" title="1. Javascript垃圾回收方法"></a>1. Javascript垃圾回收方法</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p>
<p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p>
<p>在IE中虽然<code>JavaScript</code>对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及<code>BOM</code>及DOM就会出现循环引用问题。</p>
<h4 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h4><ul>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
</ul>
<h3 id="异步装载回调"><a href="#异步装载回调" class="headerlink" title="异步装载回调"></a>异步装载回调</h3><h4 id="1-js延迟加载的方式有哪些？"><a href="#1-js延迟加载的方式有哪些？" class="headerlink" title="1. js延迟加载的方式有哪些？"></a>1. js延迟加载的方式有哪些？</h4><p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p>
<h4 id="2-异步加载的方式"><a href="#2-异步加载的方式" class="headerlink" title="2. 异步加载的方式"></a>2. 异步加载的方式</h4><ol>
<li>动态插入script标签</li>
<li>通过ajax去获取js代码，然后通过eval执行</li>
<li>script标签上添加defer或者async属性</li>
<li>创建并插入iframe，让它异步执行js</li>
</ol>
<h4 id="3-说说你对Promise的理解"><a href="#3-说说你对Promise的理解" class="headerlink" title="3. 说说你对Promise的理解"></a>3. 说说你对Promise的理解</h4><p>依照 Promise/A+ 的定义，Promise 有四种状态：</p>
<ul>
<li>pending: 初始状态, 非 fulfilled 或 rejected.</li>
<li>fulfilled: 成功的操作.</li>
<li>rejected: 失败的操作.</li>
<li>settled: Promise已被fulfilled或rejected，且不是pending</li>
</ul>
<p>另外， fulfilled 与 rejected 一起合称 settled。</p>
<p>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p>
<h4 id="4-Promise-的构造函数"><a href="#4-Promise-的构造函数" class="headerlink" title="4. Promise 的构造函数"></a>4. Promise 的构造函数</h4><p>构造一个 <code>Promise</code>，最基本的用法如下：</p>
<pre><code class="javascript">var promise = new Promise(function(resolve, reject) {
        if (...) {  // succeed
            resolve(result);
        } else {   // fails
            reject(Error(errMessage));
        }
    });
</code></pre>
<p><code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为 <code>thenable</code>）。它的使用方法如下：</p>
<pre><code class="javascript">promise.then(onFulfilled, onRejected)
</code></pre>
<p>接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在 <code>rejected</code> 的时候被调用，接收参数就是 <code>future，onFulfilled</code>对应 <code>resolve</code>, <code>onRejected</code> 对应 <code>reject</code>。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="1-创建ajax过程"><a href="#1-创建ajax过程" class="headerlink" title="1. 创建ajax过程"></a>1. 创建ajax过程</h4><ol>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新.</li>
</ol>
<pre><code class="javascript">var xmlHttp = new XMLHttpRequest();
xmlHttp.open(&#39;GET&#39;,&#39;demo.php&#39;,&#39;true&#39;);
xmlHttp.send()

xmlHttp.onreadystatechange = function(){
  if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200){...}
}
</code></pre>
<h4 id="2-GET和POST的区别"><a href="#2-GET和POST的区别" class="headerlink" title="2.GET和POST的区别"></a>2.GET和POST的区别</h4><p> GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>
<p>请使用 POST 请求的情况：</p>
<ul>
<li>无法使用缓存文件（更新服务器上的文件或数据库）</li>
<li>向服务器发送大量数据（POST 没有数据量限制）</li>
<li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li>
</ul>
<h4 id="3-ajax的缺点和在IE下的问题？"><a href="#3-ajax的缺点和在IE下的问题？" class="headerlink" title="3. ajax的缺点和在IE下的问题？"></a>3. ajax的缺点和在IE下的问题？</h4><ol>
<li>ajax不支持浏览器back按钮。</li>
<li>安全问题 AJAX暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>破坏了程序的异常机制。</li>
<li>不容易调试。</li>
</ol>
<h4 id="4-Ajax请求的页面历史记录状态问题"><a href="#4-Ajax请求的页面历史记录状态问题" class="headerlink" title="4. Ajax请求的页面历史记录状态问题"></a>4. Ajax请求的页面历史记录状态问题</h4><p>可以通过锚点来记录状态，<code>location.hash</code>。让浏览器记录Ajax请求时页面状态的变化。</p>
<p>还可以通过<code>HTML5</code>的<code>history.pushState</code>，来实现浏览器地址栏的无刷新改变</p>
<h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><h4 id="1-你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#1-你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="1. 你觉得jQuery或zepto源码有哪些写的好的地方"></a>1. 你觉得jQuery或zepto源码有哪些写的好的地方</h4><p><code>jQuery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当<code>jquery</code>中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问<code>window</code>对象。同样，传入<code>undefined</code>参数，可以缩短查找undefined时的作用域链。</p>
<pre><code class="javascript">    (function( window, undefined ) {

         //用一个函数域包起来，就是所谓的沙箱

         //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局

         //把当前沙箱需要的外部变量通过函数参数引入进来

         //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数

        window.jQuery = window.$ = jQuery;

    })( window );
</code></pre>
<p>jquery将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法。</p>
<p>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。</p>
<p><code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h4 id="1-XML和JSON的区别？"><a href="#1-XML和JSON的区别？" class="headerlink" title="1. XML和JSON的区别？"></a>1. XML和JSON的区别？</h4><ul>
<li><p>数据体积方面。</p>
<p>JSON相对于XML来讲，数据的体积小，传递的速度更快些。</p>
</li>
</ul>
<ul>
<li><p>数据交互方面。</p>
<p>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</p>
</li>
</ul>
<ul>
<li><p>数据描述方面。</p>
<p>JSON对数据的描述性比XML较差。</p>
</li>
<li><p>传输速度方面。</p>
<p>JSON的速度要远远快于XML。</p>
</li>
</ul>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="1-webpack的看法"><a href="#1-webpack的看法" class="headerlink" title="1.webpack的看法"></a>1.webpack的看法</h4><p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、JavaScript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p>
<h4 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h4><ol>
<li>code splitting（可以自动完成）</li>
<li>loader 可以处理各种类型的静态文件，并且支持串联操作</li>
</ol>
<p>webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</p>
<p>webpack具有requireJs和browserify的功能，但仍有很多自己的<strong>新特性</strong>：</p>
<ol>
<li>对 CommonJS 、 AMD 、ES6的语法做了兼容</li>
<li>对js、css、图片等资源文件都支持打包</li>
<li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li>
<li>有独立的配置文件webpack.config.js</li>
<li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li>
<li>支持 SourceUrls 和 SourceMaps，易于调试</li>
<li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</li>
<li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li>
</ol>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><h4 id="1-ES6的了解"><a href="#1-ES6的了解" class="headerlink" title="1. ES6的了解"></a>1. ES6的了解</h4><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值<code>Inputs=&gt;outputs</code>。）、<code>for-of</code>（用来遍历数据—例如数组中的值。）<code>arguments</code>对象可被不定参数和默认参数完美代替。<code>ES6</code>将<code>promise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。增加了<code>let</code>和<code>const</code>命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，属于全局对象的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于全局对象的属性。。还有就是引入<code>module</code>模块的概念</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="13-谈谈性能优化问题"><a href="#13-谈谈性能优化问题" class="headerlink" title="13. 谈谈性能优化问题"></a>13. 谈谈性能优化问题</h4><ul>
<li>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。</li>
<li>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</li>
<li>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</li>
<li>请求带宽：压缩文件，开启GZIP，</li>
</ul>
<p><strong>代码层面的优化</strong></p>
<ul>
<li>用<code>hash-table</code>来优化查找</li>
<li>少用全局变量</li>
<li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li>
<li>用<code>setTimeout</code>来避免页面失去响应</li>
<li>缓存DOM节点查找的结果</li>
<li>避免使用CSS Expression</li>
<li>避免全局查询</li>
<li>避免使用with(with会创建自己的作用域，会增加作用域链长度)</li>
<li>多个变量声明合并</li>
<li>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</li>
<li>尽量避免写在HTML标签中写Style属性</li>
</ul>
<p><strong>移动端性能优化</strong></p>
<ul>
<li>尽量使用css3动画，开启硬件加速。</li>
<li>适当使用<code>touch</code>事件代替<code>click</code>事件。</li>
<li>避免使用<code>css3</code>渐变阴影效果。</li>
<li>可以用<code>transform: translateZ(0)</code>来开启硬件加速。</li>
<li>不滥用Float。Float在渲染时计算量比较大，尽量减少使用</li>
<li>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</li>
<li>合理使用requestAnimationFrame动画代替setTimeout</li>
<li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</li>
<li>PC端的在移动端同样适用</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><h4 id="1-渐进增强和优雅降级"><a href="#1-渐进增强和优雅降级" class="headerlink" title="1. 渐进增强和优雅降级"></a>1. 渐进增强和优雅降级</h4><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<h4 id="2-你觉得前端工程的价值体现在哪"><a href="#2-你觉得前端工程的价值体现在哪" class="headerlink" title="2. 你觉得前端工程的价值体现在哪"></a>2. 你觉得前端工程的价值体现在哪</h4><ul>
<li>为简化用户使用提供技术支持（交互部分）</li>
<li>为多个浏览器兼容性提供支持</li>
<li>为提高用户浏览速度（浏览器性能）提供支持</li>
<li>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</li>
<li>为展示数据提供支持（数据接口）</li>
</ul>
<h4 id="3-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#3-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="3.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>3.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h4><ol>
<li>浏览器开线程+远程DNS服务器DNS查询。这能使浏览器获得请求对应的IP地址。</li>
<li>三次握手协商来建立一个<code>TCP/IP</code>连接。</li>
<li>发送<code>HTTP</code>的<code>GET</code>请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</li>
<li>客户端开始下载资源。浏览器会解析<code>HTML</code>生成<code>DOM Tree</code>，其次会根据CSS生成CSS Rule Tree，而<code>javascript</code>又可以根据<code>DOM API</code>操作<code>DOM</code></li>
</ol>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="1-TCP传输的三次握手四次挥手策略"><a href="#1-TCP传输的三次握手四次挥手策略" class="headerlink" title="1. TCP传输的三次握手四次挥手策略"></a>1. TCP传输的三次握手四次挥手策略</h4><p>“三次握手”</p>
<ul>
<li>发送端首先发送一个带<code>SYN</code>标志的数据包给对方。</li>
<li>接收端收到后，回传一个带有<code>SYN/ACK</code>标志的数据包以示传达确认信息。 </li>
<li>最后，发送端再回传一个带<code>ACK</code>标志的数据包，代表“握手”结束。 </li>
</ul>
<p>若在握手过程中某个阶段莫名中断，<code>TCP</code>协议会再次以相同的顺序发送相同的数据包。</p>
<p>“四次握手”</p>
<ul>
<li>第一次挥手：主动关闭方发送一个<code>FIN</code>，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li>
<li>第二次挥手：被动关闭方收到<code>FIN</code>包后，发送一个<code>ACK</code>给对方，确认序号为收到序号<code>+1</code>（与<code>SYN</code>相同，一个<code>FIN</code>占用一个序号）。</li>
<li>第三次挥手：被动关闭方发送一个<code>FIN</code>，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，<strong>我的数据也发送完了</strong>，不会再给你发数据了。</li>
<li>第四次挥手：主动关闭方收到<code>FIN</code>后，发送一个<code>ACK</code>给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li>
</ul>
<h4 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h4><p><code>TCP</code>（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个<code>TCP</code>连接必须要经过三次“对话”才能建立起来</p>
<p><code>UDP</code>（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h4 id="3-HTTP和HTTPS"><a href="#3-HTTP和HTTPS" class="headerlink" title="3. HTTP和HTTPS"></a>3. HTTP和HTTPS</h4><p><code>HTTP</code>协议通常承载于TCP协议之上，在<code>HTTP</code>和<code>TCP</code>之间添加一个安全协议层（<code>SSL</code>或<code>TSL</code>），这个时候，就成了我们常说的HTTPS。</p>
<p>默认HTTP的端口号为80，<code>HTTPS</code>的端口号为443。</p>
<h4 id="4-为什么HTTPS安全"><a href="#4-为什么HTTPS安全" class="headerlink" title="4. 为什么HTTPS安全"></a>4. 为什么<code>HTTPS</code>安全</h4><p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用<code>HTTPS</code>，密钥在你和终点站才有。<code>https</code>之所以比<code>http</code>安全，是因为他利用<code>ssl/tls</code>协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p>
<h4 id="5-关于Http-2-0-你知道多少？"><a href="#5-关于Http-2-0-你知道多少？" class="headerlink" title="5. 关于Http 2.0 你知道多少？"></a>5. 关于Http 2.0 你知道多少？</h4><p><code>HTTP/2</code>引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p>
<p><code>HTTP/2</code>提供更多的加密支持</p>
<p><code>HTTP/2</code>使用多路技术，允许多个消息在一个连接上同时交差。</p>
<p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的<code>header</code>都只会占用很小比例的带宽。</p>
<h4 id="6-HTTP状态码"><a href="#6-HTTP状态码" class="headerlink" title="6. HTTP状态码"></a>6. HTTP状态码</h4><ul>
<li>200  OK   正常返回信息</li>
<li>201  Created  请求成功并且服务器创建了新的资源</li>
<li>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li>401 Unauthorized  请求未授权。</li>
<li>403 Forbidden  禁止访问。</li>
<li>404 Not Found  找不到如何与 URI 相匹配的资源。</li>
<li>500 Internal Server Error  最常见的服务器端错误。</li>
</ul>
<h4 id="7-说说网络分层里七层模型是哪七层"><a href="#7-说说网络分层里七层模型是哪七层" class="headerlink" title="7. 说说网络分层里七层模型是哪七层"></a>7. 说说网络分层里七层模型是哪七层</h4><ul>
<li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li>
<li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li>
<li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li>
<li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li>
<li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li>
<li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li>
<li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li>
</ul>
<h3 id="WEB安全"><a href="#WEB安全" class="headerlink" title="WEB安全"></a>WEB安全</h3><h4 id="1-常见web安全及防护原理"><a href="#1-常见web安全及防护原理" class="headerlink" title="1. 常见web安全及防护原理"></a>1. 常见web安全及防护原理</h4><h5 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h5><p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>总的来说有以下几点：</p>
<ol>
<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</li>
</ol>
<h5 id="XSS原理及防范"><a href="#XSS原理及防范" class="headerlink" title="XSS原理及防范"></a>XSS原理及防范</h5><p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，</p>
<p>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>
<h5 id="XSS防范方法"><a href="#XSS防范方法" class="headerlink" title="XSS防范方法"></a>XSS防范方法</h5><p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以<code>encode</code>，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的<code>XSS</code> 攻击。</p>
<p>首先，避免直接在<code>cookie</code> 中泄露用户隐私，例如email、密码等等。</p>
<p>其次，通过使<code>cookie</code> 和系统<code>ip</code> 绑定来降低<code>cookie</code> 泄露后的危险。这样攻击者得到的<code>cookie</code> 没有实际价值，不可能拿来重放。</p>
<p>如果网站不需要再浏览器端对<code>cookie</code> 进行操作，可以在<code>Set-Cookie</code> 末尾加上<code>HttpOnly</code> 来防止<code>javascript</code> 代码直接获取<code>cookie</code> 。</p>
<p>尽量采用<code>POST</code> 而非<code>GET</code> 提交表单</p>
<h5 id="XSS与CSRF有什么区别吗？"><a href="#XSS与CSRF有什么区别吗？" class="headerlink" title="XSS与CSRF有什么区别吗？"></a>XSS与CSRF有什么区别吗？</h5><p><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。</p>
<p>要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤：</p>
<p>登录受信任网站A，并在本地生成Cookie。</p>
<p>在不登出A的情况下，访问危险网站B。</p>
<h5 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h5><ul>
<li>服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</li>
<li>通过验证码的方法</li>
</ul>
<p>####2.请解释一下 JavaScript 的同源策略。</p>
<p>同源策略指的是：协议，域名，端口相同，指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><h4 id="1-谈谈你对重构的理解"><a href="#1-谈谈你对重构的理解" class="headerlink" title="1. 谈谈你对重构的理解"></a>1. 谈谈你对重构的理解</h4><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化， 在扩展的同时保持一致的UI。</p>
<p>对于传统的网站来说重构通常是：</p>
<ul>
<li>表格(table)布局改为DIV+CSS</li>
<li>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</li>
<li>对于移动平台的优化</li>
<li>针对于SEO进行优化</li>
</ul>
<p>深层次的网站重构应该考虑的方面</p>
<ul>
<li>减少代码间的耦合</li>
<li>让代码保持弹性</li>
<li>严格按规范编写代码</li>
<li>设计可扩展的API</li>
<li>代替旧有的框架、语言(如VB)</li>
<li>增强用户体验</li>
<li>通常来说对于速度的优化也包含在重构中</li>
<li>压缩JS、CSS、image等前端资源(通常是由服务器来解决)</li>
<li>程序的性能优化(如数据读写)</li>
<li>采用CDN来加速资源加载</li>
<li>对于JS DOM的优化</li>
<li>HTTP服务器的文件缓存</li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="1-如何评价AngularJS和BackboneJS"><a href="#1-如何评价AngularJS和BackboneJS" class="headerlink" title="1. 如何评价AngularJS和BackboneJS"></a>1. 如何评价AngularJS和BackboneJS</h4><p><code>backbone</code>具有依赖性，依赖<code>underscore.js</code>。<code>Backbone + Underscore + jQuery(or Zepto)</code> 就比一个<code>AngularJS</code> 多出了2 次HTTP请求.</p>
<p><code>Backbone</code>的<code>Model</code>没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。<code>AngularJS</code>与此相反，Model直接与UI视图绑定，<code>Model</code>与UI视图的关系，通过<code>directive</code>封装，<code>AngularJS</code>内置的通用<code>directive</code>，就能实现大部分操作了，也就是说，基本不必关心<code>Model</code>与UI视图的关系，直接操作Model就行了，UI视图自动更新。</p>
<p><code>AngularJS</code>的<code>directive</code>，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。</p>
<h4 id="2-说说你对MVC和MVVM的理解"><a href="#2-说说你对MVC和MVVM的理解" class="headerlink" title="2. 说说你对MVC和MVVM的理解"></a>2. 说说你对MVC和MVVM的理解</h4><p><strong>MVC</strong>：所有通信都是单向的。</p>
<ul>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
</ul>
<p><strong>MVVM</strong></p>
<ul>
<li>View：UI界面</li>
<li>ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；</li>
<li>Model：数据访问层</li>
</ul>
<p>关于MVVM的优点：</p>
<ul>
<li>方便测试</li>
<li>便于代码的移植</li>
<li>兼容MVC</li>
</ul>
<p>缺点：</p>
<ul>
<li>类会增多</li>
<li>viewModel会越来越庞大</li>
<li>调用复杂度增加</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="1-说说mongoDB和MySQL的区别"><a href="#1-说说mongoDB和MySQL的区别" class="headerlink" title="1. 说说mongoDB和MySQL的区别"></a>1. 说说mongoDB和MySQL的区别</h4><p><code>MySQL</code>是传统的关系型<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>，<code>MongoDB</code>则是非关系型数据库</p>
<p><code>mongodb</code>以<code>BSON</code>结构（二进制）进行存储，对海量数据存储有着很明显的优势。</p>
<ul>
<li>弱一致性（最终一致），更能保证用户的访问速度： </li>
<li>文档结构的存储方式，能够更便捷的获取数据。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍闭包</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p><strong>解释1</strong></p>
<p><strong>闭包</strong>是有权限访问其他函数作用域内的变量的一个函数。——《JavaScript高级程序设计》</p>
<p>这句话几个深入的问题：</p>
<ul>
<li>为什么其他非闭包的函数没有权限访问另一个函数的内部作用域</li>
<li>为什么闭包有这个权限</li>
<li>什么是函数作用域</li>
</ul>
<p>全面的回答：</p>
<p>由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>
<p><strong>解释2</strong></p>
<ul>
<li><p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</p>
</li>
<li><p>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</p>
</li>
<li>当在一个函数内定义另外一个函数就会产生闭包</li>
</ul>
<p><strong>解释3</strong></p>
<p>官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p><strong>解释4</strong></p>
<p><strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong></p>
<h2 id="闭包解决了什么"><a href="#闭包解决了什么" class="headerlink" title="闭包解决了什么"></a>闭包解决了什么</h2><p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。——阮一峰的博客《学习Javascript闭包》</p>
<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>
<p>总结：</p>
<ul>
<li>使用闭包可以访问函数中的变量。</li>
<li>可以使变量长期保存在内存中，生命周期比较长。</li>
</ul>
<h2 id="闭包有哪些应用场景"><a href="#闭包有哪些应用场景" class="headerlink" title="闭包有哪些应用场景"></a>闭包有哪些应用场景</h2><h3 id="Ans1"><a href="#Ans1" class="headerlink" title="Ans1"></a>Ans1</h3><p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>
<h3 id="Ans2"><a href="#Ans2" class="headerlink" title="Ans2"></a>Ans2</h3><p>比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。</p>
<h4 id="1-匿名自执行函数"><a href="#1-匿名自执行函数" class="headerlink" title="1.匿名自执行函数"></a>1.匿名自执行函数</h4><pre><code class="javascript">(function( window, undefined ) {
    // code
})(window);
</code></pre>
<p><strong>为何要传入window？</strong></p>
<p>这样传入window可将其从全局变量变为局部变量，在函数作用域内可以直接访问到window，就不用将作用域链退回到顶层作用域了。</p>
<p>在压缩代码时，可以对window进行优化。</p>
<p><strong>增加参数undefined？</strong></p>
<p>由于undefined在一些情况下有可能会被重写，为确保在自执行匿名函数里的undefined是”真的undefined”，就需要增加参数undefined。</p>
<h4 id="2-结果缓存"><a href="#2-结果缓存" class="headerlink" title="2.结果缓存"></a>2.结果缓存</h4><p>需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。</p>
<pre><code class="javascript">var CachedSearchBox = (function(){    
    var cache = {},    
       count = [];    
    return {    
       attachSearchBox : function(dsid){    
           if(dsid in cache){//如果结果在缓存中    
              return cache[dsid];//直接返回缓存中的对象    
           }    
           var fsb = new uikit.webctrl.SearchBox(dsid);//新建    
           cache[dsid] = fsb;//更新缓存    
           if(count.length &gt; 100){//保正缓存的大小&lt;=100    
              delete cache[count.shift()];    
           }    
           return fsb;          
       },    

       clearSearchBox : function(dsid){    
           if(dsid in cache){    
              cache[dsid].clearSelection();      
           }    
       }    
    };    
})();    

CachedSearchBox.attachSearchBox(&quot;input&quot;);
</code></pre>
<h4 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h4><pre><code class="javascript">var person = function(){    
    //变量作用域为函数内部，外部无法访问    
    var name = &quot;default&quot;;       

    return {    
       getName : function(){    
           return name;    
       },    
       setName : function(newName){    
           name = newName;    
       }    
    }    
}();    

print(person.name);//直接访问，结果为undefined    
print(person.getName());    
person.setName(&quot;abruzzi&quot;);    
print(person.getName());    

得到结果如下：  

undefined  
default  
abruzzi
</code></pre>
<h4 id="4-实现类和继承"><a href="#4-实现类和继承" class="headerlink" title="4.实现类和继承"></a>4.实现类和继承</h4><pre><code class="javascript">function Person(){    
    var name = &quot;default&quot;;       

    return {    
       getName : function(){    
           return name;    
       },    
       setName : function(newName){    
           name = newName;    
       }    
    }    
};   

var p = new Person();
p.setName(&quot;Tom&quot;);
alert(p.getName());

var Jack = function(){};
//继承自Person
Jack.prototype = new Person();
//添加私有方法
Jack.prototype.Say = function(){
    alert(&quot;Hello,my name is Jack&quot;);
};
var j = new Jack();
j.setName(&quot;Jack&quot;);
j.Say();
alert(j.getName());
</code></pre>
<h3 id="Ans3"><a href="#Ans3" class="headerlink" title="Ans3"></a>Ans3</h3><p><strong>Singleton 单件：</strong></p>
<pre><code class="javascript">var singleton = function () {
    var privateVariable;
    function privateFunction(x) {
        ...privateVariable...
    }

    return {
        firstMethod: function (a, b) {
            ...privateVariable...
        },
        secondMethod: function (c) {
            ...privateFunction()...
        }
    };
}();
</code></pre>
<p>这个单件通过闭包来实现。通过闭包完成了私有的成员和方法的封装。匿名主函数返回一个对象。对象包含了两个方法，方法1可以方法私有变量，方法2访问内部私有函数。需要注意的地方是匿名主函数结束的地方的’()’，如果没有这个’()’就不能产生单件。因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用。这个就是利用闭包产生单件的方法。</p>
<h2 id="闭包有哪些问题"><a href="#闭包有哪些问题" class="headerlink" title="闭包有哪些问题"></a>闭包有哪些问题</h2><p><strong>原理比较深奥：</strong>要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承等，然而闭包是随处可见的，很可能开发者在不经意间就写出了一个闭包，理解不够深入的话很可能造成运行结果与预期不符。</p>
<p><strong>代码难以维护：</strong>闭包内部是可以缓存上级作用域，而如果闭包又是异步执行的话，一定要清楚上级作用域都发生了什么，而这样就需要对代码的运行逻辑和JS运行机制相当了解才能弄明白究竟发生了什么。</p>
<p><strong>内存泄露</strong>：闭包使用完了后，要立即释放资源，将引用变量指向null。</p>
<p>注：闭包并不会引起内存泄漏，只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，从而导致内存无法进行回收，这是IE的问题。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
</code></pre>
<p>闭包是functional language里面的核心概念。</p>
<p>当出现高阶嵌套函数的时候，编译器会做<code>closure convention闭包变换</code>，核心就是变量不在分配在stack上，而是分配在heap上。</p>
<p>高阶嵌套函数：</p>
<ul>
<li>函数里面有定义的函数，这是嵌套</li>
<li>高阶的原因是，函数可以所谓参数传递和返回，像我们熟悉的C语言。</li>
</ul>
<p>最后一点，n在堆上如何被销毁，这个工作是垃圾收集器负责。当n不在被任何闭包的env引用的时候，会被回收。</p>
<h3 id="ECMAScript闭包模型"><a href="#ECMAScript闭包模型" class="headerlink" title="ECMAScript闭包模型"></a>ECMAScript闭包模型</h3><p>在ECMAscript的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分</p>
<ul>
<li>文法环境（The LexicalEnvironment）</li>
<li>变量环境（The VariableEnvironment）</li>
<li>this绑定</li>
</ul>
<p>文法环境中用于解析函数执行过程使用到的变量标识符。我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。</p>
<p><img src="https://coolshell.cn//wp-content/uploads/2012/03/closure.png" alt=""></p>
<p>变量环境(The VariableEnvironment)和文法环境的作用基本相似，具体的区别请参看ECMAScript的规范文档。</p>
<h3 id="闭包的几种写法和用法"><a href="#闭包的几种写法和用法" class="headerlink" title="闭包的几种写法和用法"></a>闭包的几种写法和用法</h3><pre><code class="javascript">//第1种写法  
//只是给函数添加一些属性
function Circle(r) {  
      this.r = r;  
}  
Circle.PI = 3.14159;  
Circle.prototype.area = function() {  
  return Circle.PI * this.r * this.r;  
}  

var c = new Circle(1.0);     
alert(c.area()); 


//第2种写法
//声明一个变量，将一个函数当作值赋给变量。常用
var Circle = function() {  
   var obj = new Object();  
   obj.PI = 3.14159;  

   obj.area = function( r ) {  
       return this.PI * r * r;  
   }  
   return obj;  
}  

var c = new Circle();  
alert( c.area( 1.0 ) );  


//第3种写法  
//new 一个对象，然后给对象添加属性和方法。
var Circle = new Object();  
Circle.PI = 3.14159;  
Circle.Area = function( r ) {  
       return this.PI * r * r;  
}  

alert( Circle.Area( 1.0 ) );  


//第4种写法  
//这种方法使用较多，也最为方便。var obj = {}就是声明一个空的对象。
var Circle={  
   &quot;PI&quot;:3.14159,  
     &quot;area&quot;:function(r){  
      return this.PI * r * r;  
    }  
};  
alert( Circle.area(1.0) );  


//第5种写法  
var Circle = new Function(&quot;this.PI = 3.14159;this.area = function( r ) {return r*r*this.PI;}&quot;);  

alert( (new Circle()).area(1.0) );
</code></pre>
<p>关于Prototype：</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var dom = function(){

};

dom.Show = function(){
  alert(&quot;Show Message&quot;);
};

dom.prototype.Display = function(){
  alert(&quot;Property Message&quot;);
};

dom.Display(); //error
dom.Show();  
var d = new dom();s
d.Display();
d.Show(); //error
</code></pre>
<p><strong>1、不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！</strong><br><strong>2、使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var html = {
        Name:&#39;Object&#39;,
        Success:function(){
            this.Say = function(){
                    alert(&quot;Hello,world&quot;);
            };
            alert(&quot;Obj Success&quot;);
        }
    };
</code></pre>
<p>怎么访问Success方法中的Say方法:</p>
<pre><code class="javascript">var s = new html.Success();
s.Say();

//还可以写到外面
html.Success.prototype.Show = function(){
    alert(&quot;HaHa&quot;);
};
var s = new html.Success();
s.Show();
</code></pre>
<h3 id="闭包的样列"><a href="#闭包的样列" class="headerlink" title="闭包的样列"></a>闭包的样列</h3><h4 id="1-闭包中局部变量是引用而非拷贝"><a href="#1-闭包中局部变量是引用而非拷贝" class="headerlink" title="1. 闭包中局部变量是引用而非拷贝"></a>1. 闭包中局部变量是引用而非拷贝</h4><h4 id="2-多个函数绑定同一个闭包，因为他们定义在同一个函数内。"><a href="#2-多个函数绑定同一个闭包，因为他们定义在同一个函数内。" class="headerlink" title="2.多个函数绑定同一个闭包，因为他们定义在同一个函数内。"></a>2.多个函数绑定同一个闭包，因为他们定义在同一个函数内。</h4><pre><code class="javascript">function setupSomeGlobals() {
    // Local variable that ends up within closure
    var num = 666;
    // Store some references to functions as global variables
    gAlertNumber = function() { alert(num); }
    gIncreaseNumber = function() { num++; }
    gSetNumber = function(x) { num = x; }
}
setupSomeGlobals(); // 为三个全局变量赋值
gAlertNumber(); //666
gIncreaseNumber();
gAlertNumber(); // 667
gSetNumber(12);//
gAlertNumber();//12
</code></pre>
<h4 id="3-当在一个循环中赋值函数时，这些函数将绑定同样的闭包"><a href="#3-当在一个循环中赋值函数时，这些函数将绑定同样的闭包" class="headerlink" title="3.当在一个循环中赋值函数时，这些函数将绑定同样的闭包"></a>3.当在一个循环中赋值函数时，这些函数将绑定同样的闭包</h4><pre><code class="javascript">function buildList(list) {
    var result = [];
    for (var i = 0; i &lt; list.length; i++) {
        var item = &#39;item&#39; + list[i];
        result.push( function() {alert(item + &#39; &#39; + list[i])} );
    }
    return result;
}

function testList() {
    var fnlist = buildList([1,2,3]);
    // using j only to help prevent confusion - could use i
    for (var j = 0; j &lt; fnlist.length; j++) {
        fnlist[j]();
    }
}
</code></pre>
<p>testList的执行结果是弹出item3 undefined窗口三次，因为这三个函数绑定了同一个闭包，而且item的值为最后计算的结果，但是当i跳出循环时i值为4，所以list[4]的结果为undefined.</p>
<h4 id="4-外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后"><a href="#4-外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后" class="headerlink" title="4.外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后"></a>4.外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后</h4><pre><code class="javascript">function sayAlice() {
    var sayAlert = function() { alert(alice); }
    // Local variable that ends up within closure
    var alice = &#39;Hello Alice&#39;;
    return sayAlert;
}
var helloAlice=sayAlice();
helloAlice();
</code></pre>
<h4 id="5-每次函数调用的时候创建一个新的闭包"><a href="#5-每次函数调用的时候创建一个新的闭包" class="headerlink" title="5.每次函数调用的时候创建一个新的闭包"></a>5.每次函数调用的时候创建一个新的闭包</h4><pre><code class="javascript">function newClosure(someNum, someRef) {
    // Local variables that end up within closure
    var num = someNum;
    var anArray = [1,2,3];
    var ref = someRef;
    return function(x) {
        num += x;
        anArray.push(num);
        alert(&#39;num: &#39; + num +
        &#39;\nanArray &#39; + anArray.toString() +
        &#39;\nref.someVar &#39; + ref.someVar);
    }
}
closure1=newClosure(40,{someVar:&#39;closure 1&#39;});
closure2=newClosure(1000,{someVar:&#39;closure 2&#39;});

closure1(5); // num:45 anArray[1,2,3,45] ref:&#39;someVar closure1&#39;
closure2(-10);// num:990 anArray[1,2,3,990] ref:&#39;someVar closure2&#39;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="大部分人都会做错的经典JS闭包面试题"><a href="#大部分人都会做错的经典JS闭包面试题" class="headerlink" title="大部分人都会做错的经典JS闭包面试题"></a><a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a></h2><pre><code class="javascript">function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1
//问:三行a,b,c的输出分别是什么？
</code></pre>
<h3 id="JS中有几种函数"><a href="#JS中有几种函数" class="headerlink" title="JS中有几种函数"></a>JS中有几种函数</h3><p>在JS中函数可以分为两种，<strong>具名函数（命名函数）</strong>和<strong>匿名函数</strong>。区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<h3 id="创建函数的几种方式"><a href="#创建函数的几种方式" class="headerlink" title="创建函数的几种方式"></a>创建函数的几种方式</h3><h4 id="1-声明函数"><a href="#1-声明函数" class="headerlink" title="1.声明函数"></a>1.声明函数</h4><h4 id="2-创建匿名函数表达式"><a href="#2-创建匿名函数表达式" class="headerlink" title="2.创建匿名函数表达式"></a>2.创建匿名函数表达式</h4><pre><code class="javascript">var fn1=function (){}
</code></pre>
<h4 id="3-创建具名函数表达式"><a href="#3-创建具名函数表达式" class="headerlink" title="3.创建具名函数表达式"></a>3.创建具名函数表达式</h4><pre><code class="javascript">var fn1=function xxcanghai(){};
</code></pre>
<blockquote>
<p>注意：具名函数表达式的函数名只能在创建函数内部使用(xxcanghai)</p>
<p>注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
</blockquote>
<h4 id="4-Function构造函数"><a href="#4-Function构造函数" class="headerlink" title="4.Function构造函数"></a>4.Function构造函数</h4><p>可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是<strong>匿名函数</strong>。</p>
<pre><code class="javascript">Function(&quot;alert(1)&quot;)
</code></pre>
<h4 id="5-自执行函数"><a href="#5-自执行函数" class="headerlink" title="5.自执行函数"></a>5.自执行函数</h4><pre><code class="javascript">(function(){alert(1);})();
(function fn1(){alert(1);})();
</code></pre>
<p>自执行函数属于上述的“函数表达式”，规则相同</p>
<h4 id="6-其他创建函数的方法"><a href="#6-其他创建函数的方法" class="headerlink" title="6.其他创建函数的方法"></a>6.其他创建函数的方法</h4><p>采用 eval ， setTimeout ， setInterval 等非常用方法</p>
<h3 id="三个fun函数的关系是什么？"><a href="#三个fun函数的关系是什么？" class="headerlink" title="三个fun函数的关系是什么？"></a>三个fun函数的关系是什么？</h3><p>第一个fun函数，属于标准具名函数声明，是<strong>新创建</strong>的函数，他的返回值是一个对象字面量表达式，属于一个新的object。</p>
<p>fun这个属性中存放的是一个<strong>新创建</strong>匿名函数表达式。</p>
<blockquote>
<p>注意：所有<strong>声明的匿名函数都是一个新函数。</strong></p>
</blockquote>
<h3 id="函数作用域链的问题"><a href="#函数作用域链的问题" class="headerlink" title="函数作用域链的问题"></a>函数作用域链的问题</h3><p>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。</p>
<p>原因也非常简单，因为<strong>函数作用域链</strong>的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。</p>
<p>所以综上所述，可以得知，<strong>最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数</strong>。</p>
<h3 id="到底在调用哪个函数？"><a href="#到底在调用哪个函数？" class="headerlink" title="到底在调用哪个函数？"></a>到底在调用哪个函数？</h3><p><strong>1、第一行a</strong></p>
<p>第一个fun(0)是在调用<strong>第一层fun函数</strong>。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：第后面几个fun(1),fun(2),fun(3),函数都是在调用<strong>第二层fun函数</strong>。</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p><strong>2、第二行b</strong></p>
<p>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是<strong>第二次执行的返回对象</strong>。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p><strong>3、第三行c</strong></p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/29157822" target="_blank" rel="external">当面试官问你闭包时，他究竟想听到些什么？</a></li>
<li><a href="https://segmentfault.com/q/1010000002880935" target="_blank" rel="external">javascript关于闭包的面试题</a></li>
<li><a href="http://blog.csdn.net/chelen_jak/article/details/50568911" target="_blank" rel="external">理解 Javascript 的闭包 （例子举得很好）</a></li>
<li><a href="http://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="external">全面理解Javascript闭包和闭包的几种写法及用途</a></li>
<li><a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍面向对象的</p>
<a id="more"></a>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实作用域很简单，搞清楚以下几点：</p>
<h2 id="1-函数作用域"><a href="#1-函数作用域" class="headerlink" title="1. 函数作用域"></a>1. 函数作用域</h2><p>js没有块级作用域（你可以自己闭包或其他方法实现），只有函数级作用域，<strong>函数外面的变量函数里面可以找到，函数里面的变量外面找不到</strong>。</p>
<h2 id="2-变量声明提升-Hoisting"><a href="#2-变量声明提升-Hoisting" class="headerlink" title="2. 变量声明提升(Hoisting)"></a>2. 变量声明提升(Hoisting)</h2><p>由于函数作用域的特性，局部变量在整个函数体始终是由定义的。<strong>变量声明”提前“到函数体顶部，同时变量初始化还在原来位置。</strong></p>
<p>这意味着 <strong><code>var</code> 表达式和 <code>function</code> 声明</strong>都将会被提升到当前作用域的顶部。</p>
<p>在 Nettuts+ 网站有一篇介绍 hoisting 的<a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-javascript-hoisting-explained/" target="_blank" rel="external">文章</a></p>
<h2 id="3-变量就近查找"><a href="#3-变量就近查找" class="headerlink" title="3. 变量就近查找"></a>3. 变量就近查找</h2><p>每次引用一个变量，<strong>JavaScript 会向上遍历整个作用域直到找到这个变量为止。</strong><br>如果到达全局作用域但是这个变量仍未找到，则会抛出 <code>ReferenceError</code> 异常。这是一个预解析的过程。</p>
<h2 id="4-参数"><a href="#4-参数" class="headerlink" title="4. 参数"></a>4. 参数</h2><p><strong>当参数跟局部变量重名时，优先级是等同的。</strong></p>
<h2 id="5-变量作用域"><a href="#5-变量作用域" class="headerlink" title="5. 变量作用域"></a>5. 变量作用域</h2><p>当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说无法通过delete运算符删除</p>
<pre><code class="javascript">var name=1    -&gt;不可删除
sex=”girl“         -&gt;可删除
this.age=22    -&gt;可删除
</code></pre>
<h2 id="6-名称解析顺序"><a href="#6-名称解析顺序" class="headerlink" title="6. 名称解析顺序"></a>6. 名称解析顺序</h2><p>比如，当访问函数内的 <code>foo</code> 变量时，JavaScript 会按照下面顺序查找：</p>
<ol>
<li>当前作用域内是否有 <code>var foo</code> 的定义。</li>
<li>函数形式参数是否有使用 <code>foo</code> 名称的。</li>
<li>函数自身是否叫做 <code>foo</code>。</li>
<li>回溯到上一级作用域，然后从 <strong>#1</strong> 重新开始。</li>
</ol>
<blockquote>
<p><strong>注意:</strong> 自定义 <code>arguments</code> 参数将会阻止原生的 <code>arguments</code> 对象的创建。</p>
</blockquote>
<h2 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h2><p>只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript中，这可以通过 <em>匿名包装器</em> 轻松解决。</p>
<pre><code class="javascript">(function() {
    // 函数创建一个命名空间

    window.foo = function() {
        // 对外公开的函数，创建了闭包
    };

})(); // 立即执行此匿名函数
</code></pre>
<p>匿名函数被认为是表达式；因此为了可调用性，它们首先会被执行。</p>
<pre><code class="javascript">( // 小括号内的函数首先被执行
function() {}
) // 并且返回函数对象
() // 调用上面的执行结果，也就是函数对象
</code></pre>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。</p>
<pre><code class="javascript">// 另外两种方式
+function(){}();
(function(){}());
</code></pre>
<p>推荐使用<em>匿名包装器</em>（<strong>译者注：</strong>也就是自执行的匿名函数）来创建命名空间。</p>
<h2 id="8-作用域链"><a href="#8-作用域链" class="headerlink" title="8. 作用域链"></a>8. 作用域链</h2><p>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个<strong>内部属性是[[Scope]]</strong>，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。</p>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。</p>
<h2 id="9-改变作用域链"><a href="#9-改变作用域链" class="headerlink" title="9. 改变作用域链"></a>9. 改变作用域链</h2><p>一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。</p>
<p>with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。with语句是对象的快捷应用方式，用来避免书写重复代码。实际上会产生性能问题。在程序中应避免使用with语句</p>
<p>当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理。</p>
<h2 id="10-作用域链和代码优化"><a href="#10-作用域链和代码优化" class="headerlink" title="10.作用域链和代码优化"></a>10.作用域链和代码优化</h2><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。<strong>一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</strong></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-函数作用域"><a href="#Case1-函数作用域" class="headerlink" title="Case1.函数作用域"></a>Case1.函数作用域</h2><pre><code class="javascript">var a=10; 
function aaa(){ 
 alert(a);
};            
function bbb(){
var a=20;
aaa();
}
bbb(); //结果为10，因为aaa()函数不能访问到bbb()里面的局部变量，所以访问到的是a=10,这个全局变量。
</code></pre>
<h2 id="Case2-函数声明提升"><a href="#Case2-函数声明提升" class="headerlink" title="Case2.函数声明提升"></a>Case2.函数声明提升</h2><pre><code class="javascript">var scope=&quot;global&quot;;  
function t(){  
    console.log(scope);      //undefined
    var scope=&quot;local&quot;  
    console.log(scope);      //local
}  
t();
</code></pre>
<h2 id="Case3-函数作用域"><a href="#Case3-函数作用域" class="headerlink" title="Case3.函数作用域"></a>Case3.函数作用域</h2><pre><code class="javascript">&lt;html&gt;  
&lt;head&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
function buttonInit(){  
    for(var i=1;i&lt;4;i++){  
        var b=document.getElementById(&quot;button&quot;+i);  
        b.addEventListener(&quot;click&quot;,function(){ alert(&quot;Button&quot;+i);},false);  
    }  
}  
window.onload=buttonInit;  
&lt;/script&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;button id=&quot;button1&quot;&gt;Button1&lt;/button&gt;  
&lt;button id=&quot;button2&quot;&gt;Button2&lt;/button&gt;  
&lt;button id=&quot;button3&quot;&gt;Button3&lt;/button&gt;  
&lt;/body&gt;  
&lt;/html&gt;
</code></pre>
<p>三个按钮都是弹出：”Button4”。当注册事件结束后，i的值为4，当点击按钮时，事件函数即function(){ alert(“Button”+i);}这个匿名函数中没有i,根据作用域链，所以到buttonInit函数中找，此时i的值为4，</p>
<h2 id="Case4-if-表达式"><a href="#Case4-if-表达式" class="headerlink" title="Case4.if 表达式"></a>Case4.<code>if</code> 表达式</h2><p>没有块级作用域不仅导致 <code>var</code> 表达式被从循环内移到外部，而且使一些 <code>if</code> 表达式更难看懂。</p>
<pre><code class="javascript">// 检查 SomeImportantThing 是否已经被初始化
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>
<h2 id="Case5-with语句"><a href="#Case5-with语句" class="headerlink" title="Case5.with语句"></a>Case5.with语句</h2><pre><code class="javascript">person={name:&quot;yhb&quot;,age:22,height:175,wife:{name:&quot;lwy&quot;,age:21}};  
with(person.wife){  
    console.log(name);  
}
</code></pre>
<h2 id="Case6-作用域链流程"><a href="#Case6-作用域链流程" class="headerlink" title="Case6.作用域链流程"></a>Case6.作用域链流程</h2><pre><code class="javascript">function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}
</code></pre>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg" alt=""></p>
<p>函数add的作用域将会在执行时用到。例如执行如下代码：<code>var</code> <code>total = add(5,10);</code></p>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg" alt=""></p>
<h2 id="Case7-作用域链和代码优化"><a href="#Case7-作用域链和代码优化" class="headerlink" title="Case7.作用域链和代码优化"></a>Case7.作用域链和代码优化</h2><pre><code class="javascript">function changeColor(){
    document.getElementById(&quot;btnChange&quot;).onclick=function(){
        document.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;
    };
}
</code></pre>
<p>这段代码可以重写如下：</p>
<pre><code class="javascript">function changeColor(){
    var doc=document;
    doc.getElementById(&quot;btnChange&quot;).onclick=function(){
        doc.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;
    };
}
</code></pre>
<h2 id="Case8-改变作用域链"><a href="#Case8-改变作用域链" class="headerlink" title="Case8.改变作用域链"></a>Case8.改变作用域链</h2><p><strong>with</strong></p>
<pre><code class="javascript">function initUI(){
    with(document){
        var bd=body,
            links=getElementsByTagName(&quot;a&quot;),
            i=0,
            len=links.length;
        while(i &lt; len){
            update(links[i++]);
        }
        getElementById(&quot;btnInit&quot;).onclick=function(){
            doSomething();
        };
    }
}
</code></pre>
<p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示：</p>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg" alt=""></p>
<p><strong>catch</strong></p>
<pre><code class="javascript">try{
    doSomething();
}catch(ex){
    alert(ex.message); //作用域链在此处改变
}
</code></pre>
<p>一个很好的模式是将错误委托给一个函数处理，例如：</p>
<pre><code class="javascript">try{
    doSomething();
}catch(ex){
    handleError(ex); //委托给处理器方法
}
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/yueguanghaidao/article/details/9568071" target="_blank" rel="external">Js作用域与作用域链详解</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="external">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></li>
<li><a href="https://segmentfault.com/a/1190000000736812" target="_blank" rel="external">js作用域与命名空间</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端工程化]]></title>
      <url>/2017/11/04/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA/%E6%9E%B6%E6%9E%84/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>前端工程化学习整理。</p>
<p>TODO：</p>
<blockquote>
<ul>
<li>太多太多，慢慢细化记录构建的坑和优化对比</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="前端工程化概念"><a href="#前端工程化概念" class="headerlink" title="前端工程化概念"></a>前端工程化概念</h1><h2 id="《浅析前端工程化》"><a href="#《浅析前端工程化》" class="headerlink" title="《浅析前端工程化》"></a>《浅析前端工程化》</h2><h3 id="1-什么是前端工程化"><a href="#1-什么是前端工程化" class="headerlink" title="1.什么是前端工程化"></a>1.什么是前端工程化</h3><h3 id="2-前端工程化面临的问题"><a href="#2-前端工程化面临的问题" class="headerlink" title="2.前端工程化面临的问题"></a>2.前端工程化面临的问题</h3><p>要解决前端工程化的问题，可以从两个角度入手：<em>开发</em>和<em>部署</em>。</p>
<p>从开发角度，要解决的问题包括：</p>
<ol>
<li>提高开发生产效率；</li>
<li>降低维护难度。</li>
</ol>
<p>这两个问题的解决方案有两点：</p>
<ol>
<li>制定开发规范，提高团队协作能力；</li>
<li>分治。软件工程中有个很重要的概念叫做<em>模块化开发</em>其中心思想就是分治。</li>
</ol>
<p>从部署角度，要解决的问题主要是<strong>资源管理</strong>，包括：</p>
<ol>
<li>代码审查；</li>
<li>压缩打包；</li>
<li>增量更新；</li>
<li>单元测试；</li>
</ol>
<p>要解决上述问题，需要引入<strong>构建/编译</strong>阶段。</p>
<h4 id="2-1-开发规范"><a href="#2-1-开发规范" class="headerlink" title="2.1 开发规范"></a>2.1 开发规范</h4><p>推荐<a href="https://github.com/airbnb/javascript" target="_blank" rel="external">Airbnb的eslint规范</a></p>
<h4 id="2-2-模块-组件化开发"><a href="#2-2-模块-组件化开发" class="headerlink" title="2.2 模块/组件化开发"></a>2.2 模块/组件化开发</h4><h5 id="2-2-1-模块还是组件？"><a href="#2-2-1-模块还是组件？" class="headerlink" title="2.2.1 模块还是组件？"></a>2.2.1 模块还是组件？</h5><p>两者的区别主要在<strong>颗粒度</strong>方面。</p>
<p>简单讲，module侧重的是对属性的封装，重心是在设计和开发阶段，不关注runtime的逻辑。module是一个白盒；而component是一个可以独立部署的软件单元，面向的是runtime，侧重于产品的功能性。component是一个黑盒，内部的逻辑是不可见的。</p>
<p>用通俗的话讲，模块可以理解为零件，比如轮胎上的螺丝钉；而组件则是轮胎，是具备某项完整功能的一个整体。具体到前端领域，一个button是一个模块，一个包括多个button的nav是一个组件。</p>
<h5 id="2-2-2-模块-组件化开发的必要性"><a href="#2-2-2-模块-组件化开发的必要性" class="headerlink" title="2.2.2 模块/组件化开发的必要性"></a>2.2.2 模块/组件化开发的必要性</h5><p>模块/组件化开发的核心思想是<strong>分治</strong>，主要针对的是开发和维护阶段。</p>
<h3 id="3-构建-amp-编译"><a href="#3-构建-amp-编译" class="headerlink" title="3. 构建&amp;编译"></a>3. 构建&amp;编译</h3><h4 id="3-1-构建在前端工程中的角色"><a href="#3-1-构建在前端工程中的角色" class="headerlink" title="3.1 构建在前端工程中的角色"></a>3.1 构建在前端工程中的角色</h4><p>典型的web前后端协作模式</p>
<p><img src="http://images2015.cnblogs.com/blog/595796/201604/595796-20160411142716207-1803317219.png" alt="典型的web前后端协作模式"></p>
<p>大前端模式的构建：</p>
<p><img src="http://images2015.cnblogs.com/blog/595796/201604/595796-20160411142733598-1823214206.png" alt="大前端模式的构建"></p>
<p>构建的作用就是对静态资源以及模板进行处理，换句话说：<strong>构建的核心是资源管理</strong>。</p>
<h4 id="3-2-资源管理要做什么？"><a href="#3-2-资源管理要做什么？" class="headerlink" title="3.2 资源管理要做什么？"></a>3.2 资源管理要做什么？</h4><p>前端的资源可以分为<strong>静态资源</strong>和<strong>模板</strong>。构建过程中需要对两种资源使用不同的构建策略。</p>
<h5 id="3-2-1-静态资源构建策略"><a href="#3-2-1-静态资源构建策略" class="headerlink" title="3.2.1 静态资源构建策略"></a>3.2.1 静态资源构建策略</h5><p>通常开发阶段的静态资源是：</p>
<ol>
<li>es6/7规范的文件；</li>
<li>less/sass等文件（具体看团队技术选型）；</li>
<li>[可选]独立的小图标，在构建阶段使用工具处理成spirit图片。</li>
</ol>
<p>构建阶段在处理这些静态文件时，基本的功能应包括：</p>
<ol>
<li>es6/7转译，比如babel；</li>
<li>将less/sass编译成css；</li>
<li>spirit图片生成；</li>
</ol>
<p>静态资源的构建处理还需要考虑web应用的<strong>性能因素</strong>，构建阶段需要包括以下功能：</p>
<ol>
<li>依赖打包。分析文件依赖关系，将同步依赖的的文件打包在一起，减少http请求数量；</li>
<li>资源嵌入。比如小于10KB的图片编译为base64格式嵌入文档，减少一次http请求；</li>
<li>文件压缩。减小文件体积；</li>
<li>hash指纹。通过给文件名加入hash指纹，以应对浏览器缓存引起的静态资源更新问题；</li>
<li>代码审查。避免上线文件的低级错误；</li>
</ol>
<p>对比目前较流行的一些构建产品，比如fis，它具备以上所得的编译功能，同时提供了一些机制以<strong>提高开发阶段的生产效率</strong>。包括：</p>
<ol>
<li>文件监听。配合动态构建、浏览器自动刷新等功能，提高开发效率；</li>
<li>mock server。并非所有前端团队都是大前端，即使在大前端体系下，mock server的存在也是很有必要的；</li>
</ol>
<h5 id="3-2-2-模板的构建策略"><a href="#3-2-2-模板的构建策略" class="headerlink" title="3.2.2 模板的构建策略"></a>3.2.2 模板的构建策略</h5><p>模板与静态资源是<em>容器-模块</em>关系。模板直接引用静态资源，经过构建后，静态资源的改动有以下几点：</p>
<ol>
<li>url改变。开发环境与线上环境的url肯定是不同的，不同类型的资源甚至根据项目的CDN策略放在不同的服务器上；</li>
<li>文件名改变。静态资源经过构建之后，文件名被加上hash指纹，内容的改动导致hash指纹的改变。</li>
</ol>
<p>对于模板的构建宗旨是在<strong>静态资源url和文件名改变后，同步更新模板中资源的引用地址</strong>。</p>
<p>这种模式下fis的<strong>资源映射表</strong>机制是非常好的解决方案。</p>
<h5 id="3-2-3-小结"><a href="#3-2-3-小结" class="headerlink" title="3.2.3 小结"></a>3.2.3 小结</h5><p>构建可以分为<strong>工具层面</strong>和<strong>平台层面</strong>的功能：</p>
<p>工具层面</p>
<ol>
<li>预编译，包括es6/7语法转译、css预编译器处理、spirit图片生成；</li>
<li>依赖打包；</li>
<li>资源嵌入；</li>
<li>文件压缩；</li>
<li>hash指纹；</li>
<li>代码审查；</li>
<li>模板构建。</li>
</ol>
<p>平台层面</p>
<ol>
<li>文件监听，动态编译；</li>
<li>mock server。</li>
</ol>
<h2 id="《谁能介绍下web前端工程化》"><a href="#《谁能介绍下web前端工程化》" class="headerlink" title="《谁能介绍下web前端工程化》"></a>《谁能介绍下web前端工程化》</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化就是<strong>将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载</strong>。</p>
<h4 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h4><p>社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。</p>
<p>ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>
<p>模块的打包和加载问题：</p>
<ol>
<li>用 Webpack + Babel将所有模块打包成一个文件同步加载，也可以打成多个chunk异步加载；（主流）</li>
<li>用 SystemJS+Babel 主要是分模块异步加载；</li>
<li>用浏览器的<code>&lt;script type=&quot;module&quot;&gt;</code>加载</li>
</ol>
<h4 id="CSS的模块化"><a href="#CSS的模块化" class="headerlink" title="CSS的模块化"></a>CSS的模块化</h4><p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：<strong>选择器的全局污染问题</strong>。</p>
<p>解决方法：</p>
<ul>
<li>各厂都制定了自己的CSS命名风格。弱约束</li>
<li>工具层面：Shadow DOM、CSS in JS和CSS Modules三种解决方案<ul>
<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；</li>
<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；<a href="https://polished.js.org/" target="_blank" rel="external">polished.js</a>，柯里化</li>
<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。一种哈希文件名的实现，只加入了局部作用域和模块依赖。CSS Modules 内部通过 <a href="https://github.com/css-modules/icss" target="_blank" rel="external">ICSS</a> 来解决样式导入和导出这两个问题。分别对应 <code>:import</code> 和 <code>:export</code> 两个新增的伪类。</li>
</ul>
</li>
</ul>
<h4 id="资源的模块化"><a href="#资源的模块化" class="headerlink" title="资源的模块化"></a>资源的模块化</h4><p>资源模块化后，有三个好处：</p>
<ol>
<li>依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；</li>
<li>资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等。</li>
<li>项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数：dest = webpack(src, config)</li>
</ol>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。</p>
<p>从UI拆分下来的<strong>每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</strong></p>
<p>其实，组件化更重要的是一种<strong>分治思想</strong>。</p>
<p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p>
<p>其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式<strong>对面向对象的进一步抽象</strong>。</p>
<p>所以我们除了封装组件本身，还要合理处理组件之间的关系，比如<strong>（逻辑）继承</strong>、<strong>（样式）扩展</strong>、<strong>（模板）嵌套</strong>和<strong>包含</strong>等，这些关系都可以归为<strong>依赖</strong>。</p>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><p>一些内容：</p>
<ul>
<li>目录结构的制定</li>
<li>编码规范</li>
<li>前后端接口规范</li>
<li>文档规范</li>
<li>组件管理</li>
<li>Git分支管理</li>
<li>Commit描述规范</li>
<li>定期CodeReview</li>
<li>视觉图标规范</li>
<li>…</li>
</ul>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h4 id="图标合并"><a href="#图标合并" class="headerlink" title="图标合并"></a>图标合并</h4><p>Webpack</p>
<h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><h4 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h4><h4 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h4><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><p>比如：Karma + Mocha + Chai</p>
<h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="RequireJS"><a href="#RequireJS" class="headerlink" title="RequireJS"></a>RequireJS</h2><h3 id="RequireJS使用"><a href="#RequireJS使用" class="headerlink" title="RequireJS使用"></a>RequireJS使用</h3><h2 id="SPA理解"><a href="#SPA理解" class="headerlink" title="SPA理解"></a>SPA理解</h2><h3 id="作用（好处）"><a href="#作用（好处）" class="headerlink" title="作用（好处）"></a>作用（好处）</h3><ol>
<li>由于避免了页面的重新加载，SPA可以提供较为流畅的用户体验。得益于Ajax，可以实现无跳转刷新，由于与浏览器的history机制，可以使用hash的b变化从而可以实现推动界面变化。</li>
<li>只要使用支持HTML5和CSS3的浏览器就可以执行复杂的SPA,因此，开发人员不必为了写SPA网站而特别学习另一个开发方式，而使用者也不额外安装软件，所以，让开发SPA网页程序的入门和使用门槛降低不少。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>以SPA方式开发的网站不容易管理也不够安全。<br>因为没了一页一页的网页给搜索引擎的爬虫来爬，所以，在搜索引擎最佳化（SEO）的工作上，需要花费额外的功夫。<br>因为没有换页，需要自定义状态来取代传统网页程序以网址来做判断。</p>
<h3 id="实现SPA"><a href="#实现SPA" class="headerlink" title="实现SPA"></a>实现SPA</h3><p><strong>技术：</strong></p>
<ol>
<li>处理#后面的字符</li>
<li>局部刷新</li>
</ol>
<h2 id="Babel的原理"><a href="#Babel的原理" class="headerlink" title="Babel的原理"></a>Babel的原理</h2><p>但是和编译器类似，babel的转译过程也分为三个阶段：parsing、transforming、generating，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p>
<blockquote>
<p>ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码</p>
</blockquote>
<p>Babel工作分为三个阶段:</p>
<ol>
<li>解析:将代码字符串解析成抽象语法树</li>
<li>变换:将抽象语法树</li>
<li>根据变换后的抽象语法树再生成代码字符串</li>
</ol>
<h2 id="Babel的一些转化"><a href="#Babel的一些转化" class="headerlink" title="Babel的一些转化"></a>Babel的一些转化</h2><h3 id="A-动态字符使用反引号"><a href="#A-动态字符使用反引号" class="headerlink" title="A.动态字符使用反引号"></a>A.动态字符使用反引号</h3><pre><code class="javascript">const a = &#39;foobar&#39;;
const b = `foo${a}bar`;

var a = &#39;foobar&#39;;
var b = &#39;foo&#39; + a + &#39;bar&#39;;
</code></pre>
<h3 id="B-解构"><a href="#B-解构" class="headerlink" title="B.解构"></a>B.解构</h3><pre><code class="javascript">const arr = [1, 2, 3, 4];
const [first, second] = arr;

var arr = [1, 2, 3, 4];
var first = arr[0],
    second = arr[1];
</code></pre>
<h3 id="C-默认参数"><a href="#C-默认参数" class="headerlink" title="C.默认参数"></a>C.默认参数</h3><pre><code class="javascript">function concateAll(...args){
    return args.join(&#39;&#39;);
}

function concateAll() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key &lt; _len; _key++) {
        args[_key] = arguments[_key];
    }
    return args.join(&#39;&#39;);
}
</code></pre>
<h2 id="Gzip压缩工作原理"><a href="#Gzip压缩工作原理" class="headerlink" title="Gzip压缩工作原理"></a>Gzip压缩工作原理</h2><p>Web服务器处理HTTP压缩的过程如下：</p>
<ol>
<li>Web服务器接收到浏览器的HTTP请求后，检查浏览器是否支持HTTP压缩（Accept-Encoding 信息）；</li>
<li>如果浏览器支持HTTP压缩，Web服务器检查请求文件的后缀名；</li>
<li>如果请求文件是HTML、CSS等静态文件，Web服务器到压缩缓冲目录中检查是否已经存在请求文件的最新压缩文件；</li>
<li>如果请求文件的压缩文件不存在，Web服务器向浏览器返回未压缩的请求文件，并在压缩缓冲目录中存放请求文件的压缩文件；</li>
<li>如果请求文件的最新压缩文件已经存在，则直接返回请求文件的压缩文件；</li>
<li>如果请求文件是动态文件，Web服务器动态压缩内容并返回浏览器，压缩内容不存放到压缩缓存目录中。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="ES6模块系统"><a href="#ES6模块系统" class="headerlink" title="ES6模块系统"></a>ES6模块系统</h2><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://www.zhihu.com/question/24558375" target="_blank" rel="external">谁能介绍下web前端工程化？</a></li>
<li><a href="http://www.cnblogs.com/ihardcoder/p/5378290.html" target="_blank" rel="external">浅析前端工程化</a></li>
<li><a href="http://hzp.iteye.com/blog/1833619" target="_blank" rel="external">用Gzip对网页内容进行压缩详解</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 构建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6知识点整理]]></title>
      <url>/2017/11/04/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/ES6/ES6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>ES6知识点整理。</p>
<p>ES6给我的感觉主要是一个简化的工具，一是将作用域、继承、原型这些JS比较难理解的概念做抽象，二是对对象、数组这些不太方便使用的方法增加方法，三是对函数模型做简化，默认值、Rest这些，四是对模块交互上做简化，比如Modules。有点C向C++过渡的意思。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p><code>let</code> 和 <code>const</code> 语句不会造成声明提升。会报错ReferenceError</p>
<p><code>let</code> 和 <code>const</code> 是块级作用域语句。</p>
<p>使用 <code>let</code> 声明一个变量，使用 <code>const</code> 来声明一个不可改变的常量。</p>
<h2 id="块级立即执行函数"><a href="#块级立即执行函数" class="headerlink" title="块级立即执行函数"></a>块级立即执行函数</h2><p>ES6支持块级作用域，可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>一些时候，我们在函数嵌套中需要访问上下文中的 <code>this</code>。</p>
<ul>
<li>一种通用的方式是把上下文中的 <code>this</code> 保存在一个变量里</li>
<li>也可以把 <code>this</code> 通过属性传进去</li>
<li>还可以直接使用 <code>bind</code></li>
<li>使用 <strong>箭头函数</strong></li>
</ul>
<h3 id="箭头函数需要注意的地方"><a href="#箭头函数需要注意的地方" class="headerlink" title="箭头函数需要注意的地方"></a>箭头函数需要注意的地方</h3><p>当要求动态上下文的时候，就不能够使用箭头函数。也就是this的固定化</p>
<ol>
<li>在使用=&gt;定义函数的时候，<strong>this的指向是定义时所在的对象</strong>，而不是使用时所在的对象</li>
<li>不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误</li>
<li>不能够使用arguments对象</li>
<li>不能使用yield命令</li>
</ol>
<h2 id="字符串拓展"><a href="#字符串拓展" class="headerlink" title="字符串拓展"></a>字符串拓展</h2><h3 id="includes"><a href="#includes" class="headerlink" title=".includes( )"></a>.includes( )</h3><p>替代以往判断内容<code>.indexOf(xxx) &gt; -1</code> 的方式。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title=".repeat( )"></a>.repeat( )</h3><p>实现重复字符：</p>
<pre><code class="javascript">&#39;meow&#39;.repeat(3); // &#39;meowmeowmeow&#39;
</code></pre>
<h3 id="contains"><a href="#contains" class="headerlink" title=".contains()"></a>.contains()</h3><p>返回布尔值，表示是否找到了参数字符串</p>
<h3 id="startsWith"><a href="#startsWith" class="headerlink" title=".startsWith()"></a>.startsWith()</h3><p>返回布尔值，表示参数字符串是否在源字符串的头部</p>
<h3 id="endsWith"><a href="#endsWith" class="headerlink" title=".endsWith()"></a>.endsWith()</h3><p>返回布尔值，表示参数字符串是否在源字符串的尾部</p>
<h3 id="字符串模板字面量"><a href="#字符串模板字面量" class="headerlink" title="字符串模板字面量"></a>字符串模板字面量</h3><ul>
<li>在字符串中直接使用特殊字符，而不用转义。</li>
<li>支持直接插入变量</li>
<li>直接换行</li>
<li>内部可以使用表达式</li>
</ul>
<pre><code class="javascript">let text = ( `cat
    dog
    nickelodeon`
);
string${varible}string
</code></pre>
<h2 id="数组的拓展"><a href="#数组的拓展" class="headerlink" title="数组的拓展"></a>数组的拓展</h2><p><strong>Array.from()用于将两类对象转为真正的数组：</strong>类似数组的对象（array-like object）和可遍历（iterable）的对象，其中包括ES6新增的Set和Map结构。</p>
<p><strong>【重点】find()和findIndex()</strong>，意义较大，如下：</p>
<pre><code class="javascript">[1,5,10,15].find( function(value, index, arr){ return value &gt; 9; } ); // 返回10
[1,5,10,15].findIndex( function(value, index, arr){ return value &gt; 9; } ); // 返回2
</code></pre>
<p><strong>fill()使用给定值，填充一个数组：</strong></p>
<pre><code class="javascript">newArray(3).fill(7)
</code></pre>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><strong>Maps</strong> 是一个JavaScript中很重要（迫切需要）的数据结构。</p>
<p>Maps让我们使用 <code>set</code>，<code>get</code> 和 <code>search</code> 操作数据。</p>
<p>Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。</p>
<pre><code class="javascript">let map = new Map();
&gt; map.set(&#39;name&#39;, &#39;david&#39;);
&gt; map.get(&#39;name&#39;); // david
&gt; map.has(&#39;name&#39;); // true
</code></pre>
<p><strong>遍历：</strong></p>
<pre><code class="javascript">for (let key of map.keys()) {
for (let [key, value] of map.entries()) {
</code></pre>
<p><strong>ES6提供三个新的方法：entries()，keys()和values()用于遍历数组</strong>。</p>
<p>可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="Object.setPrototypeOf()，Object.getPrototypeOf()"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h3><h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of循环可以代替数组实例的forEach方法</p>
<p><strong>和for…in的区别</strong></p>
<ul>
<li>for…of可以遍历键与值，for…in只能遍历键名</li>
<li>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名</li>
</ul>
<h2 id="WeakMaps"><a href="#WeakMaps" class="headerlink" title="WeakMaps"></a>WeakMaps</h2><p>使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名</p>
<p>通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常有效的。</p>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><pre><code class="javascript">let [a, b, c, d] = [1, 2, 3, 4];    //数组
let luke = { occupation: &#39;jedi&#39;, father: &#39;anakin&#39; };    //对象
let {occupation, father} = luke;
</code></pre>
<p>该特性更多的用处是在遍历Map结构的时候，可以如下：</p>
<pre><code class="javascript">for( let [ key,value] of map ) 
{ console.log ( key +&#39;:&#39;+ value);}
</code></pre>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><pre><code class="javascript">export default api;
</code></pre>
<p>总是在模块的 <strong>最后</strong> 使用 <code>export default</code> 方法。它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><pre><code class="javascript">import * as content from &#39;./content&#39;
</code></pre>
<p><strong>注意</strong>：被导出的值是被 <strong>绑定的（原文：bingdings）</strong>，而不是引用。<br>所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。</p>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><pre><code class="javascript">function addTwoNumbers(x=0, y=0) {
    return x + y;
}
</code></pre>
<h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><p>使用 <strong>rest</strong> 操作符，我们可以给函数传入一个不确定数量的参数列表：</p>
<pre><code class="javascript">function logArguments(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
</code></pre>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>class语法相对原型、构造函数、继承更接近传统语法</p>
<pre><code class="javascript">class Animal {
    constructor () {
        this.type = &#39;animal&#39;
    }
    says(say) {
        console.log(this.type + &#39;says&#39; + say)
    }
}
 let animal = new Animal()
 animal.says(&#39;hello&#39;) // animal says hello

 class Cat extends Animal {
     constructor() {
         super()
         this.type = &#39;cat&#39;
     }
 }
 let cat = new Cat()
 cat.says(&#39;hello&#39;) // cat says hello
</code></pre>
<p>contructor内部定义的方法和属性是实例对象自己的，不能通过extends 进行继承。</p>
<p>在ES6中，子类的构造函数必须含有super函数，super表示的是调用父类的构造函数，虽然是父类的构造函数，但是this指向的却是cat</p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）</p>
<pre><code class="javascript">var target = { a:1};
var source1 = { b:2};
var source2 = { c:3};
Object.assign(target, source1, source2);
target// {a:1, b:2, c:3}

var n = Object.assign(a,b,c)向n中添加a,b,c的属性
</code></pre>
<p><strong>应用</strong></p>
<ul>
<li>为对象添加属性</li>
<li>为对象添加方法</li>
</ul>
<ul>
<li>克隆对象</li>
<li>为属性指定默认值</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的ID。它通过Symbol函数生成。</p>
<p>Symbols常用的一个使用场景，尤其是使用 <code>Symbol.for(key)</code> 方法，是用于实现代码间的互操作。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：</p>
<pre><code class="javascript">f1().then(f2);
f1().then(f2).then(f3);
f1().then(f2).fail(f3);
</code></pre>
<p>如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。</p>
<p>API:</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt;
    reject(new Error(&#39;Failed to fulfill Promise&#39;)))
        .catch(reason =&gt; console.log(reason));
</code></pre>
<p>这里有两个处理函数，<strong>resolve</strong>（当Promise执行成功完毕时调用的回调函数） 和 <strong>reject</strong> （当Promise执行不接受时调用的回调函数）</p>
<p><strong>Promises的好处</strong>：</p>
<ul>
<li>大量嵌套错误处理回调函数会使代码变得难以阅读理解。使用Promises，我们可以通过清晰的路径将错误事件让上传递，并且适当地处理它们。</li>
</ul>
<p>此外，Promise处理后的值，无论是解决（resolved）还是拒绝（rejected）的结果值，都是不可改变的。</p>
<h3 id="1-什么是promise对象，它能干什么？"><a href="#1-什么是promise对象，它能干什么？" class="headerlink" title="1. 什么是promise对象，它能干什么？"></a>1. 什么是promise对象，它能干什么？</h3><p><strong>Promise</strong> 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
<p><strong>Promise</strong> 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的 promise 对象来替代原返回值。</p>
<p><strong>Promise</strong> 对象有以下几种状态:</p>
<ul>
<li><em>pending</em>: 表示一个初始状态, 非 fulfilled 或 rejected。</li>
<li><em>fulfilled</em>: 成功的操作。</li>
<li><em>rejected</em>: 失败的操作。</li>
</ul>
<p>每一个异步任务都会返回一个Promise对象，该对象有一个then方法，允许指定回调函数。可以根据Promise对象的状态相应的去执行对应的回调函数。</p>
<h3 id="2-常用的API"><a href="#2-常用的API" class="headerlink" title="2. 常用的API"></a>2. 常用的API</h3><h4 id="1-Promise-prototype-then"><a href="#1-Promise-prototype-then" class="headerlink" title="1.Promise.prototype.then()"></a>1.Promise.prototype.then()</h4><p>它的作用是为promise实例添加状态改变时的回调函数。</p>
<p>then()方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的promise实例。</p>
<p>then方法的第二个参数一般不推荐写。有以下两个原因：</p>
<ul>
<li>由于是链式操作，这个then方法之后还可能会有其他操作，如果此时把错误捕捉的函数放在后面方法前边的话，并且之后再无错误捕获方法，then之后的错误就会捕捉不到。</li>
<li>在then方法里面，两个参数都是回调函数写了一大堆，这样结构看起来比较混乱。</li>
</ul>
<pre><code class="javascript">var p=new Promise(function(resolve, reject){
    resolve(&quot;ok&quot;);    
});
p.then(function(value){console.log(val)},
 function(err)(console.log(err))       
);
</code></pre>
<h4 id="2-Promise-prototype-catch"><a href="#2-Promise-prototype-catch" class="headerlink" title="2.Promise.prototype.catch()"></a>2.Promise.prototype.catch()</h4><p>这个方法是.then(null,rejection)的别名，这也能看出这个方法是专门只能用来捕获错误信息，用于指定发生错误时的回调函数。</p>
<p>要注意一下几点：</p>
<ul>
<li>当promise状态已经变成resolved的时候，再抛出错误时是无效的。</li>
<li>尽量将catch方法写在链式操作的最后。错误会一直冒泡到最后，catch放在最后会捕捉到所有错误。</li>
<li>当没有使用catch方法指定错误处理函数的回调函数时，promise对象里面抛出的错误不会传递到外层的代码。</li>
</ul>
<h4 id="3-Promise-resolve"><a href="#3-Promise-resolve" class="headerlink" title="3. Promise.resolve()"></a>3. Promise.resolve()</h4><p>这个方法的作用就是将现有的对象转化为Promise对象，进而可以执行这些方法。</p>
<pre><code class="javascript">Promise.resolve(&quot;foo&quot;);
</code></pre>
<h4 id="4-Promise-all"><a href="#4-Promise-all" class="headerlink" title="4. Promise.all()"></a>4. Promise.all()</h4><p>这个方法用于将多个promise实例，包装成一个新的promise实例。</p>
<pre><code class="javascript">var p=Promise.all([p1,p2,p3]);
</code></pre>
<p>要注意一下两点：</p>
<ul>
<li>只有当p1,p2,p3状态都变为fulfilled之后，p的状态才会变为fulfilled。</li>
<li>只要p1.p2,p3中有任意一个状态变为rejected，p的状态就会变为rejected。</li>
</ul>
<h3 id="3-实现异步编程的原理"><a href="#3-实现异步编程的原理" class="headerlink" title="3. 实现异步编程的原理"></a>3. 实现异步编程的原理</h3><p>Promise对象相当于是一个状态机，在其内部使用resolve方法，使其由初始状态变为成功时的fulfilled状态或者执行失败后的rejected状态。这时内部的工作就完成了，开始由外部监听其内部的状态的改变，调用then()方法（catch()方法相当于then内部的第二个参数方法）对应的状态调用对应的处理函数。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-promise执行顺序"><a href="#Case1-promise执行顺序" class="headerlink" title="Case1.promise执行顺序"></a>Case1.promise执行顺序</h2><pre><code class="javascript">setTimeout(function(){
    console.log(1);
}, 0)

new Promise(function executor(resolve){
    console.log(2);
    for(var i = 0; i &lt; 1000; i++){
        i = 9999 &amp;&amp; resolve();
    }
    console.log(3);
}).then(function(){
    console.log(4);
})

console.log(5);
// 2， 3， 5， 4， 1
</code></pre>
<ul>
<li>在定时器，事件，ajax等操作的时候，<strong>会使一个异步操作，会把该操作放到一个task queue里，需要等当前主线程的任务完成后，会读取任务队列(task queue)中的是事件。</strong></li>
<li>promise中的then操作是放在执行栈，也就是主线程的最后。 </li>
</ul>
<h2 id="Case2-promise的原理？jquery的ajax返回的是promise对象吗？"><a href="#Case2-promise的原理？jquery的ajax返回的是promise对象吗？" class="headerlink" title="Case2.promise的原理？jquery的ajax返回的是promise对象吗？"></a>Case2.promise的原理？jquery的ajax返回的是promise对象吗？</h2><p>jquery的ajax返回的是<strong>deferred对象</strong>，通过<strong>promise的resolve()方</strong>法将其转换为promise对象。</p>
<pre><code class="javascript">var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<h2 id="Case3-promise对象捕获错误"><a href="#Case3-promise对象捕获错误" class="headerlink" title="Case3.promise对象捕获错误"></a>Case3.promise对象捕获错误</h2><pre><code class="javascript">//使用throw添加错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    throw new Error(&#39;error0&#39;);
    //setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });

//设置定时器来抛出错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    //throw new Error(&#39;error0&#39;);
    setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });

//同时添加错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    throw new Error(&#39;error0&#39;);
    setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });
</code></pre>
<p>第一个只会打印出 “ok”。状态被设定为fulfilled之后，再进行抛出错误处理，错误也不会被后续的catch方法捕获到。</p>
<p>第二个先打印出“ok”，之后抛出process里面定义的错误。虽然状态已经变为fulfilled，但是定时器抛出的错误属于异步抛出的错误，无法被try catch捕获到，因此和Promise对象无关，所以错误可以正常的抛出来</p>
<p>第三个只打印出“ok”。当执行throw之后，虽然错误未被外部函数捕获处理，但这也是个实实在在存在的错误啊，对于javascript来说，有错就不会继续往下面执行了。所以并不会执行到定时器抛出错误就停止了</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000011344301" target="_blank" rel="external">前端面试之ES6篇（高产似母猪）</a></li>
<li><a href="http://www.jianshu.com/p/c4ba3b25ca0d" target="_blank" rel="external">ECMAScript 6重点一览——基础篇</a></li>
<li><a href="http://blog.csdn.net/shuidinaozhongyan/article/details/77864182" target="_blank" rel="external">面试考察之Promise对象</a></li>
<li>​</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPC项目前端总结]]></title>
      <url>/2017/11/04/%E9%A1%B9%E7%9B%AE/IPC%E9%A1%B9%E7%9B%AE%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>IPC项目前端一部分经验的整理。</p>
<p>里面东西还是很多的，后续有时间再补上。</p>
<a id="more"></a>
<h1 id="IPC项目总结"><a href="#IPC项目总结" class="headerlink" title="IPC项目总结"></a>IPC项目总结</h1><h2 id="1-前端导出excel功能的实现"><a href="#1-前端导出excel功能的实现" class="headerlink" title="1. 前端导出excel功能的实现"></a>1. 前端导出<strong>excel</strong>功能的实现</h2><h3 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h3><h4 id="服务器端生成-Vs-浏览器端生成"><a href="#服务器端生成-Vs-浏览器端生成" class="headerlink" title="服务器端生成  Vs  浏览器端生成"></a>服务器端生成  Vs  浏览器端生成</h4><p>服务器端生成：</p>
<p><strong>table</strong>或是<strong>cvs</strong>纯文本的数据格式等。然后按<strong>.xls</strong>或是<strong>.cvs</strong>格式的文件的形式返回给用户，指定<strong>Content-Type:application/vnd.ms-excel ,</strong>浏览器就会提示要下载的文件是<strong>excel</strong>文件。</p>
<p>缺点：</p>
<p>产品主要还是以嵌入式开发为主，<strong>CPU</strong>、内存等资源资源有限，也没有相关逻辑代码，没有第三方的接口可用，实现起来反而会比前端实现更复杂。</p>
<h4 id="浏览器端生成"><a href="#浏览器端生成" class="headerlink" title="浏览器端生成"></a>浏览器端生成</h4><ol>
<li>activex方式：使用js/vbs调用excel对象。            （ie+excel）<br>e.g. var oXL = new ActiveXObject(“Excel.Application”); </li>
<li>ie命令方式：将html或是csv输出到open的window，然后使用execCommand的saveas命令，存为csv或xls。             (ie only)<br>e.g. xlsWin.document.execCommand(‘Saveas’, true, inName);</li>
<li>服务器端中转方式：将html的table或是拼接的csv传到服务器端，服务器端再按照Content-Type:application/vnd.ms-excel返回，浏览器就会按excel方式处理。     (all)<br>e.g. Response.contentType= “application/vnd.ms-excel ”</li>
<li>data协议方式：对于支持data协议的浏览器，可以将html或是csv先用js base64处理，然后前缀data:application/vnd.ms-excel;base64,，即可使浏览器将其中的数据当做excel来处理，浏览器将提示下载或打开excel文件,可惜的是ie不支持 。extjs的官网有一个grid的plugin就是采用该做法。(except IE)<br>e.g. var uri = ‘data:application/vnd.ms-excel;base64</li>
</ol>
<h4 id="浏览器端生成的缺陷"><a href="#浏览器端生成的缺陷" class="headerlink" title="浏览器端生成的缺陷"></a>浏览器端生成的缺陷</h4><ol>
<li><p>activex方式：使用js/vbs调用excel对象。            （ie+excel）</p>
<p>缺点：安全性差，数据流会被截取；需要应用配合，局限性大。</p>
</li>
<li><p>ie命令方式：将html或是csv输出到open的window，然后使用execCommand的saveas命令，存为csv或xls。                                               (ie only)</p>
<p>  缺点：只支持ie</p>
</li>
<li><p>服务器端中转方式：将html的table或是拼接的csv传到服务器端，服务器端再按照Content-Type:application/vnd.ms-excel返回，浏览器就会按excel方式处理。 (all)</p>
<p> 缺点：我司框架结构比较特殊，无法简单运用，该方法一般用于独立的js和asp页面，通用性较差。需要增加通信流程，实现复杂化。</p>
<ol>
<li>data协议方式：对于支持data协议的浏览器，可以将html或是csv先用js base64处理，然后前缀data:application/vnd.ms-excel;base64,，即可使浏览器将其中的数据当做excel来处理，浏览器将提示下载或打开excel文件 。(except IE)<br>缺点：ie不支持；模板中的excel格式无法进行复杂化自定义。</li>
</ol>
</li>
</ol>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>IE浏览器，采用方案2</p>
<p>非IE浏览器，采用方案4</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h4><blockquote>
<p>分为两步：getTblData() + doFileExport()</p>
</blockquote>
<h5 id="getTblData"><a href="#getTblData" class="headerlink" title="getTblData()"></a>getTblData()</h5><ul>
<li>检查输入框、单选框</li>
<li>检查colspan</li>
<li>间隔为\t，换行\r\n</li>
</ul>
<h5 id="doFileExport"><a href="#doFileExport" class="headerlink" title="doFileExport()"></a>doFileExport()</h5><ul>
<li>建一个隐藏的iframe</li>
<li>往iframe中写字符串，执行Saveas命令</li>
</ul>
<h4 id="方案4"><a href="#方案4" class="headerlink" title="方案4"></a>方案4</h4><p>URL拼接下载</p>
<ul>
<li>有一个固定的url模版，用于格式化表格</li>
<li>建一个链接，并指定href为固定的uri+格式化后的字符串</li>
<li>模拟点击链接</li>
</ul>
<h2 id="2-Canvas兼容"><a href="#2-Canvas兼容" class="headerlink" title="2. Canvas兼容"></a>2. Canvas兼容</h2><blockquote>
<p>目标：兼容IE6、IE7、IE8，需要html5.js + excanvas.js</p>
</blockquote>
<h3 id="html5-js"><a href="#html5-js" class="headerlink" title="html5.js"></a>html5.js</h3><ol>
<li>IE8无法识别html5标签，这些标签在IE8下无效果；</li>
<li>document.createElement();</li>
<li>设置css属性等；</li>
</ol>
<p>如<code>&lt;article&gt;</code></p>
<h3 id="excanvas-js-Google发起"><a href="#excanvas-js-Google发起" class="headerlink" title="excanvas.js(Google发起)"></a>excanvas.js(Google发起)</h3><p>工作原理：</p>
<ul>
<li>使用VML对象来实现canvas的方法；</li>
<li>加载库文件时，遍历网页中所有的canvas同时将canvas的方法赋给遍历得到的所有结果；</li>
</ul>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code class="javascript">var canvasId = “canvasArea”;
window.G_vmlCanvasManager.initElement(canvasId);

var els = document.getElementsByTagName(&#39;canvas&#39;);
for (var i = 0; i &lt; els.length; i++)
{
    if (this.canvasId == els[i].id)
    {
        this.can = window.G_vmlCanvasManager.initElement(els[i]);
    }
}
</code></pre>
<p>原方法：</p>
<pre><code class="javascript">var G_vmlCanvasManager_ = {
  init: function(opt_doc) {
    var doc = opt_doc || document;
    // Create a dummy element so that IE will allow canvas elements to be
    // recognized.
    doc.createElement(&#39;canvas&#39;);
    doc.attachEvent(&#39;onreadystatechange&#39;, bind(this.init_, this, doc));
  },

  init_: function(doc) {
    // find all canvas elements
  },
  initElement: function(el) {
    if (!el.getContext) {
      el.getContext = getContext;

      // Add namespaces and stylesheet to document of the element.
      addNamespacesAndStylesheet(el.ownerDocument);
    }
  };
</code></pre>
<h2 id="3-盒模型介绍"><a href="#3-盒模型介绍" class="headerlink" title="3. 盒模型介绍"></a>3. 盒模型介绍</h2><h3 id="IE6怪异盒模型"><a href="#IE6怪异盒模型" class="headerlink" title="IE6怪异盒模型"></a>IE6怪异盒模型</h3><blockquote>
<p>在IE6下，会以盒模型的宽度 = margin + width或者padding+border（两者取其大者）</p>
</blockquote>
<p>解决方法：</p>
<ol>
<li>将页面设为“标准模式”。添加对应的dtd标识，如：&lt;!DOCTYPE html<strong>&gt;</strong>–推荐 </li>
</ol>
<ol>
<li>使用hack或者在外面套上一层wrapper。 </li>
</ol>
<h3 id="important研究"><a href="#important研究" class="headerlink" title="!important研究"></a>!important研究</h3><p>并不是IE6不支持!important，而是它会按照样式声明顺序后出现的覆盖前面的，此时它已经不认识!important了，它六亲不认了。这正是广为流传的IE6 hack之一。</p>
<h3 id="Block-Formatting-Context"><a href="#Block-Formatting-Context" class="headerlink" title="Block Formatting Context"></a>Block Formatting Context</h3><p>创建了BFC的元素规定了内部的块级盒如何布局，并且使该盒子在页面上形成一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。</p>
<h4 id="创建块格式化上下文"><a href="#创建块格式化上下文" class="headerlink" title="创建块格式化上下文"></a>创建块格式化上下文</h4><ul>
<li>根元素或其它包含它的元素</li>
<li>浮动 (元素的 float 不为 none)</li>
<li>绝对定位元素 (元素的 position 为 absolute 或 fixed)</li>
<li>行内块 inline-blocks (元素的 display: inline-block)</li>
<li>表格单元格 (元素的 display: table-cell，HTML表格单元格默认属性)</li>
<li>表格标题 (元素的 display: table-caption, HTML表格标题默认属性)</li>
<li>overflow 的值不为 visible的元素</li>
<li>弹性盒子 flex boxes (元素的 display: flex 或 inline-flex)</li>
</ul>
<h4 id="块格式化上下文表现"><a href="#块格式化上下文表现" class="headerlink" title="块格式化上下文表现"></a>块格式化上下文表现</h4><ul>
<li>内部的Box会在垂直方向，从顶部开始一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加</li>
<li>每个元素的margin 子元素盒子的左边， 与包含块border 父元素盒的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box叠加。</li>
<li>计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<blockquote>
<p><strong>margin塌陷的解释</strong> </p>
<p>所谓的塌陷其实是两个BFC的相邻盒或者父子盒相互作用时产生的。在形成BFC的两个盒子会取两个盒子相邻边的最大margin作为相邻边的共用maring。</p>
</blockquote>
<h2 id="4-title2-0页面加载流程问题"><a href="#4-title2-0页面加载流程问题" class="headerlink" title="4. title2.0页面加载流程问题"></a>4. title2.0页面加载流程问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><pre><code class="css">/* Basic.htm中: */
body{
    background-color:#1c1c1c;
}

/* 和BasicPreview.htm中*/

body{
    background-color:#000000;
}
</code></pre>
<p>权值是相同的，理论上后加载的BasicPreview.htm中的css的优先级高于Basic.htm中css样式。但现在却出现了Basic.htm优先级高的问题。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经排查：2016年12月20日，Jenkins服务器修复了不能调用Java的问题，导致压缩后的htm文件js、css和html各部分顺序发生变化。原来没有压缩或者tftp传输没有问题。预览页面背景色涉及Basic.htm和BasicPreview.htm。原来这两个htm中的顺序是js-&gt;css-&gt;html,压缩后抓包看到顺序变为html-&gt;js-&gt;css。</p>
<p>压缩后的Basic.htm先加载，html在页面中生成div容器等dom，css在html后面自然也在div的后面；BasicPreview.htm中的html和css载到Basic.htm的div容器中。所以此时BasicPreview.htm中的css出现在Basic.htm的css前，导致了Basic.htm中css样式优先级高于BasicPreview.htm中的css。</p>
<p>解决方法：在时BasicPreview.htm中的相关css使用“!important”规则，来提高优先级。</p>
<h3 id="HTML页面加载和解析流程"><a href="#HTML页面加载和解析流程" class="headerlink" title="HTML页面加载和解析流程"></a>HTML页面加载和解析流程</h3><ol>
<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。</li>
<li>浏览器开始载入html代码，发现<head>标签内有一个<link>标签引用外部CSS文件。</head></li>
<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件。</li>
<li>浏览器继续载入html中<body>部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。</body></li>
<li>浏览器在代码中发现一个<img>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。</li>
<li>浏览器发现了一个包含一行Javascript代码的<code>&lt;script&gt;</code>标签，赶快运行它。</li>
<li>Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<code>&lt;style&gt;</code>（style.display=”none”）。杯具啊，突然就少了这么一个元<br>素，浏览器不得不重新渲染这部分代码。</li>
<li>终于等到了<code>&lt;/html&gt;</code>的到来，浏览器泪流满面…… </li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。</li>
<li>浏览器召集了在座的各位<div><span><ul><li>们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>
</ul></span></div></li></ol>
<h3 id="如何加快HTML页面加载速度"><a href="#如何加快HTML页面加载速度" class="headerlink" title="如何加快HTML页面加载速度"></a>如何加快HTML页面加载速度</h3><ol>
<li>页面减肥：<br>a. 页面的肥瘦是影响加载速度最重要的因素。<br>b. 删除不必要的空格、注释。<br>c. 将inline的script和css移到外部文件。<br>d. 可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具来给JavaScript减肥。</li>
<li>减少文件数量：<br>a. 减少页面上引用的文件数量可以减少HTTP连接数。<br>b. 许多JavaScript、CSS文件可以合并最好合并，把自己的JavaScript. functions和Prototype.js合并到一个base.js文件里去了。</li>
<li>减少域名查询：<br>a. DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好。</li>
<li>缓存重用数据：<br>a. 对重复使用的数据进行缓存。</li>
</ol>
<ol>
<li>优化页面元素加载顺序：<br>a. 首先加载页面最初显示的内容和与之相关的JavaScript和CSS，然后加载HTML相关的东西，像什么不是最初显示相关的图片、flash、视频等很肥的资源就最后加载。</li>
<li>减少inline JavaScript的数量：<br>a. 浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大。<br>b. 不要使用document.write()这种输出内容的方法，使用现代W3C DOM方法来为现代浏览器处理页面内容。</li>
<li>使用现代CSS和合法的标签：<br>a. 使用现代CSS来减少标签和图像，例如使用现代CSS+文字完全可以替代一些只有文字的图片。<br>b. 使用合法的标签避免浏览器解析HTML时做“error correction”等操作，还可以被HTML Tidy来给HTML减肥。</li>
<li>Chunk your content：<br>a. 不要使用嵌套table，而使用非嵌套table或者div。将基于大块嵌套的table的layout分解成多个小table，这样就不需要等到整个页面（或<br>大table）内容全部加载完才显示。</li>
<li>指定图像和table的大小：<br>a. 如果浏览器可以立即决定图像或table的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作。<br>b. 这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变。<br>c. image使用height和width。</li>
</ol>
<h2 id="5-自动化测试"><a href="#5-自动化测试" class="headerlink" title="5. 自动化测试"></a>5. 自动化测试</h2><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><ul>
<li>Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。它支持<strong>Firefox</strong>、<strong>ie</strong>、<strong>Mozilla</strong>等众多浏览器。它同时支持<strong>JAVA</strong>、<strong>C#</strong>、<strong>Ruby</strong>、<strong>Python</strong>、<strong>PHP</strong>、<strong>Perl</strong>等众多的主流语言开发测试用例。</li>
</ul>
<h3 id="webdriver"><a href="#webdriver" class="headerlink" title="webdriver"></a>webdriver</h3><ul>
<li>属于selenium的工具包</li>
<li>WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver针对各个浏览器而开发，取代了嵌入到被测Web应用中的JavaScript。</li>
</ul>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><pre><code class="python">#!/usr/bin/env python 
# -*- coding: UTF-8 -* 
import time 
from selenium import webdriver 
from selenium.webdriver.common.keys import Keys 
print &#39;----- STEP1: Open the browser -----&#39; 
browser = webdriver.Chrome() 
print &#39;----- STEP2: Get the url:http://tp-link.net/ -----&#39; 
browser.get(&#39;http://tp-link.net/&#39;) 
assert u&#39;内网导航&#39; in browser.title 
print &#39;----- STEP3: Find the element -----&#39; 
elem = browser.find_element_by_name(&#39;searchword&#39;)  # Find the search box 
print &#39;----- STEP4: Send keys to the element -----&#39; 
elem.send_keys(&#39;seleniumhq&#39; + Keys.RETURN) 
time.sleep(30) 
print &#39;----- STEP5: Close the browser -----&#39; 
browser.quit()
</code></pre>
<p>程序说明: 打开chrome浏览器，跳转内网<a href="http://tp-link.net/" target="_blank" rel="external">http://tp-link.net/</a>,  输入’seleniumhq’，按下ENTER</p>
<h3 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h3><p>从html中提取控件的属性，然后通过webdriver的接口去定位这些控件，从而对控件进行各种操作。</p>
<p>WebDriver提供八种定位方法：</p>
<ul>
<li>find _element_by_id()</li>
<li>…</li>
</ul>
<h3 id="关键对象"><a href="#关键对象" class="headerlink" title="关键对象"></a>关键对象</h3><ul>
<li>driver</li>
<li>element</li>
</ul>
<h2 id="6-Cookie-amp-Session-amp-Cache-机制介绍"><a href="#6-Cookie-amp-Session-amp-Cache-机制介绍" class="headerlink" title="6. Cookie &amp; Session &amp; Cache 机制介绍"></a>6. <strong>Cookie &amp; Session &amp; Cache </strong>机制介绍</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="Cookie格式"><a href="#Cookie格式" class="headerlink" title="Cookie格式"></a>Cookie格式</h4><pre><code class="http">Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE
</code></pre>
<ul>
<li>在字符串“NAME=VALUE”中，不含分号、逗号和空格等字符。</li>
<li>DATE必须以特定的格式来书写：星期几，DD－MM－YY HH:MM:SS GMT</li>
<li>如果Path属性的值为“/”，则Web服务器上所有的WWW资源均可读取该Cookie。</li>
<li>Secure：在Cookie中标记该变量，表明只有当浏览器和Web Server之间的通信协议为加密认证协议时，浏览器才向服务器提交相应的Cookie。</li>
</ul>
<h4 id="Cookie介绍"><a href="#Cookie介绍" class="headerlink" title="Cookie介绍"></a>Cookie介绍</h4><ul>
<li>Cookie是保存在客户端的一组数据，主要用来保存用户名等个人信息。</li>
<li>我们可以存放非敏感的用户信息，保存时间可以根据需要设置</li>
<li>如果没有设置Cookie失效日期，它的生命周期保存到关闭浏览器为止</li>
<li>Cookie对象的Expires属性设置为MinValue表示永不过期</li>
<li>Cookie存储的数据量受限制，大多数的浏览器为4K因此不要存放大数据，很多浏览器都限制一个站点最多保存20个cookie。</li>
</ul>
<h4 id="Cookie的用法"><a href="#Cookie的用法" class="headerlink" title="Cookie的用法"></a>Cookie的用法</h4><p>Cookie是用于维持服务端会话状态的。</p>
<p>客户端写Cookie：</p>
<pre><code class="javascript">document.cookie = &quot;Authorization=&quot;+escape(auth)+&quot;;path=/&quot;;
document.cookie = “SubType=pcSub;path=/&quot;;
</code></pre>
<p>客户端读Cookie：</p>
<pre><code class="javascript">var startIndex = document.cookie.indexOf(“SubType=&quot;);
var  cookieSubType = document.cookie.substring(startIndex);
var startIndex = cookieLoginTime.indexOf(&quot;=&quot;);
cookieSubType = cookieLoginTime.substring(startIndex +1);
var endIndex = cookieLoginTime.indexOf(&quot;;&quot;);            
cookieSubType = cookieSubType.substring(startIndex, endIndex);
</code></pre>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="Session介绍"><a href="#Session介绍" class="headerlink" title="Session介绍"></a>Session介绍</h4><p>Session是由应用服务器维持的一个服务器端的存储空间，用SessionID作为标识符来存取服务器端的Session存储空间。</p>
<h4 id="Session作用"><a href="#Session作用" class="headerlink" title="Session作用"></a>Session作用</h4><p>Session 对象用于存储用户的信息，存储于 session 对象中的变量持有单一用户的信息，并且对于一个应用程序中的所有页面都是可用的。</p>
<h4 id="Session用法"><a href="#Session用法" class="headerlink" title="Session用法"></a>Session用法</h4><h5 id="借助Cookie"><a href="#借助Cookie" class="headerlink" title="借助Cookie"></a>借助Cookie</h5><p>SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。</p>
<h5 id="url重写"><a href="#url重写" class="headerlink" title="url重写"></a>url重写</h5><p>  通过向 URL 连接添加参数，把 session ID 作为值包含在连接中。</p>
<pre><code class="javascript">location.href = &quot;linkStatus.htm?clrStats=1&amp;session_id=&quot; + session_id;

w(&#39;&lt;input name=&quot;session_id&quot; id=&quot;session_id&quot; type=&quot;hidden&quot; value=&quot;&#39;+ session_id +&#39;&quot;&gt;&#39;);
</code></pre>
<h3 id="为什么会有cookie和session"><a href="#为什么会有cookie和session" class="headerlink" title="为什么会有cookie和session"></a>为什么会有cookie和session</h3><ul>
<li>http是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息。</li>
<li>session就是一种保存上下文信息的机制，它是针对每一个用户的，变量的值保存在服务器端，通过SessionID来区分不同的客户,session是以cookie或URL重写为基础的，默认使用cookie来实现，系统会创造一个名为JSESSIONID的输出cookie，我们叫做session cookie,以区别persistent cookies,也就是我们通常所说的cookie。</li>
<li>注意session cookie是存储于浏览器内存中的，并不是写到硬盘上的，这也就是我们刚才看到的JSESSIONID，我们通常情是看不到JSESSIONID的，但是当我们把浏览器的cookie禁止后，web服务器会采用URL重写的方式传递Sessionid，我们就可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串。 </li>
</ul>
<h3 id="为什么Session比cookie更安全？"><a href="#为什么Session比cookie更安全？" class="headerlink" title="为什么Session比cookie更安全？"></a>为什么Session比cookie更安全？</h3><p>session针对某一次会话而言，会话结束session也就随着消失了，而(persistent) cookie只是存在于客户端硬盘上的一段文本（通常是加密的），而且可能会遭到cookie欺骗以及针对cookie的跨站脚本攻击，自然不如session安全了。 </p>
<h3 id="跨窗口使用"><a href="#跨窗口使用" class="headerlink" title="跨窗口使用"></a>跨窗口使用</h3><p>通常session cookie是不能跨窗口使用的，当你新开了一个浏览器窗口进入相同页面时，系统会赋予你一个新的sessionid，这样我们信息共享的目的就达不到了，此时我们可以先把sessionid保存在persistent cookie中，然后在新窗口中读出来，就可以得到上一个窗口SessionID了，这样通过session cookie和persistent cookie的结合我们就实现了跨窗口的session tracking（会话跟踪）。 </p>
<h3 id="Session-vs-Cookie总结"><a href="#Session-vs-Cookie总结" class="headerlink" title="Session vs Cookie总结"></a>Session vs Cookie总结</h3><ul>
<li>cookie存放在客户的浏览器上，session放在服务器上</li>
<li>cookie不是很安全，考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用cookie 。</li>
</ul>
<p>建议：将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><h4 id="Cache简介"><a href="#Cache简介" class="headerlink" title="Cache简介"></a>Cache简介</h4><h5 id="浏览器缓存（IE为例）"><a href="#浏览器缓存（IE为例）" class="headerlink" title="浏览器缓存（IE为例）"></a>浏览器缓存（IE为例）</h5><p>为了提高访问网页的速率，IE浏览器会采用累积式加速的方法，将曾经访问的网页内容存放在电脑里。这个存放空间，就称它为IE缓存。以后每次访问网站时，IE会首先搜索这个目录，其中已经有访问过的内容，那IE就不必从网上下载，而直接从缓存中调出来，从而提高了访问网站的速率</p>
<h5 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h5><p>代理缓存是共享缓存的一种，不是只有一个人正在使用它们，而是同时又大量的用户，因为他们可以非常好的节约了带宽和网页延迟。</p>
<h4 id="网站缓存的工作原理"><a href="#网站缓存的工作原理" class="headerlink" title="网站缓存的工作原理"></a>网站缓存的工作原理</h4><ul>
<li><p>header响应头部分可以设置了是否进行缓存.</p>
</li>
<li><p>如果请求是经过HTTP 认证或是SSL安全链接 (i.e., HTTPS),缓存也无法工作.</p>
</li>
<li><p>如果符合以下条件，缓存机制的启用是通过页面的刷新引起(不需要经过检测服务器就可以直接发送到客户端)：</p>
</li>
<li><ul>
<li>时间没有超过已设置的缓存页面过期时间或者其它类似 age-controlling（指示客户机可以接收生存期不大于指定时间的响应） 的设置。</li>
<li>缓存是最近请求时保存的，或是缓存修改的时间也是新的。</li>
</ul>
</li>
<li><p>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified（Etag）声明，则再次向web服务器请求时带上头 <strong>If-Modified-Since</strong>（<strong>If-None-Match</strong>），表示客户端请求时间。<strong>web</strong>服务器收到请求后发现有头<strong>If-Modified-Since</strong>（<strong>If-None-Match</strong>）则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p>
</li>
<li><p>特定情况— 比如, 与服务器断开连接 — 缓存会直接作为请求的响应.</p>
</li>
</ul>
<h2 id="7-settimeout介绍"><a href="#7-settimeout介绍" class="headerlink" title="7. settimeout介绍"></a>7. settimeout介绍</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>setInterval()，setTimeout() 方法是浏览器 window 对象提供，所以第一个参数函数中的this指向window对象，这跟变量的作用域有关。 </p>
<p>Function.prototype.bind() 方法，该方法允许显式地指定函数调用时 this 所指向的值 。</p>
<h3 id="js事件线程机制"><a href="#js事件线程机制" class="headerlink" title="js事件线程机制"></a>js事件线程机制</h3><p>浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：javascript引擎线程，GUI渲染线程，浏览器事件触发线程。</p>
<ul>
<li>javascript引擎是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。js的工作机制是：当线程中没有执行任何同步代码的前提下才会执行异步代码</li>
<li>GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li>
<li>事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。（当线程中没有执行任何同步代码的前提下才会执行异步代码）</li>
</ul>
<h2 id="8-jquery选择器"><a href="#8-jquery选择器" class="headerlink" title="8. jquery选择器"></a>8. jquery选择器</h2><h3 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h3><p>《jquery选择器.ppt》P7</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code class="javascript">//如果硬盘格式化中，无法进行格式化操作
$(&quot;td:contains(&#39;+label.formatting+&#39;)&quot;).next().children().css(&quot;display:none&quot;)

//点击格式化按钮，呈现格式化进度条动画
$(&quot;#diskTable tbody tr:eq(&#39;+(index+1)+&#39;) td:last-child&quot;)
</code></pre>
<h2 id="9-页面布局"><a href="#9-页面布局" class="headerlink" title="9.页面布局"></a>9.页面布局</h2><h3 id="布局模型"><a href="#布局模型" class="headerlink" title="布局模型"></a>布局模型</h3><ol>
<li>流动模型（Flow）</li>
<li>浮动模型 (Float)</li>
<li>层模型（Layer）</li>
</ol>
<h3 id="布局模型：Flow"><a href="#布局模型：Flow" class="headerlink" title="布局模型：Flow"></a>布局模型：Flow</h3><p>流动是默认的网页布局模式，也是HTML页面默认的布局模型。</p>
<p>特征：</p>
<ol>
<li>块状元素都会在父元素内自上而下按照顺序垂直分布，宽度为100%，每个块状元素均占据一行。</li>
</ol>
<ol>
<li>内联元素都会在父元素中从左到右水平分布显示，宽度由内容撑开。</li>
<li>内联块状元素在父元素中同一行分布，可设置宽度、高度、padding、margin。</li>
</ol>
<p>常用的块状元素有：</p>
<pre><code class="html">&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;
</code></pre>
<p>常用的内联元素有：</p>
<pre><code class="html">&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;
</code></pre>
<p>常用的内联块状元素有：</p>
<pre><code class="html">&lt;img&gt;、&lt;input&gt;
</code></pre>
<h3 id="布局模型：Float"><a href="#布局模型：Float" class="headerlink" title="布局模型：Float"></a>布局模型：Float</h3><p>使用浮动的元素必然是inline-block;</p>
<h3 id="布局模型：Layer"><a href="#布局模型：Layer" class="headerlink" title="布局模型：Layer"></a>布局模型：Layer</h3><p>层模型有三种形式：</p>
<ol>
<li><strong>绝对定位</strong>(position: absolute)</li>
<li><strong>相对定位</strong>(position: relative)</li>
<li><strong>固定定位</strong>(position: fixed)</li>
</ol>
<h4 id="布局模型：绝对定位"><a href="#布局模型：绝对定位" class="headerlink" title="布局模型：绝对定位"></a>布局模型：绝对定位</h4><p><strong>使用绝对定位的元素必然是inline-block;</strong></p>
<p>使用position:absolute可以为元素设置层模型中的绝对定位，该样式的作用：</p>
<ol>
<li>将元素从文档流中拖出来；</li>
<li>使用left、right、top、bottom属性<strong>相对于其最接近的一个具有定位属性的父包含块进行绝对定位。</strong>如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。</li>
</ol>
<h4 id="布局模型：相对定位"><a href="#布局模型：相对定位" class="headerlink" title="布局模型：相对定位"></a>布局模型：相对定位</h4><p>它通过left、right、top、bottom属性确定元素在<strong>正常文档流中</strong>的偏移位置。</p>
<p>相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于<strong>以前的位置移动</strong>，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p>
<h4 id="布局模型：固定定位"><a href="#布局模型：固定定位" class="headerlink" title="布局模型：固定定位"></a>布局模型：固定定位</h4><p>它的相对移动的坐标是视图（<strong>屏幕内的网页窗口</strong>）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响</p>
<h3 id="居中效果的实现"><a href="#居中效果的实现" class="headerlink" title="居中效果的实现"></a>居中效果的实现</h3><ol>
<li><p>水平居中</p>
<ul>
<li>行内或类行内元素：text-align:center</li>
<li>块级元素：设置 margin-left 和 margin-right 为 auto（前提是已经为元素设置了适当的 <code>width</code> 宽度，否则块级元素的宽度会被拉伸为父级容器的宽度）</li>
<li>float + left</li>
</ul>
</li>
<li><p>垂直居中</p>
<ul>
<li>行内或类行内元素 + 父元素高度确定<ul>
<li>单行行内或者文本元素：<ul>
<li>等值的 padding-top 和 padding-bottom</li>
<li><code>line-height</code> 和 <code>center</code> 相等</li>
</ul>
</li>
<li>多行文本<ul>
<li>等值 <code>padding-top</code> 和 <code>padding-bottom</code></li>
<li><code>table-cell</code> 的父级容器 +  <code>vertical-align</code></li>
<li>父级容器为 <code>display: flex</code> </li>
<li>幽灵元素：在垂直居中的元素上添加伪元素，设置伪元素的高等于父级容器的高，然后为文本添加 vertical-align: middle;</li>
</ul>
</li>
</ul>
</li>
<li>块级元素 + 已知元素的高度：top+height+margin-top</li>
<li>块级元素 + 未知元素的高度：top+<code>translate</code> 属性</li>
<li>flexbox</li>
</ul>
</li>
<li>水平且垂直居中</li>
</ol>
<ul>
<li>宽高固定元素：设定父级容器为相对定位的容器，设定子元素绝对定位的位置 <code>position: absolute; top: 50%; left: 50%</code>，最后使用负向 <code>margin</code> 实现水平和垂直居中，<code>margin</code> 的值为宽高（具体的宽高需要根据实际情况计算 <code>padding</code>）的一半。</li>
<li>宽高不固定元素：设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%。不同的是，接下来需要使用 transform: translate(-50%, -50%); 实现垂直居中</li>
<li>flexbox：justify-content+align-items</li>
</ul>
<h2 id="10-Vue-js"><a href="#10-Vue-js" class="headerlink" title="10. Vue.js"></a>10. Vue.js</h2><h3 id="Vue-Vs-React"><a href="#Vue-Vs-React" class="headerlink" title="Vue Vs React"></a>Vue Vs React</h3><p>相同点：</p>
<ul>
<li>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</li>
<li>中心思想相同：一切都是组件，组件实例之间可以嵌套。</li>
<li>都提供合理的钩子函数，可以让开发者定制化地去处理需求。</li>
<li>都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。</li>
<li>在组件开发中都支持mixins的特性。</li>
</ul>
<p>不同点：</p>
<ul>
<li>React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。</li>
<li>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作DOM。</li>
</ul>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ul>
<li>v-on  事件监听</li>
<li>v-bind 元素属性绑定</li>
</ul>
<p>在 Vue.js 中，父子组件的关系可以总结为 <strong>props down, events up</strong> 。</p>
<ul>
<li>使用 $on(eventName) 监听事件</li>
<li>使用 $emit(eventName) 触发事件</li>
</ul>
<h2 id="11-正则表达式介绍"><a href="#11-正则表达式介绍" class="headerlink" title="11. 正则表达式介绍"></a>11. 正则表达式介绍</h2><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>合法路径检测：</p>
<pre><code class="javascript">/^[^\\/:*?&quot;&#39;&lt;&gt;|%]+$/gi.test(val)
</code></pre>
<h2 id="12-IPC浏览器兼容性问题"><a href="#12-IPC浏览器兼容性问题" class="headerlink" title="12. IPC浏览器兼容性问题"></a>12. IPC浏览器兼容性问题</h2><h3 id="1-firefox兼容性问题"><a href="#1-firefox兼容性问题" class="headerlink" title="1. firefox兼容性问题"></a>1. firefox兼容性问题</h3><h4 id="1-1-firefox中float造成的异常"><a href="#1-1-firefox中float造成的异常" class="headerlink" title="1.1 firefox中float造成的异常"></a>1.1 firefox中float造成的异常</h4><p>清除浮动</p>
<h4 id="1-2-firefox下event缺失造成的异常"><a href="#1-2-firefox下event缺失造成的异常" class="headerlink" title="1.2 firefox下event缺失造成的异常"></a>1.2 firefox下event缺失造成的异常</h4><p>函数接口缺失event所致，window.event只能在IE下使用，而不能用在Firefox下，导致代码在stopProp处中止执行下面为body绑定点击事件的代码。</p>
<h4 id="1-3-firefox下iframe造成的异常"><a href="#1-3-firefox下iframe造成的异常" class="headerlink" title="1.3 firefox下iframe造成的异常"></a>1.3 firefox下iframe造成的异常</h4><p>firefox下iframe造成的异常，本质上是浏览器的bug。目前没有什么好的方法解决，只能避免采用iframe同时再使用某些属性。</p>
<h5 id="1-3-1-设置透明度被视频遮挡"><a href="#1-3-1-设置透明度被视频遮挡" class="headerlink" title="1.3.1 设置透明度被视频遮挡"></a>1.3.1 设置透明度被视频遮挡</h5><pre><code class="css">opacity:0.95;
filter:alpha(opacity=95);
</code></pre>
<h5 id="1-3-2-设置圆角被视频截成矩形"><a href="#1-3-2-设置圆角被视频截成矩形" class="headerlink" title="1.3.2 设置圆角被视频截成矩形"></a>1.3.2 设置圆角被视频截成矩形</h5><pre><code class="css">border-radius:12px;;
</code></pre>
<h4 id="1-4-冒泡事件"><a href="#1-4-冒泡事件" class="headerlink" title="1.4 冒泡事件"></a>1.4 冒泡事件</h4><pre><code class="javascript">/*绑定事件函数*/
this.attachEvnt = function(target, event, handle)
{
    if (event.indexOf(&quot;on&quot;) == 0)
    {
        event = event.substring(2);
    }

    if (document.body.attachEvent)
    {
        target.attachEvent(&quot;on&quot;+event, handle);
    }
    else
    {
        target.addEventListener(event, handle, false);
    }
};
</code></pre>
<h4 id="1-5-阻止事件传播"><a href="#1-5-阻止事件传播" class="headerlink" title="1.5 阻止事件传播"></a>1.5 阻止事件传播</h4><pre><code class="javascript">/*stop propagation of event */
this.stopProp = function (event)
{
    event = event || window.event;
    if (undefined == event)
    {
        return;
    }

    if (event.stopPropagation)
    {
        event.stopPropagation();
    }
    else
    {
        event.cancelBubble = true;
    }
};
</code></pre>
<h3 id="2-IE8兼容性问题"><a href="#2-IE8兼容性问题" class="headerlink" title="2. IE8兼容性问题"></a>2. IE8兼容性问题</h3><h4 id="2-1-div-设为z-index经常无法覆盖下面元素"><a href="#2-1-div-设为z-index经常无法覆盖下面元素" class="headerlink" title="2.1 div 设为z-index经常无法覆盖下面元素"></a>2.1 div 设为z-index经常无法覆盖下面元素</h4><p>当div使用transparent时，或不使用时（默认透明）IE8下z-index经常会出现无效问题。无法起到覆盖作用。</p>
<p>解决方法：将div的背景颜色设为背景色。</p>
<h4 id="2-2-变量未声明"><a href="#2-2-变量未声明" class="headerlink" title="2.2 变量未声明"></a>2.2 变量未声明</h4><p>变量未声明在IE11下为全局变量。但在IE8下会在此中断往下执行javascript，导致页面异常。</p>
<h4 id="2-3-使用absolute"><a href="#2-3-使用absolute" class="headerlink" title="2.3 使用absolute"></a>2.3 使用absolute</h4><p>使用absolute进行绝对定位时，元素的位置未通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</p>
<h4 id="2-4-日期显示NaN问题"><a href="#2-4-日期显示NaN问题" class="headerlink" title="2.4 日期显示NaN问题"></a>2.4 日期显示NaN问题</h4><p>IE8下使用new Date()。设初始值时，日期会显示NaN</p>
<p>可使用parseISO8601()解决</p>
<h4 id="2-5-NAN和数字相加减导致的问题"><a href="#2-5-NAN和数字相加减导致的问题" class="headerlink" title="2.5 NAN和数字相加减导致的问题"></a>2.5 NAN和数字相加减导致的问题</h4><p>解决方案：针对不同的变量，建议采用不同的方法来解决。</p>
<ul>
<li>当被设置的值不是必需时如line-height，加减运算前可先进行判断，不为NAN再进行运算。</li>
<li>若控件中已经定义默认值，判断为NAN时可采用默认值来替代。</li>
</ul>
<h4 id="2-6-width不包括边框导致的缩放问题"><a href="#2-6-width不包括边框导致的缩放问题" class="headerlink" title="2.6 width不包括边框导致的缩放问题"></a>2.6 width不包括边框导致的缩放问题</h4><p>IE8/Firefox下缩放，拖动条最后一个元素输入框会异位，呈现在下一行。</p>
<p>原因：IE8/Firefox下缩放按照width缩放，测试发现width不包括边框，这样会带来：如果有border，那么放大后，实际的宽度会比正常放大的比例小。而缩小相反。此时父元素的width按同等比例缩小，会小于实际宽度。</p>
<p>解决方案：父元素的宽度不需要设置。</p>
<h4 id="2-7-innerHTML写操作权限问题"><a href="#2-7-innerHTML写操作权限问题" class="headerlink" title="2.7 innerHTML写操作权限问题"></a>2.7 innerHTML写操作权限问题</h4><p> 在IE8上修改table的innerHTML时，会出现“未知的运行时错误”。</p>
<p>原因：IE8在对innerHTML进行写操作的时候会检查element是否满足作为这些内容的容器的要求，在IE8上<tbody>,<table>,<tr>标签不满足这种要求。</tr></table></tbody></p>
<p>解决方案：避免直接对table的innerHTML进行操作，改为对其父容器进行操作</p>
<h3 id="3-IE6兼容性问题"><a href="#3-IE6兼容性问题" class="headerlink" title="3. IE6兼容性问题"></a>3. IE6兼容性问题</h3><h4 id="3-1-插件object占空间导致的布局异常"><a href="#3-1-插件object占空间导致的布局异常" class="headerlink" title="3.1 插件object占空间导致的布局异常"></a>3.1 插件object占空间导致的布局异常</h4><p>IE6预览界面object对象没有设置宽和高，但会有默认的宽度和高度。</p>
<h4 id="3-2-float折行-错位问题"><a href="#3-2-float折行-错位问题" class="headerlink" title="3.2 float折行/错位问题"></a>3.2 float折行/错位问题</h4><p>解决方法：</p>
<ol>
<li>尽量不使用浮动定位；</li>
<li>使用position定位，记得父元素使用相对定位，子元素使用绝对定位；</li>
<li>浮动的div尝试使用display:inline和overflow:hidden属性；</li>
<li>将使用右浮动的元素放到没有浮动元素的左边；将使用左浮动的元素放到没有使用浮动元素的右边。</li>
</ol>
<h4 id="3-3-经典问题-双边距问题"><a href="#3-3-经典问题-双边距问题" class="headerlink" title="3.3 经典问题:双边距问题"></a>3.3 经典问题:双边距问题</h4><p>给样式增加一条css样式：_display:inline;</p>
<h4 id="3-4-缩放页面，页面换行重合问题"><a href="#3-4-缩放页面，页面换行重合问题" class="headerlink" title="3.4 缩放页面，页面换行重合问题"></a>3.4 缩放页面，页面换行重合问题</h4><p>原因：在body上设置最小宽度在IE6下没有生效,测试发现expression表达式在IE6下可以正常执行（会不断重复计算），但是body属性只执行了一次，后续resize不会再执行expression表达式，转而设置body宽度为页面宽度，所以不能很好缩放。</p>
<p>解决：绕过该问题，改为在body的子元素Con上设置expression，可以解决问题，它会不断计算当前的最小宽度。</p>
<h4 id="3-5-text-indent位置偏移问题"><a href="#3-5-text-indent位置偏移问题" class="headerlink" title="3.5 text-indent位置偏移问题"></a>3.5 text-indent位置偏移问题</h4><p>在IE6/IE7中，text-indent会导致inline- block元素出现向左(text-indent的值为负时)或向右(text-indent值为正时)的偏移。</p>
<p>解决方法：在基本布局不变情况下，做IE6/7 hack：在CSS中添加 *margin-left:-14px;</p>
<h4 id="3-6-z-index无论设置多高都无效问题"><a href="#3-6-z-index无论设置多高都无效问题" class="headerlink" title="3.6 z-index无论设置多高都无效问题"></a>3.6 z-index无论设置多高都无效问题</h4><p>这种情况发生的条件有三个：</p>
<ol>
<li>父标签 position属性为relative；</li>
<li>问题标签无position属性（不包括static）；</li>
<li>问题标签含有浮动(float)属性。</li>
</ol>
<p>解决方法：</p>
<ol>
<li>position:relative改为position:absolute；</li>
<li>去除浮动；</li>
<li>浮动元素添加position属性（如relative，absolute等）。</li>
</ol>
<p>原因：父标签position属性为relative或absolute时，子标签的absolute属性是相对于父标签而言的。而在IE6下，层级的表现有时候不是看子标签的z-index多高，而要看它们的父标签的z-index谁高谁低。所以在满足上述条件同时，要保证父标签的z-index高。</p>
<h3 id="4-各浏览器共有性的兼容性问题"><a href="#4-各浏览器共有性的兼容性问题" class="headerlink" title="4. 各浏览器共有性的兼容性问题"></a>4. 各浏览器共有性的兼容性问题</h3><h4 id="4-1-父元素为inline-block，子元素之间会多出4px的间距"><a href="#4-1-父元素为inline-block，子元素之间会多出4px的间距" class="headerlink" title="4.1 父元素为inline-block，子元素之间会多出4px的间距"></a>4.1 父元素为inline-block，子元素之间会多出4px的间距</h4><p>原因： inline 元素中间的空白符引起的，解决办法：就是去掉空白符<br>解决方法：</p>
<p>方法一：改变HTML结构。具体方式较多，但需要修改dom结构，不实用。</p>
<p>方法二：负的margin。如果你的父元素设置的字号不一样，可能你的“-4px”就不能解决问题。况且在Chrome中你需要另外设置一个负的margin值才能实现同等的效果，不实用。</p>
<p>方法三：设置父元素的字体为“0”，然后在“inline-block”元素上重置字体需要的大小。这样处理在Firexfox,chrome等浏览器下是达到了效果，可是在Safari下可问题依然存在，根据ipc支持性，认为相对较好。</p>
<p>方法四：丢失结束标签。这种方法又回到了方法一，还是有一个前提，那就是“DOCTYPE”要选择对，在“XHTML”下可就问题又出来了，不实用。</p>
<p>方法五：通过jQuery来改变“nodeType”的值。不实用</p>
<p><strong>全兼容的样式解决方法：在父元素中设置font-size:0,用来兼容chrome，而使用letter-space:-N px来兼容safari:</strong></p>
<h2 id="13-遮挡框"><a href="#13-遮挡框" class="headerlink" title="13. 遮挡框"></a>13. 遮挡框</h2><pre><code class="html">&lt;div style=&quot;position:relative;*z-index:1;&quot;&gt;
    &lt;div id=&quot;hidebg&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">#hidebg{
    position:absolute;
    background-color:#F5F6FA;
    left:0px;
    width:100%;
    filter:alpha(opacity=50);
    opacity:0.5;
    display:none;
    z-Index:1000;
}
</code></pre>
<pre><code class="javascript">function exSwitchHd(state)
{
  var hideobj = document.getElementById(&quot;hidebg&quot;);

  if(0 == state)
  {
    hideobj.style.display = &quot;block&quot;;
    hideobj.style.height = getoffset(id(&quot;save&quot;)).top - getoffset(id(&quot;actionBarDiv&quot;)).top + &quot;px&quot;;
  }
  else
  {
      hideobj.style.display = &quot;none&quot;;
  }
}
</code></pre>
<h2 id="14-闭包"><a href="#14-闭包" class="headerlink" title="14. 闭包"></a>14. 闭包</h2><pre><code class="javascript">(function(path)
 {
      table.rows[parseInt(indexArry[downIndex],10) + 1].cells[6].childNodes[1].onclick = function()
  {
    plugin.openFileStorageFolder(path);
  }
}(path));
</code></pre>
<h2 id="15-canvas实现图表"><a href="#15-canvas实现图表" class="headerlink" title="15. canvas实现图表"></a>15. canvas实现图表</h2><pre><code class="javascript">function createChart(chartStyle, chartInfo)
{
    var chart =
    {
        /*用于配置图表的必选参数*/
        canvasId:undefined,//绘制的图表所在的canvas的ID
        chartStyle : chartStyle,//当前选中的图表类型 barChart || lineChart
        xyData:[],//用于绘制图形的XY轴数据

        /*可选，假设在同一张图上绘制折线图和柱形图，则折线图的点对应于柱形图顶部中心点*/
        fontSize:0.017,//填充的字体大小和canvas整体长度的比例，包括XY轴数据，柱形图和折线图上的信息
        graphName:undefined,//图表标题
        xValuePosition:&quot;center&quot;,//假设绘制柱形图，X轴数据需要和柱形中轴线还是右边对齐 right || center

        xyColor:&quot;#606060&quot;,//XY轴的颜色
        lineColor:&quot;#006ACC&quot;,//折线图线条的颜色
        barColorFill:&quot;#006ACC&quot;,//柱形图填充的颜色
        barColorStroke:&quot;#006ACC&quot;,//柱形图边框颜色
        dotColor:&quot;#006ACC&quot;,//折线图中数据点的颜色
        xyDataColor:&quot;#909090&quot;,//XY轴上数值以及文字信息的颜色
        dataColor:&quot;#E1E1E1&quot;,//数据点上数值的颜色
        chartBackColor:&quot;transparent&quot;,//图表背景颜色

        chartPaddingLeft:0.044,//图表左边距和图表总宽度的比例
        chartPaddingRight:0.022,//图表右边距和图表总宽度的比例
        chartPaddingTop:0.07,//图表上边距和图表总高度的比例
        chartPaddingBottom:0.101,//图表下边距和图表总高度的比例
        barWidth:0.8,//柱形宽度和相邻柱形间距的比例，默认为0.8
        leftDis:0.5,//最左端柱形离Y轴距离和相邻柱形之间的距离的比例，默认为0.5
        smallPaddingWithY:0,//用于微调柱形和Y轴之间的距离的像素值
        smallPaddingBetween:0,//用于微调柱形之间的距离的像素值

        init:function(chartInfo)
        {
            for (var prop in chartInfo)
            {
                if (undefined != chartInfo[prop])
                {
                    this[prop] = chartInfo[prop];
                }
            }

            /*支持动态生成的canvas*/
            var browser = navigator.appName;

            if (&quot;Microsoft Internet Explorer&quot; == browser)
            {
                var b_version = navigator.appVersion;
                var version = b_version.split(&quot;;&quot;);
                var trim_Version = version[1].replace(/[ ]/g,&quot;&quot;);

                if ((&quot;MSIE6.0&quot; == trim_Version) || (&quot;MSIE7.0&quot; == trim_Version) || (&quot;MSIE8.0&quot; == trim_Version))
                {
                    var els = document.getElementsByTagName(&#39;canvas&#39;);
                    for (var i = 0; i &lt; els.length; i++)
                    {
                        if (this.canvasId == els[i].id)
                        {
                            this.can = window.G_vmlCanvasManager.initElement(els[i]);
                        }
                    }
                }
                else
                {
                    this.can = document.getElementById(this.canvasId);
                }
            }
            else
            {
                this.can = document.getElementById(this.canvasId);
            }

            this.can.style.display = &quot;block&quot;;
            this.canctx = this.can.getContext(&quot;2d&quot;);

            /*比例转化为像素值*/
            this.chartPaddingLeft = parseInt(this.chartPaddingLeft * this.can.width);
            this.chartPaddingRight = parseInt(this.chartPaddingRight * this.can.width);
            this.chartPaddingTop = parseInt(this.chartPaddingTop * this.can.height);
            this.chartPaddingBottom = parseInt(this.chartPaddingBottom * this.can.height);
            this.fontSize = parseInt(this.fontSize * this.can.width);

            /*设置用于调节fillText中文字位置的字体宽度和高度以及字体颜色*/
            this.fontWidth = this.fontSize;
            this.fontHeight = this.fontSize * 1.2;
            this.canctx.font = this.fontSize + &quot;px 微软雅黑&quot;;

            /*清除原有画布内容*/
            this.canctx.clearRect(0, 0, this.can.width, this.can.height);

            this.drawGraph(this.xyData, this.chartStyle, this.chartPaddingLeft, this.chartPaddingRight, this.chartPaddingTop, this.chartPaddingBottom, this.barWidth, this.leftDis, this.xValuePosition, this.can);
        },

        /*绘制XY轴以及坐标轴上的数值、图表的标题、图表的背景*/
        drawGraph:function(data, chartStyle, paddingLeft, paddingRight, paddingTop, paddingBottom, barWidth, leftDis, xValuePosition, can)
        {
            /*获取绘图需要的数据*/
            var perwidth = this.getXWidth(data, can.width, paddingLeft, paddingRight, barWidth, leftDis);//x 轴上两个数据点之间距离
            var floatExist = this.checkFloatExist(data);//搜索data中value值中是否有小数
            var yEmptyHeight = parseInt(0.07 * can.height);//用于放置Y轴备注信息的位置高度
            var yInfo = this.getYInfo(this.getMax(data), can.height, paddingBottom, paddingTop, yEmptyHeight, floatExist);
            var maxY = yInfo.maxY;//图表中Y轴所能表示的最大值
            var perY = yInfo.perY;//Y轴上每maxY所表示的像素值
            var tenTimes = yInfo.tenTimes;//Y轴显示的数据需要乘以十的倍数

            /*修改图表背景颜色*/
            if (&quot;transparent&quot; != this.chartBackColor)
            {
                can.style.background = this.chartBackColor;
            }

            this.drawCoordinate(data, paddingLeft, paddingRight, paddingTop, paddingBottom, barWidth, leftDis, xValuePosition, can, tenTimes, perwidth, yEmptyHeight, maxY, perY);

            /*绘制标题*/
            if (undefined != chartInfo[&quot;graphName&quot;])
            {
                this.drawGraphName(perY, can, paddingTop, paddingLeft, paddingRight);
            }

            /*绘制柱形或折线*/
            if (&quot;lineChart&quot; == chartStyle)
            {
                this.drawLine(data, paddingLeft, paddingBottom, perwidth, perY, barWidth, leftDis, tenTimes);
            }
            else if (&quot;barChart&quot; == chartStyle)
            {
                this.drawBar(data, paddingLeft, paddingBottom, perwidth, perY, barWidth, leftDis, tenTimes);
            }
        },

        drawCoordinate:function(data, paddingLeft, paddingRight, paddingTop, paddingBottom, barWidth, leftDis, xValuePosition, can, tenTimes, perwidth, yEmptyHeight, maxY, perY)
        {
            var moveDis = 0;//根据不同的xValuePosition设置的文字偏移距离

            /*绘制XY轴*/
            this.canctx.beginPath();
            this.canctx.lineWidth = &quot;1&quot;;
            this.canctx.strokeStyle = this.xyColor;
            this.canctx.moveTo(paddingLeft, paddingTop);
            this.canctx.lineTo(paddingLeft, can.height - paddingBottom);
            this.canctx.lineTo(can.width - paddingRight, can.height - paddingBottom);
            this.canctx.stroke();
            this.canctx.closePath();

            this.canctx.beginPath();
            this.canctx.fillStyle= this.xyDataColor;

            /*绘制X轴上的数据*/
            if (&quot;right&quot; == xValuePosition)
            {
                moveDis = perwidth * barWidth / 2;
            }

            for (var i = 0; i &lt; data.length; i++)
            {
                var nameValue = data[i].name;
                var dataLengthByNumber = this.getTotalLength((!isNaN(nameValue))?nameValue.toString():nameValue);

                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth) + moveDis - this.fontWidth / 4 * dataLengthByNumber;
                var y = can.height - paddingBottom + this.fontHeight;
                this.canctx.fillText(data[i].name, x, y);
            }

            /*绘制Y轴上的数字*/
            for (var i = 1; i &lt;= 10; i ++)
            {
                var valueOfY = maxY * i / 10;
                var dataLengthByNumber = this.getTotalLength(valueOfY.toString());

                var x = paddingLeft - this.fontWidth / 2 * dataLengthByNumber - 10;
                var y = this.getCoordY(paddingBottom, perY, valueOfY) + this.fontHeight / 2;
                this.canctx.fillText(valueOfY, x, y);
            }

            /*绘制坐标轴左下角的0*/
            if (0 == moveDis)
            {
                var x = paddingLeft - this.fontWidth / 2 * 1.2 - 2;
                var y = this.getCoordY(paddingBottom, perY, 0) + this.fontHeight / 2;
            }
            else
            {
                var x = paddingLeft - this.fontWidth / 2;
                var y = can.height - paddingBottom + this.fontHeight;
            }
            this.canctx.fillText(0, x, y);

            /*绘制Y轴上方表示10的倍数的值*/
            if (1 != tenTimes)
            {
                var content = &quot;( ×&quot; + tenTimes + &quot; )&quot;;
                var dataLengthByNumber = this.getTotalLength(content);
                var x = paddingLeft - dataLengthByNumber * (this.fontWidth / 2) / 2;
                var y = paddingTop - this.fontHeight / 4;
                //var y = paddingTop + parseInt(yEmptyHeight / 2) + parseInt(this.fontHeight / 2);
                this.canctx.fillText(content, x, y);
            }
        },

        drawGraphName:function(perY, can, paddingTop, paddingLeft, paddingRight)
        {
            /*绘制标题*/
            var dataLengthByNumber = this.getTotalLength(this.graphName);
            var x = (can.width - paddingLeft - paddingRight) / 2 + paddingLeft - (this.fontWidth / 2) * (dataLengthByNumber / 2);
            var y = paddingTop / 2 + this.fontHeight / 2;
            this.canctx.fillStyle= this.xyDataColor;

            this.canctx.fillText(this.graphName, x, y);
        },

        /*折线图：根据数据在坐标轴中添加点和线*/
        drawLine:function(data, paddingLeft, paddingBottom, perwidth, perY, barWidth, leftDis, tenTimes)
        {
            var x = this.getCoordX(paddingLeft, perwidth, 0, leftDis, barWidth);
            var y = this.getCoordY(paddingBottom, perY, data[0].value / tenTimes);

            this.canctx.lineWidth = &quot;2&quot;;
            this.canctx.strokeStyle = this.lineColor;
            this.canctx.beginPath();
            this.canctx.moveTo(x, y);

            for (var i = 1; i &lt; data.length; i++)
            {
                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth);
                var y = this.getCoordY(paddingBottom, perY, data[i].value / tenTimes);
                this.canctx.lineTo(x, y);
            }
            this.canctx.stroke();

            /*画折线上的点*/
            this.canctx.fillStyle = this.dotColor;

            for (var i = 0; i &lt; data.length; i++)
            {
                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth);
                var y = this.getCoordY(paddingBottom, perY, data[i].value / tenTimes);

                this.canctx.beginPath();
                this.canctx.arc(x, y, 3, 0, Math.PI*2, true);
                this.canctx.fill();
            }

            /*填充每一点对应的值*/
            this.canctx.fillStyle= this.dataColor;

            for (var i = 0; i &lt; data.length; i++)
            {
                var dataLengthByNumber = this.getTotalLength(data[i].value.toString());
                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth) - (this.fontWidth / 2) * (dataLengthByNumber / 2);
                var y = this.getCoordY(paddingBottom, perY, data[i].value / tenTimes);

                this.canctx.fillText(data[i].value, x, y - this.fontWidth / 2);
            }
        },

        /*柱形图：根据数据在坐标轴中添加框*/
        drawBar:function(data, paddingLeft, paddingBottom, perwidth, perY, barWidth, leftDis, tenTimes)
        {
            /*此处绘制柱形图
            先绘制柱形*/
            this.canctx.lineWidth = &quot;2&quot;;
            this.canctx.fillStyle = this.barColorFill;

            /*先绘制第一个柱形*/
            var x = this.getCoordX(paddingLeft, perwidth, 0, leftDis, barWidth) - perwidth * barWidth / 2;
            var y = this.getCoordY(paddingBottom, perY, data[0].value / tenTimes);
            this.canctx.beginPath();
            this.canctx.rect(x + this.smallPaddingWithY, y, perwidth * barWidth - this.smallPaddingBetween - this.smallPaddingWithY, data[0].value / tenTimes * perY);
            this.canctx.fill();
            var smallPadding = 0;

            /*绘制第2到n个柱形*/
            for (var i = 1; i &lt; data.length; i++)
            {
                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth) - perwidth * barWidth / 2;
                var y = this.getCoordY(paddingBottom, perY, data[i].value / tenTimes);

                this.canctx.beginPath();
                this.canctx.rect(x + this.smallPaddingBetween, y, perwidth * barWidth - 2 * this.smallPaddingBetween, data[i].value / tenTimes * perY);
                this.canctx.fill();
            }

            /*再绘制柱形上的数值*/
            this.canctx.fillStyle = this.dataColor;
            for (var i = 0; i &lt; data.length; i++)
            {
                var dataLengthByNumber = this.getTotalLength(data[i].value.toString());
                var x = this.getCoordX(paddingLeft, perwidth, i, leftDis, barWidth) - (this.fontWidth / 2) * (dataLengthByNumber / 2);
                var y = this.getCoordY(paddingBottom, perY, data[i].value / tenTimes);

                this.canctx.fillText(data[i].value, x, y - this.fontWidth / 4);
            }
        },

        /*获取value值占据的总宽度(像素)相对于单个数字宽度(像素)的倍数*/
        getTotalLength:function(value)
        {
            var totalLength = 0;

            for (var i = 0; i &lt; value.length; i++)
            {
                if (/[\u4E00-\u9FA5]/g.test(value[i]))
                {
                    totalLength += 2;
                }
                else
                {
                    totalLength += 1;
                }
            }

            return totalLength;
        },

        /*搜索data中value值中是否有小数*/
        checkFloatExist:function(data)
        {
            for (var i = 0; i &lt; data.length; i++)
            {
                if (data[i].value != parseInt(data[i].value))
                {
                    return 1;
                }
            }

            return 0;
        },

        /*x 轴每一个数据占据的宽度*/
        getXWidth:function(data, width, paddingLeft, paddingRight, barWidth, leftDis)
        {
            return ((width - paddingLeft - paddingRight) / (data.length + leftDis - (1 - barWidth) / 2));
        },

        /*根据pindex获取X轴上相邻两个坐标点之间的距离，表示柱形图中轴线或者折线图的点的横坐标*/
        getCoordX:function(paddingLeft, perwidth, ptindex, leftDis, barWidth)
        {
            return paddingLeft + perwidth * (leftDis + barWidth / 2 + ptindex);
        },

        /*根据y的值获取对应的坐标*/
        getCoordY:function(paddingBottom, perY, yValue)
        {
            return (this.can.height - paddingBottom - perY * yValue);
        },

        /*返回Y轴上数值能够显示的最大值和Y轴单位数值占有的像素值*/
        getYInfo:function(maxYNumber, height, paddingBottom, paddingTop, yEmptyHeight, floatExist)
        {
            var tenTimes = 1;
            var maxY = undefined;

            while (maxYNumber &gt; 100)
            {
                tenTimes *= 10;
                maxYNumber /= 10;
            }

            if (10 &gt;= maxYNumber)
            {
                maxY = 10;
            }
            else if (10 &lt; maxYNumber)
            {
                maxY = (parseInt(maxYNumber / 10) + 1) * 10;
            }

            return {perY:(height - paddingBottom - paddingTop - yEmptyHeight) / maxY, maxY:maxY, tenTimes:tenTimes};
        },

        /*返回最大值*/
        getMax:function(data)
        {
            var maxYNumber = data[0].value;
            var length = data.length;
            for (var i = 1; i &lt; length; i++)
            {
                if (maxYNumber &lt; data[i].value)
                {
                    maxYNumber = data[i].value;
                }
            }
            return maxYNumber;
        }
    };

    chart.init(chartInfo);
}
</code></pre>
<h2 id="16-输入框滚动"><a href="#16-输入框滚动" class="headerlink" title="16. 输入框滚动"></a>16. 输入框滚动</h2><pre><code class="javascript">this.getWheelDelta = function(event){
  event = event || window.event;
  if (event.wheelDelta)
  {
    return window.opera&amp;&amp;window.opera.version &lt; 9.5?-event.wheelDelta:event.wheelDelta;
  }
  else
  {
    return -event.detail*40;
  }
};

this.scrollWheelHd = function(event)
{
  if(gTimeEditInputId == null)
  {
    return;
  }

  var targerObj = id(gTimeEditInputId);
  var tmpValue = parseInt(targerObj.value, 10);
  var direct = (this.getWheelDelta(event) &gt; 0) ? 0 : 1;

  switch (gTimeEditInputId)
  {
    case &quot;timeHour&quot;:
      if(direct == 0)
      {
        if (tmpValue == 23)
        {
          targerObj.value = &quot;00&quot;;
        }
        else
        {
          tmpValue++;
          targerObj.value = midifyTimeStr(tmpValue);
        }
      }
      else
      {
        if (tmpValue == 0)
        {
          targerObj.value = &quot;23&quot;;
        }
        else
        {
          tmpValue--;
          targerObj.value = midifyTimeStr(tmpValue);
        }
      }
      break;
    case &quot;timeMinute&quot;:
    case &quot;timeSecond&quot;:
      if(direct == 0)
      {
        if (tmpValue == 59)
        {
          targerObj.value = &quot;00&quot;;
        }
        else
        {
          tmpValue++;
          targerObj.value = midifyTimeStr(tmpValue);
        }
      }
      else
      {
        if (tmpValue == 0)
        {
          targerObj.value = &quot;59&quot;;
        }
        else
        {
          tmpValue--;
          targerObj.value = midifyTimeStr(tmpValue);
        }
      }
      break;
    default:
      break;
  }

  clearSelection();
}

this.bindScrollWheel = function()
{
  if (document.attachEvent)
  {
    document.body.attachEvent(&quot;onmousewheel&quot;, function(event){
      event = event || window.event;scrollWheelHd(event)});
  }
  else
  {
    document.body.addEventListener(&quot;mousewheel&quot;,
                                   function(event){event = event || window.event;scrollWheelHd(event)}, false);
    document.body.addEventListener(&quot;DOMMouseScroll&quot;,
                                   function(event){event = event || window.event;scrollWheelHd(event)}, false);
  }
}
</code></pre>
<p>onmousewheel +  getWheelDelta 测试滚动距离</p>
<p>…</p>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack篇]]></title>
      <url>/2017/10/02/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA/Webpack/Webpack%E7%AF%87/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍webpack结构</p>
<a id="more"></a>
<h1 id="webpack篇"><a href="#webpack篇" class="headerlink" title="webpack篇"></a>webpack篇</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>不像大多数的模块打包机，webpack是收把项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件</p>
<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果。这些是有关<strong>devServer的配置</strong></p>
<pre><code class="javascript">contentBase,  // 为文件提供本地服务器
port, // 监听端口，默认8080
inline, // 设置为true,源文件发生改变自动刷新页面
historyApiFallback  // 依赖HTML5 history API,如果设置为true,所有的页面跳转指向index.html

devServer:{
    contentBase: &#39;./src&#39; // 本地服务器所加载的页面所在的目录
    historyApiFallback: true, // 不跳转
    inline: true // 实时刷新
}
</code></pre>
<p>然后我们在根目录下创建一个’webpack.config.js’，在’package.json’添加两个命令用于本地开发和生产发布</p>
<pre><code class="javascript">&quot;scripts&quot;: {
      &quot;start&quot;: &quot;webpack-dev-server&quot;,
    &quot;build&quot;: &quot;webpack&quot;
}
</code></pre>
<h1 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry: 用来写入口文件，它将是整个依赖关系的根，当我们需要多个入口文件的时候，可以把entry写成一个对象</p>
<pre><code class="javascript">var baseConfig = {
        entry: {
            main: &#39;./src/index.js&#39;
        }
    }
</code></pre>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>output: 即使入口文件有多个，但是只有一个输出配置</p>
<pre><code class="javascript">var path = require(&#39;path&#39;)
var baseConfig = {
    entry: {
        main: &#39;./src/index.js&#39;
    },
    output: {
        filename: &#39;main.js&#39;,
        path: path.resolve(&#39;./build&#39;)
    }
}
module.exports = baseConfig
</code></pre>
<p>如果你定义的入口文件有多个，那么我们需要使用<strong>占位符</strong>来确保输出文件的唯一性</p>
<pre><code class="javascript">output: {
      filename: &#39;[name].js&#39;,
    path: path.resolve(&#39;./build&#39;)
}
</code></pre>
<p>注：filename应该比较好理解，就是对应于entry里面生成出来的文件名。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><strong>loader的作用</strong>： </p>
<ol>
<li>实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js</li>
<li>转换这些文件，从而使其能够被添加到依赖图中</li>
</ol>
<p>loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置，需要的loader需要通过npm 进行安装。配置如下：</p>
<pre><code class="javascript">var baseConfig = {
  // ...
  module: {
    rules: [
      {
        test: /*匹配文件后缀名的正则*/,
        use: [
        loader: /*loader名字*/,
        query: /*额外配置*/
        ]
      }
    ]
  }
}
</code></pre>
<p>几个常用的loader：</p>
<ul>
<li>babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。babel有些复杂，所以大多数都会新建一个.babelrc进行配置</li>
<li>css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader</li>
<li>file-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名</li>
<li>url-loader: 功能类似 file-loader,但是文件大小低于指定的限制时，可以返回一个DataURL事实上，在使用less,scss,stylus这些的时候，npm会提示你差什么插件，差什么，你就安上就行了</li>
</ul>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p><strong>plugins和loader区别</strong></p>
<p><strong>loaders负责的是处理源文件的如css、jsx，一次处理一个文件。而plugins并不是直接操作单个文件，</strong>它直接对整个构建过程起作用。下面列举了一些我们常用的plugins和他的用法</p>
<ul>
<li>ExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。</li>
<li>HtmlWebpackPlugin:它依据一个简单的index.html模版，生成一个自动引用你打包后的js文件的新index.html</li>
<li>HotModuleReplacementPlugin: 它允许你在修改组件代码时，自动刷新实时预览修改后的结果注意永远不要在生产环境中使用HMR。这儿说一下一般情况分为开发环境，测试环境，生产环境。</li>
</ul>
<p>Case.webapck.config.js的全部内容:</p>
<pre><code class="javascript">const webpack = require(&quot;webpack&quot;)
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)
var lessRules = {
  use: [
    {loader: &#39;css-loader&#39;},
    {loader: &#39;less-loader&#39;}
  ]
}
module.exports = {
  entry: {
    main: &#39;./src/index.js&#39;
  },
  output: {
    filename: &#39;[name].js&#39;,
    path: path.resolve(&#39;./build&#39;)
  },
  devServer: {
    contentBase: &#39;/src&#39;,
    historyApiFallback: true,
    inline: true,
    hot: true
  },
  module: {
    rules: [
      {test: /\.less$/, use: ExtractTextPlugin.extract(lessRules)}
    ]
  },
  plugins: [
    new ExtractTextPlugin(&#39;main.css&#39;)
  ]
}
</code></pre>
<h1 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h1><p>在产品阶段，还需要对资源进行别的<br>处理，例如压缩，优化，缓存，分离css和js。首先我们来定义产品环境</p>
<pre><code class="javascript">var ENV = process.env.NODE_ENV
var baseConfig = {
  // ... 
  plugins: [
    new webpack.DefinePlugin({
      &#39;process.env.NODE_ENV&#39;: JSON.stringify(ENV)
    })
  ]
}
</code></pre>
<p>然后还需要修改我们的script命令</p>
<pre><code class="javascript">&quot;scripts&quot;: {
    &quot;start&quot;: &quot;NODE_ENV=development webpack-dev-server&quot;,
    &quot;build&quot;: &quot;NODE_ENV=production webpack&quot;
}
</code></pre>
<p>process.env.NODE_ENV 将被一个字符串替代，它运行压缩器排除那些不可到达的开发代码分支。<br>当你引入那些不会进行生产的代码，下面这个代码将非常有用。</p>
<pre><code class="javascript">if (process.env.NODE_ENV === &#39;development&#39;) {
  console.warn(&#39;这个警告会在生产阶段消失&#39;)
}
</code></pre>
<h1 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h1><ul>
<li>OccurenceOrderPlugin: 为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多 的模块，然后为他们分配最小的ID</li>
<li>UglifyJsPlugin: 压缩代码</li>
</ul>
<p>使用方法</p>
<pre><code class="javascript">var baseConfig = {
  // ...
  new webpack.optimize.OccurenceOrderPlugin()
  new webpack.optimize.UglifyJsPlugin()
}
</code></pre>
<p>然后在我们使用npm run build会发现代码是压缩的</p>
]]></content>
      
        <categories>
            
            <category> 构建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less语言特性]]></title>
      <url>/2017/10/02/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA/Less/Less%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍Less语言特性</p>
<a id="more"></a>
<h1 id="Less语言特性"><a href="#Less语言特性" class="headerlink" title="Less语言特性"></a>Less语言特性</h1><h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><ul>
<li>在定义变量值时使用其它的变量</li>
<li>多次定义，<strong>当前作用域中最后一次定义</strong>的将被使用</li>
<li><strong>按需加载，不必强制在使用之前声明</strong></li>
</ul>
<h3 id="2-混合（Mixins）"><a href="#2-混合（Mixins）" class="headerlink" title="2.混合（Mixins）"></a>2.混合（Mixins）</h3><ul>
<li>可以定义一些通用的属性集为一个 class，然后在另一个 class 中去调用这些属性</li>
<li>任何 CSS class, id 属性集都可以以同样的方式引入</li>
<li>变量也会被混合，也就是说变量会被带到当前的作用域。</li>
</ul>
<h4 id="带参数混合"><a href="#带参数混合" class="headerlink" title="带参数混合"></a>带参数混合</h4><ul>
<li>定义一个带参数的属性集合，如果无默认值，调用必须传参</li>
<li>给参数设置默认值，调用可不传参</li>
<li>定义不带参数属性集合：隐藏（不在 CSS 中）+ 可引用</li>
</ul>
<h4 id="多参数混合"><a href="#多参数混合" class="headerlink" title="多参数混合"></a>多参数混合</h4><ul>
<li>使用分号或者逗号分隔，推荐使用分号分隔，因为逗号有两重含义：它既可以表示混合的参数，也可以表示一个参数中一组值的分隔符。如果编译器在混合的定义或者是调用中找到至少一个分号，就会假设参数是使用分号分隔的，所有的逗号都属于参数中的一组值的分隔符。</li>
<li>使用同样的名字和同样数量的参数定义多个混合是合法的。在被调用时，LESS会应用到所有可以应用的混合上。</li>
</ul>
<h5 id="arguments-变量"><a href="#arguments-变量" class="headerlink" title="@arguments 变量"></a>@arguments 变量</h5><ul>
<li>@arguments包含了所有传递进来的参数。</li>
</ul>
<h4 id="高级参数用法与-rest-变量"><a href="#高级参数用法与-rest-变量" class="headerlink" title="高级参数用法与 @rest 变量"></a>高级参数用法与 @rest 变量</h4><ul>
<li>不限制参数的数量，可以在变量名后添加 …，表示这里可以使用 N 个参数。</li>
<li>@rest 表示之后的参数</li>
</ul>
<h4 id="important关键字"><a href="#important关键字" class="headerlink" title="!important关键字"></a>!important关键字</h4><ul>
<li>在混合后面加上<code>!important</code>关键字表示将混合带来的所有属性标记为<code>!important</code></li>
</ul>
<h4 id="模式匹配与Guard表达式"><a href="#模式匹配与Guard表达式" class="headerlink" title="模式匹配与Guard表达式"></a>模式匹配与Guard表达式</h4><ul>
<li>只有满足匹配要求的混合才会被使用</li>
<li>也可以根据参数的数量进行匹配</li>
</ul>
<h4 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h4><ul>
<li>Guards 被用来匹配表达式，LESS 选择使用 guard混合（类似于 @media 的工作方式）执行条件判断，而不是加入 if/else 声明。</li>
<li>关键词 when，它引入了一个 guard 条件</li>
<li>Guards 支持的运算符包括：&gt; &gt;= = =&lt; &lt;。true关键字是唯一被判断为真的值</li>
<li>多个Guards可以通过逗号表示分隔，如果其中任意一个结果为 true，则匹配成功</li>
<li>不同的参数之间也可以比较，而参与比较的也可以一个参数都没有</li>
<li>如果需要根据值的类型匹配混合，可以使用 is* 函数</li>
<li>使用关键词 and 在 guard 中加入额外的条件</li>
<li>使用关键词 not 否定条件</li>
</ul>
<h3 id="3-嵌套规则"><a href="#3-嵌套规则" class="headerlink" title="3.嵌套规则"></a>3.嵌套规则</h3><ul>
<li>LESS 可以让我们以嵌套的方式编写层叠样式</li>
<li>注意 &amp; 符号的使用 — 如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用如:hover 和 :focus。</li>
</ul>
<h4 id="嵌套-Media-Queries"><a href="#嵌套-Media-Queries" class="headerlink" title="嵌套 Media Queries"></a>嵌套 Media Queries</h4><ul>
<li>Media query也可以使用同样的方式进行嵌套</li>
</ul>
<h3 id="amp-的高级用法"><a href="#amp-的高级用法" class="headerlink" title="&amp; 的高级用法"></a>&amp; 的高级用法</h3><ul>
<li>用在选择器中的&amp;还可以反转嵌套的顺序并且可以应用到多个类名上</li>
<li>&amp;也可以用在混合中用于指示嵌套这个混合的父选择器。</li>
</ul>
<h3 id="4-运算"><a href="#4-运算" class="headerlink" title="4.运算"></a>4.运算</h3><ul>
<li>任何数字、颜色或者变量都可以参与运算，运算应该被包裹在括号中</li>
<li>它能够分辨出颜色和单位</li>
</ul>
<h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h3><ul>
<li>提供了多种函数用于控制颜色变化、处理字符串、算术运算等等</li>
</ul>
<h3 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6.命名空间"></a>6.命名空间</h3><ul>
<li>将一些变量或者混合模块打包起来</li>
<li>使用 <code>&gt;</code> 取命名空间</li>
</ul>
<h3 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7.作用域"></a>7.作用域</h3><ul>
<li>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止</li>
</ul>
<h3 id="8-注释"><a href="#8-注释" class="headerlink" title="8.注释"></a>8.注释</h3><ul>
<li>CSS 的注释格式</li>
<li>支持双斜线的注释，但是编译成 CSS 的时候自动过滤掉</li>
</ul>
<h3 id="9-导入（Import）"><a href="#9-导入（Import）" class="headerlink" title="9.导入（Import）"></a>9.导入（Import）</h3><ul>
<li>既可以导入CSS文件，也可以导入LESS文件。但只有导入的LESS文件才会被处理（编译），导入的CSS文件会保持原样。如果你希望导入一个CSS文件，保留.css后缀即可</li>
<li>编译过程中，对导入CSS文件只做一处处理：将导入的语句提到最前，紧跟在@charset之后</li>
<li>被导入的LESS文件会被复制到含导入语句的文件中，然后一起编译。导入和被导入的文件共享所有的混合、命名空间、变量以及其它结构。</li>
<li>如果导入语句是通过media query指定的，那么导入的语句编译之后会被包裹在@Media声明中。</li>
<li>LESSS文件的导入语句并不强制要求在顶部，它可以被入在规则内部、混合中或者其它的结构中。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>很容易理解：</p>
<pre><code class="less">@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header { color: @light-blue; }
</code></pre>
<p>输出：</p>
<pre><code class="less">#header { color: #6c94be; }
</code></pre>
<p>甚至可以<strong>在定义变量值时使用其它的变量</strong>：</p>
<pre><code class="less">@fnord: &quot;I am fnord.&quot;;
@var: &#39;fnord&#39;;
content: @@var;
</code></pre>
<p>解析后：</p>
<pre><code class="less">content: &quot;I am fnord.&quot;;
</code></pre>
<p>如果对同一个变量定义两次的话，在<strong>当前作用域中最后一次定义</strong>的将被使用。这与CSS的机制类似，最后一次定义的值会成为这个属性的值。<br>比如：</p>
<pre><code class="less">@var: 0;
.class1 {
    @var: 1;
    .class {
        @var: 2;
        three: @var;
        @var: 3;
    }
    one: @var;
}
</code></pre>
<p>会编译成：</p>
<pre><code class="css">.class1.class {
    three: 3;
}
.class1 {
    one: 1;
}
</code></pre>
<p>变量是“<strong>按需加载</strong>”（lazy loaded）的，因此<strong>不必强制在使用之前声明</strong>。<br>下面是一个有效的LESS代码片段：</p>
<pre><code class="less">lazy-eval {
    width: @var;
}

@var: @a;
@a: 9%;
</code></pre>
<p>下面这个片段也是有效的：</p>
<pre><code class="less">.lazy-eval-scope {
    width: @var;
    @a: 9%;
}

@var: @a;
@a: 100%;
</code></pre>
<p>这两个片段都会编译成：</p>
<pre><code class="css">.lazy-eval-scope {
    width: 9%;
}
</code></pre>
<hr>
<h2 id="混合（Mixins）"><a href="#混合（Mixins）" class="headerlink" title="混合（Mixins）"></a>混合（Mixins）</h2><p>在 LESS 中我们<strong>可以定义一些通用的属性集为一个 class，然后在另一个 class 中去调用这些属性</strong>，下面有这样一个 class：</p>
<pre><code class="less">.bordered {
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
</code></pre>
<p>那如果我们现在需要在其他 class 中引入那些通用的属性集，那么我们只需要在任何 class 中像下面这样调用就可以了：</p>
<pre><code class="less">#menua {
    color: #111;
    .bordered;
}
.posta {
    color: red;
    .bordered;
}
</code></pre>
<p>.bordered class 里面的属性样式都会在 #menu a 和 .post a 中体现出来：</p>
<pre><code class="less">#menua {
    color: #111;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
.posta {
    color: red;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
</code></pre>
<p>任何 <strong>CSS class, id 属性集</strong>都可以以同样的方式引入。</p>
<blockquote>
<p>注意：变量也会被混合，也就是说变量会被带到当前的作用域。这个特性还有争议，也许在未来会有变化。</p>
</blockquote>
<h3 id="带参数混合-1"><a href="#带参数混合-1" class="headerlink" title="带参数混合"></a><strong>带参数混合</strong></h3><p>在 LESS 中，你还可以像函数一样<strong>定义一个带参数的属性集合</strong>：</p>
<pre><code class="less">.border-radius (@radius) {
    border-radius: @radius;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
}
</code></pre>
<p>然后在其他 class 中像这样调用它：</p>
<pre><code class="less">#header {
    .border-radius(4px);
}
.button {
    .border-radius(6px);
}
</code></pre>
<p>我们还可以像这样<strong>给参数设置默认值</strong>：</p>
<pre><code class="less">.border-radius (@radius: 5px) {
    border-radius: @radius;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
}
</code></pre>
<p>所以现在如果我们像这样调用它的话：</p>
<pre><code class="less">#header {
    .border-radius;
}
</code></pre>
<p>radius 的值就会是 <em>5px</em>。<br>你也可以<strong>定义不带参数属性集合</strong>，如果你想隐藏这个属性集合，不让它暴露到 CSS 中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用：</p>
<pre><code class="less">.wrap () {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}

pre { .wrap }
</code></pre>
<p>输出：</p>
<pre><code class="css">pre {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}
</code></pre>
<h3 id="多参数混合-1"><a href="#多参数混合-1" class="headerlink" title="多参数混合"></a>多参数混合</h3><p>多个参数可以<strong>使用分号或者逗号分隔，推荐使用分号分隔</strong>，因为<strong>逗号有两重含义：它既可以表示混合的参数，也可以表示一个参数中一组值的分隔符。</strong><br>使用分号作为参数分隔符意味着可以将逗号分隔的一组值作为一个变量处理。换句话说，<strong>如果编译器在混合的定义或者是调用中找到至少一个分号，就会假设参数是使用分号分隔的，所有的逗号都属于参数中的一组值的分隔符。</strong><br>2个参数，每个参数都含有通过逗号分隔的一组值的情况：.name(1, 2, 3; something, else)。<br>3个参数，每个参数只含一个数字的情况：.name(1, 2, 3)。<br>使用一个象征性的分号可以创建一个只含一个参数，但参数包含一组值的混合：.name(1, 2, 3;)。<br>逗号分隔的一组值参数的默认值：.name(@param1: red, blue;)。<br><strong>使用同样的名字和同样数量的参数定义多个混合是合法的。在被调用时，LESS会应用到所有可以应用的混合上。</strong>比如你调用混合时只传了一个参数.mixin(green)，那么所有只强制要求一个参数的混合都会被调用：</p>
<pre><code class="less">.mixin(@color) {
    color-1: @color;
}
.mixin(@color; @padding:2) {
    color-2: @color;
    padding-2: @padding;
}
.mixin(@color; @padding; @margin: 2) {
    color-3: @color;
    padding-3: @padding;
    margin: @margin @margin @margin @margin;
}
.some.selectordiv {
    .mixin(#008000);
}
</code></pre>
<p>编译结果：</p>
<pre><code class="less">.some.selectordiv {
    color-1: #008000;
    color-2: #008000;
    padding-2: 2;
}
</code></pre>
<h4 id="arguments-变量-1"><a href="#arguments-变量-1" class="headerlink" title="@arguments 变量"></a><strong>@arguments 变量</strong></h4><p><strong>@arguments包含了所有传递进来的参数。</strong> 如果你不想单独处理每一个参数的话就可以像这样写：</p>
<pre><code class="less">.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {
    box-shadow: @arguments;
    -moz-box-shadow: @arguments;
    -webkit-box-shadow: @arguments;
}
.box-shadow(2px, 5px);
</code></pre>
<p>将会输出：</p>
<pre><code class="css">box-shadow: 2px5px1px#000;
-moz-box-shadow: 2px5px1px#000;
 -webkit-box-shadow: 2px5px1px#000;
</code></pre>
<h3 id="高级参数用法与-rest-变量-1"><a href="#高级参数用法与-rest-变量-1" class="headerlink" title="高级参数用法与 @rest 变量"></a>高级参数用法与 @rest 变量</h3><p>如果需要在 mixin 中<strong>不限制参数的数量，可以在变量名后添加 …，</strong>表示这里可以使用 N 个参数。</p>
<pre><code>.mixin (...) {        // 接受 0-N 个参数
     .mixin () {           // 不接受任何参数
     .mixin (@a: 1) {      // 接受 0-1 个参数
     .mixin (@a: 1, ...) { // 接受 0-N 个参数
     .mixin (@a, ...) {    // 接受 1-N 个参数
</code></pre><p><strong>此外：</strong></p>
<pre><code class="less">.mixin (@a, @rest...) {
    // @rest 表示 @a 之后的参数// @arguments 表示所有参数
}
</code></pre>
<h3 id="important关键字-1"><a href="#important关键字-1" class="headerlink" title="!important关键字"></a><strong>!important关键字</strong></h3><p>调用时<strong>在混合后面加上<code>!important</code>关键字表示将混合带来的所有属性标记为<code>!important</code>：</strong></p>
<pre><code class="less">.mixin (@a: 0) {
    border: @a;
    boxer: @a;
}
.unimportant {
    .mixin(1); 
}
.important {
    .mixin(2) !important; 
}
</code></pre>
<p>编译成：</p>
<pre><code class="css">.unimportant {
    border: 1;
    boxer: 1;
}
.important {
    border: 2!important;
    boxer: 2!important;
}
</code></pre>
<h3 id="模式匹配与Guard表达式-1"><a href="#模式匹配与Guard表达式-1" class="headerlink" title="模式匹配与Guard表达式"></a><strong>模式匹配与Guard表达式</strong></h3><p>LESS 提供了通过参数值控制 mixin 行为的功能，让我们先从最简单的例子开始：</p>
<pre><code class="less">.mixin (@s, @color) { ... }

.class {
    .mixin(@switch, #888);
}
</code></pre>
<p>如果要根据 @switch 的值控制 .mixin 行为，只需按照下面的方法定义 .mixin：</p>
<pre><code class="less">.mixin (dark, @color) {
    color: darken(@color, 10%);
}
.mixin (light, @color) {
    color: lighten(@color, 10%);
}
.mixin (@_, @color) {
    display: block;
}
</code></pre>
<p>然后调用：</p>
<pre><code class="less">@switch: light;

.class {
    .mixin(@switch, #888);
}
</code></pre>
<p>将会得到以下 CSS：</p>
<pre><code class="css">.class {
    color: #a2a2a2;
    display: block;
}
</code></pre>
<p>传给 .mixin 的颜色将执行 lighten 函数，如果 @switch 的值是 dark，那么则会执行 darken 函数输出颜色。<br>以下是整个过程如何发生的：</p>
<pre><code>1. 第一个.mixin 没有匹配，因为不满足 dark 条件；
2. 第二个.mixin 可以被匹配，因为它满足了 light 条件；
3. 第三个.mixin 也可以被匹配，因为它接受任何参数。
</code></pre><p><strong>只有满足匹配要求的混合才会被使用。</strong>混合中的变量可以匹配任何值，非变量形式的值只有与传入的值完全相等时才可以匹配成功。<br>我们<strong>也可以根据参数的数量进行匹</strong>配，比如：</p>
<pre><code class="less">.mixin (@a) {
    color: @a;
}
.mixin (@a, @b) {
    color: fade(@a, @b);
}
</code></pre>
<p>调用 .mixin 时，如果使用了一个参数，输出第一个 .mixin，使用了两个参数，则输出第二个。</p>
<h3 id="Guards-1"><a href="#Guards-1" class="headerlink" title="Guards"></a><strong>Guards</strong></h3><p>与上面匹配值或者匹配参数数量的情况不同，<strong>Guards 被用来匹配表达式</strong> (expressions)。如果你很熟悉编程函数的用法，那么很可能你已经掌握它的用法了。<br>为了尽可能地符合 CSS 的语言结构，<strong>LESS 选择使用 guard混合（guarded mixins）（类似于 @media 的工作方式）执行条件判断，而不是加入 if/else 声明。</strong><br>首先通过下面的例子开始介绍：</p>
<pre><code class="less">.mixin (@a) when (lightness(@a) &gt;= 50%) {
    background-color: black;
}
.mixin (@a) when (lightness(@a) &lt; 50%) {
    background-color: white;
}
.mixin (@a) {
    color: @a;
}
</code></pre>
<p>要点在于<strong>关键词 when，它引入了一个 guard 条件</strong> （这里只用到一个 guard）。现在如果运行下面的代码：</p>
<pre><code class="less">.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }
</code></pre>
<p>将会得到以下输出结果：</p>
<pre><code class="less">.class1 {
    background-color: black;
    color: #ddd;
}
.class2 {
    background-color: white;
    color: #555;
}
</code></pre>
<p><strong>Guards 支持的运算符包括：&gt; &gt;= = =&lt; &lt;</strong>。说明一下，<strong>true关键字是唯一被判断为真的值，也就是这两个混合是相等的</strong>：</p>
<pre><code class="less">.truth (@a) when (@a) { ... }
.truth (@a) when (@a = true) { ... }
</code></pre>
<p>其他不为 true 的值都判为假：</p>
<pre><code class="css">.class {
    .truth(40); // 不会匹配上面的 mixin
}
</code></pre>
<p><strong>多个Guards可以通过逗号表示分隔，如果其中任意一个结果为 true，则匹配成功</strong>：</p>
<pre><code class="less">.mixin (@a) when (@a &gt; 10), (@a &lt; -10) { ... }
</code></pre>
<p>值得注意的是<strong>不同的参数之间也可以比较，而参与比较的也可以一个参数都没有</strong>：</p>
<pre><code class="less">@media: mobile;

.mixin (@a) when (@media = mobile) { ... }
.mixin (@a) when (@media = desktop) { ... }

.max (@a, @b) when (@a &gt; @b) { width: @a }
.max (@a, @b) when (@a &lt; @b) { width: @b }
</code></pre>
<p><strong>如果需要根据值的类型匹配混合，可以使用 is* 函数</strong>：</p>
<pre><code class="less">.mixin (@a, @b: 0) when (isnumber(@b)) { ... }
.mixin (@a, @b: black) when (iscolor(@b)) { ... }
</code></pre>
<p><strong>几个检查基本类型的函数</strong>：</p>
<ul>
<li>iscolor</li>
<li>isnumber</li>
<li>isstring</li>
<li>iskeyword</li>
<li>isurl</li>
</ul>
<p>如果需要检查一个值（数字）使用了哪个单位，可以使用下面三个函数：</p>
<ul>
<li>ispixel</li>
<li>ispercentage</li>
<li>isem</li>
</ul>
<p>最后，你<strong>可以使用关键词 and 在 guard 中加入额外的条件</strong>:<br>.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { … }<br>或者，<strong>使用关键词 not 否定条件</strong>：<br>.mixin (@b) when not (@b &gt; 0) { … }</p>
<hr>
<h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a><strong>嵌套规则</strong></h2><p><strong>LESS 可以让我们以嵌套的方式编写层叠样式。</strong> 让我们先看下下面这段 CSS：</p>
<pre><code class="css">#header { color: black; }

#header.navigation {
font-size: 12px;
}

#header.logo {
width: 300px;
}

#header.logo:hover {
text-decoration: none;
}
</code></pre>
<p>在 LESS 中, 我们就可以这样写：</p>
<pre><code class="less">#header {
    color: black;

    .navigation {
        font-size: 12px;
    }

    .logo {
        width: 300px;
        &amp;:hover { text-decoration: none }
    }
}
</code></pre>
<p>或者这样写：</p>
<pre><code class="less">#header { color: black;
    .navigation { font-size: 12px }
    .logo { width: 300px;
        &amp;:hover { text-decoration: none }
    }
}
</code></pre>
<p>代码更简洁了，而且感觉跟 DOM 结构格式有点像。<br><strong>注意 &amp; 符号的使用 — 如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用如:hover 和 :focus。</strong><br>例如：</p>
<pre><code class="less">.bordered {
    &amp;.float {
        float: left;
    }
    .top {
        margin: 5px;
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="css">.bordered.float {
    float: left;
}
.bordered.top {
    margin: 5px;
}
</code></pre>
<h3 id="嵌套-Media-Queries-1"><a href="#嵌套-Media-Queries-1" class="headerlink" title="嵌套 Media Queries"></a><strong>嵌套 Media Queries</strong></h3><p><strong>Media query也可以使用同样的方式进行嵌套</strong>。</p>
<pre><code class="less">.one {
    @media (width: 400px) {
        font-size: 1.2em;
        @media printandcolor {
            color: blue;
        }
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="less">@media (width: 400px) {
    .one {
        font-size: 1.2em;
    }
}
@media (width: 400px) andprintandcolor {
    .one {
        color: blue;
        }
}
</code></pre>
<h2 id="amp-的高级用法-1"><a href="#amp-的高级用法-1" class="headerlink" title="&amp; 的高级用法"></a><strong>&amp; 的高级用法</strong></h2><p><strong>用在选择器中的&amp;还可以反转嵌套的顺序并且可以应用到多个类名上</strong>。<br>例如：</p>
<pre><code class="less">.child, .sibling {
    .parent &amp; {
        color: black;
    }
    &amp; + &amp; {
        color: red;
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="css">.parent.child,
.parent.sibling {
    color: black;
}
.child + .child,
.child + .sibling,
.sibling + .child,
.sibling + .sibling {
    color: red;
}
</code></pre>
<p><strong>&amp;也可以用在混合中用于指示嵌套这个混合的父选择器。</strong></p>
<hr>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a><strong>运算</strong></h2><p><strong>任何数字、颜色或者变量都可以参与运算，运算应该被包裹在括号中</strong>。来看一组例子：</p>
<pre><code class="less">@base: 5%;
@filler: (@base * 2);
@other: (@base + @filler);

color: (#888 / 4);
background-color: (@base-color + #111);
height: (100% / 2 + @filler);
</code></pre>
<p>LESS 的运算已经超出了我们的期望，如果像下面这样的话，<strong>它能够分辨出颜色和单位</strong>：</p>
<pre><code class="less">@var: (1px + 5);
</code></pre>
<p>LESS 将会使用出现的单位，最终输出 6px。<br>也可以使用括号：</p>
<pre><code class="less">width: ((@var + 5) * 2);
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p>LESS <strong>提供了多种函数用于控制颜色变化、处理字符串、算术运算等等</strong>。这些函数在函数手册中有详细介绍。<br>函数的用法非常简单，下面这个例子将介绍如何将 0.5 转换为 50%，将颜色饱和度增加 5%,以及颜色亮度降低25% 色相值增加 8 等</p>
<pre><code class="less">@base: #f04615;
@width: 0.5;

.class {
    width: percentage(0.5); // returns `50%`color:             saturate(@base, 5%);
    background-color: spin(lighten(@base, 25%), 8);
}
</code></pre>
<p><strong>命名空间</strong><br>有时候，你可能为了更好组织 CSS 或者单纯是为了更好的封装，将一些变量或者混合模块打包起来，你可以像下面这样在 #bundle 中定义一些属性集之后可以重复使用：</p>
<pre><code class="less">#bundle {
    .button () {
        display: block;
        border: 1px solid black;
        background-color: grey;
        &amp;:hover { background-color: white }
    }
    .tab { ... }
    .citation { ... }
}
</code></pre>
<p>你只需要在 #header a 中像<strong>这样引入 .button</strong>：</p>
<pre><code class="less">#headera {
    color: orange;
    #bundle &gt; .button;
}
</code></pre>
<hr>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h2><p>LESS 中的作用域跟其他编程语言非常类似，<strong>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止</strong>。</p>
<pre><code class="less">@var: red;

#page {
    @var: white;
    #header {
        color: @var; // white
    }
}

#footer {
    color: @var; // red
}
</code></pre>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p>CSS 的注释格式在 LESS 中依然有效：</p>
<pre><code class="less">/* Hello, I&#39;m a CSS-style comment */.class { color: black }1
</code></pre>
<p>LESS 同样<strong>也支持双斜线的注释，但是编译成 CSS 的时候自动过滤掉</strong>：</p>
<pre><code class="css">// Hi, I&#39;m a silent comment, I won&#39;t show up in your CSS.class { color: white }1
</code></pre>
<h2 id="导入（Import）"><a href="#导入（Import）" class="headerlink" title="导入（Import）"></a><strong>导入（Import）</strong></h2><p>在LESS中，你<strong>既可以导入CSS文件，也可以导入LESS文件。但只有导入的LESS文件才会被处理（编译），导入的CSS文件会保持原样。如果你希望导入一个CSS文件，保留.css后缀即可</strong>：</p>
<pre><code class="less">@import &quot;lib.css&quot;;
</code></pre>
<p><strong>编译过程中，对导入CSS文件只做一处处理：将导入的语句提到最前，紧跟在@charset之后</strong>。<br>例如输入的文件有导入语句：</p>
<pre><code class="less">h1 { color: green; }
@import &quot;import/official-branding.css?urlParameter=23&quot;;
</code></pre>
<p>导入语句将被提到最前：</p>
<pre><code class="less">@import &quot;import/official-branding.css?urlParameter=23&quot;;
h1 { color: green; }
</code></pre>
<p><strong>被导入的LESS文件会被复制到含导入语句的文件中，然后一起编译。导入和被导入的文件共享所有的混合、命名空间、变量以及其它结构。</strong><br>另外，<strong>如果导入语句是通过media query指定的，那么导入的语句编译之后会被包裹在@Media声明中。</strong><br>例如有被导入的文件library.less：</p>
<pre><code class="less">@imported-color: red;
h1 { color: green; }
</code></pre>
<p>主样式文件导入了上面的library.less：</p>
<pre><code class="less">@import &quot;library.less&quot; screen and (max-width: 400px); // 通过media query指定的import@import &quot;library.less&quot;; // 无media query的import.class {
    color: @importedColor; // 使用导入的变量
}
</code></pre>
<p>将会编译出：</p>
<pre><code class="less">// 对应通过media query指定的import@media screen and (max-width: 400px) {
    h1 { color: green; }
}

// 对应无media query的importh1 { color: green; }
.class {
    // 使用导入的变量color: #ff0000;
}
</code></pre>
<p><strong>LESSS文件的导入语句并不强制要求在顶部，它可以被入在规则内部、混合中或者其它的结构中。</strong><br>例如放在规则内部：</p>
<pre><code class="less">pre {
    @import &quot;library.less&quot;;
    color: @importedColor;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 构建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Less </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax]]></title>
      <url>/2017/08/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/Ajax/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍Ajax知识体系。</p>
<p>参考一篇非常好的文章<a href="https://segmentfault.com/a/1190000008697448" target="_blank" rel="external">《Ajax知识体系大梳理》</a>，内容比较多，我就做一点关注点总结。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>Ajax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. </p>
<h2 id="浏览器为ajax做了什么"><a href="#浏览器为ajax做了什么" class="headerlink" title="浏览器为ajax做了什么"></a>浏览器为ajax做了什么</h2><p>1.标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest();
</code></pre>
<p>2.IE浏览器通过 <code>XMLHttpRequest</code> 或者 <code>ActiveXObject</code> 对象同样实现了ajax的功能.</p>
<h3 id="MSXML"><a href="#MSXML" class="headerlink" title="MSXML"></a>MSXML</h3><p>IE6及更低版本浏览器只能使用 <code>ActiveXObject</code> 对象来创建 XMLHttpRequest 对象实例. 创建时需要指明一个类似”Microsoft.XMLHTTP”这样的ProgID. </p>
<p>IE5及之后的浏览器均可以通过如下语句获取xhr对象:</p>
<pre><code class="javascript">var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3
var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用
</code></pre>
<h3 id="全平台兼容的XMLHttpRequest对象"><a href="#全平台兼容的XMLHttpRequest对象" class="headerlink" title="全平台兼容的XMLHttpRequest对象"></a>全平台兼容的XMLHttpRequest对象</h3><pre><code class="javascript">function getXHR(){
  var xhr = null;
  if(window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
      } catch (e) { 
        alert(&quot;您的浏览器暂不支持Ajax!&quot;);
      }
    }
  }
  return xhr;
}
</code></pre>
<h2 id="ajax有没有破坏js单线程机制"><a href="#ajax有没有破坏js单线程机制" class="headerlink" title="ajax有没有破坏js单线程机制"></a>ajax有没有破坏js单线程机制</h2><p>一般情况下, 浏览器有如下四种线程:</p>
<ul>
<li>GUI渲染线程</li>
<li>javascript引擎线程</li>
<li>浏览器事件触发线程</li>
<li>HTTP请求线程</li>
</ul>
<p>通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到<code>任务队列</code> 的末尾 , 等到js引擎空闲时, <code>任务队列</code> 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.</p>
<p><strong>浏览器中, js引擎线程会循环从 任务队列 中读取事件并且执行, 这种运行机制称作 Event Loop (事件循环).</strong></p>
<p>对于一个ajax请求, js引擎首先生成 <code>XMLHttpRequest</code> 实例对象, open过后再调用send方法. 至此, 所有的语句都是同步执行. 但从send方法内部开始, 浏览器为将要发生的网络请求创建了新的http请求线程, 这个线程独立于js引擎线程, 于是网络请求异步被发送出去了. 另一方面, js引擎并不会等待 ajax 发起的http请求收到结果, 而是直接顺序往下执行.</p>
<p>当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> (当然也可能触发onload, 或者 onerror等等) . 该回调事件并没有被立即执行, 而是被添加到 <code>任务队列</code> 的末尾. 直到js引擎空闲了, <code>任务队列</code> 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 <code>onreadystatechange</code> 事件.</p>
<p>在 <code>onreadystatechange</code> 事件内部, 有可能对dom进行操作. 此时浏览器便会挂起js引擎线程, 转而执行GUI渲染线程, 进行UI重绘(repaint)或者回流(reflow). 当js引擎重新执行时, GUI渲染线程又会被挂起, GUI更新将被保存起来, 等到js引擎空闲时立即被执行.</p>
<p>以上整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 <code>GUI渲染线程</code> 和 <code>js引擎线程</code> 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.</p>
<h2 id="ajax与setTimeout排队问题"><a href="#ajax与setTimeout排队问题" class="headerlink" title="ajax与setTimeout排队问题"></a>ajax与setTimeout排队问题</h2><p>由于ajax异步, setTimeout回调本应该最先被执行, 然而实际上, 一次ajax请求, 并非所有的部分都是异步的, 至少<strong>“readyState==1”的 <code>onreadystatechange</code> 回调以及 <code>onloadstart</code> 回调就是同步执行的</strong>. 因此它们的输出排在最前面.</p>
<h2 id="XMLHttpRequest-属性解读"><a href="#XMLHttpRequest-属性解读" class="headerlink" title="XMLHttpRequest 属性解读"></a>XMLHttpRequest 属性解读</h2><p>追根溯源, XMLHttpRequest 实例对象具有如下的继承关系. (下面以a&lt;&lt;b表示a继承b)</p>
<p><code>xhr</code> &lt;&lt; <code>XMLHttpRequest.prototype</code> &lt;&lt; <code>XMLHttpRequestEventTarget.prototype</code> &lt;&lt; <code>EventTarget.prototype</code> &lt;&lt; <code>Object.prototype</code></p>
<p>通常, 一个xhr实例对象拥有10个普通属性+9个方法.</p>
<h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>只读属性, readyState属性记录了ajax调用过程中所有可能的状态.</p>
<h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><p>onreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调</p>
<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.</p>
<h3 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h3><p>只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 <code>OK</code> . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 <code>Moved Permanently</code> , 302的 <code>Found</code> , 303的 <code>See Other</code> , 307 的 <code>Temporary Redirect</code> , 400的 <code>Bad Request</code> , 401的 <code>Unauthorized</code> 等等.</p>
<h3 id="onloadstart"><a href="#onloadstart" class="headerlink" title="onloadstart"></a>onloadstart</h3><p>onloadstart事件回调方法在ajax请求发送之前触发, 触发时机在 <code>readyState==1</code> 状态之后, <code>readyState==2</code> 状态之前.</p>
<h3 id="onprogress"><a href="#onprogress" class="headerlink" title="onprogress"></a>onprogress</h3><p>onprogress事件回调方法在 <code>readyState==3</code> 状态时开始触发, 默认传入 ProgressEvent 对象, 可通过 <code>e.loaded/e.total</code> 来计算加载资源的进度, 该方法用于获取资源的下载进度.</p>
<h3 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h3><p>onload事件回调方法在ajax请求成功后触发, 触发时机在 <code>readyState==4</code> 状态之后.</p>
<p>可用于捕捉到一个ajax异步请求的成功状态, 并且执行回调。</p>
<h3 id="onloadend"><a href="#onloadend" class="headerlink" title="onloadend"></a>onloadend</h3><p>onloadend事件回调方法在ajax请求完成后触发, 触发时机在 <code>readyState==4</code> 状态之后(收到响应时) 或者<code>readyState==2</code> 状态之后(未收到响应时).</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>timeout属性用于指定ajax的超时时长. </p>
<h3 id="ontimeout"><a href="#ontimeout" class="headerlink" title="ontimeout"></a>ontimeout</h3><p>ontimeout方法在ajax请求超时时触发, 通过它可以在ajax请求超时时做一些后续处理.</p>
<h3 id="response-responseText"><a href="#response-responseText" class="headerlink" title="response responseText"></a>response responseText</h3><p>均为只读属性, response表示服务器的响应内容, 相应的, responseText表示服务器响应内容的文本形式.</p>
<h3 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h3><p>只读属性, responseXML表示xml形式的响应数据, 缺省为null, 若数据不是有效的xml, 则会报错.</p>
<h3 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h3><p>responseType表示响应的类型, 缺省为空字符串, 可取 <code>&quot;arraybuffer&quot;</code> , <code>&quot;blob&quot;</code> , <code>&quot;document&quot;</code> , <code>&quot;json&quot;</code> , and <code>&quot;text&quot;</code> 共五种类型.</p>
<h3 id="responseURL"><a href="#responseURL" class="headerlink" title="responseURL"></a>responseURL</h3><p>responseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL.</p>
<h3 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h3><p>withCredentials是一个布尔值, 默认为false, 表示跨域请求中不发送cookies等信息.</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>abort方法用于取消ajax请求, 取消后, readyState 状态将被设置为 <code>0</code> (<code>UNSENT</code>). </p>
<h3 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader"></a>getResponseHeader</h3><p>getResponseHeader方法用于获取ajax响应头中指定name的值. </p>
<h3 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders"></a>getAllResponseHeaders</h3><p>getAllResponseHeaders方法用于获取所有安全的ajax响应头, 响应头以字符串形式返回. </p>
<h3 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h3><p>设置请求头</p>
<h3 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h3><p>onerror方法用于在ajax请求出错后执行. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时触发</p>
<h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><p>upload属性默认返回一个 <code>XMLHttpRequestUpload</code> 对象, 用于上传资源</p>
<h3 id="overrideMimeType"><a href="#overrideMimeType" class="headerlink" title="overrideMimeType"></a>overrideMimeType</h3><p>overrideMimeType方法用于强制指定response 的 MIME 类型, 即强制修改response的 <code>Content-Type</code> . </p>
<h2 id="XHR一级"><a href="#XHR一级" class="headerlink" title="XHR一级"></a>XHR一级</h2><p>XHR1时, xhr对象具有如下缺点:</p>
<ul>
<li>仅支持文本数据传输, 无法传输二进制数据.</li>
<li>传输数据时, 没有进度信息提示, 只能提示是否完成.</li>
<li>受浏览器 <code>同源策略</code> 限制, 只能请求同域资源.</li>
<li>没有超时机制, 不方便掌控ajax请求节奏.</li>
</ul>
<h2 id="XHR二级"><a href="#XHR二级" class="headerlink" title="XHR二级"></a>XHR二级</h2><p>XHR2针对XHR1的上述缺点做了如下改进:</p>
<ul>
<li>支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单.</li>
<li>提供进度提示, 可通过 <code>xhr.upload.onprogress</code> 事件回调方法获取传输进度.</li>
<li>依然受 <code>同源策略</code> 限制, 这个安全机制不会变. XHR2新提供 <code>Access-Control-Allow-Origin</code> 等headers, 设置为 <code>*</code> 时表示允许任何域名请求, 从而实现跨域CORS访问</li>
<li>可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.</li>
</ul>
<p>目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的.</p>
<h2 id="XDomainRequest"><a href="#XDomainRequest" class="headerlink" title="XDomainRequest"></a>XDomainRequest</h2><p>XDomainRequest 对象是IE8,9折腾出来的, 用于支持CORS请求非成熟的解决方案. 以至于IE10中直接移除了它, 并重新回到了 XMLHttpRequest 的怀抱.</p>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h2><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><h3 id="支持promise"><a href="#支持promise" class="headerlink" title="支持promise"></a>支持promise</h3><p>$.ajax() 方法返回jqXHR对象(jq1.5起), 如果使用的不是XMLHttpRequest对象时, 如jsonp请求, 返回的jqXHR对象将尽可能模拟原生的xhr. 从jq1.5起, 返回的jqXHR对象实现了promise接口.</p>
<h3 id="使用转换器"><a href="#使用转换器" class="headerlink" title="使用转换器"></a>使用转换器</h3><p>$.ajax() 的转换器可以将支持的数据类型映射到其它数据类型. 如果需要将自定义数据类型映射到已知的类型. 需要使用 <code>contents</code> 选项在响应的 “Content-Type” 和实际数据类型之间添加一个转换函数.</p>
<h3 id="事件触发顺序"><a href="#事件触发顺序" class="headerlink" title="事件触发顺序"></a>事件触发顺序</h3><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios Vs jquery</p>
<ul>
<li>Axios支持node, jquery并不支持.</li>
<li>Axios基于promise语法, jq3.0才开始全面支持.</li>
<li>Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.</li>
<li>vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.</li>
</ul>
<p>语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:</p>
<pre><code class="javascript">axios.get(&quot;https://api.github.com/users/louiszhai&quot;)
  .then(function(response){
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
</code></pre>
<p>除了get, 它还支持post, delete, head, put, patch, request请求. </p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p><a href="http://louiszhai.github.io/2016/11/02/fetch/" target="_blank" rel="external">Fetch进阶指南</a> .</p>
<h2 id="ajax跨域请求"><a href="#ajax跨域请求" class="headerlink" title="ajax跨域请求"></a>ajax跨域请求</h2><h3 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h3><p>实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)</p>
<h3 id="移动端CORS兼容性"><a href="#移动端CORS兼容性" class="headerlink" title="移动端CORS兼容性"></a>移动端CORS兼容性</h3><p>当前几乎所有的桌面浏览器(Internet Explorer 8+, Firefox 3.5+, Safari 4+和 Chrome 3+)都可通过名为跨域资源共享的协议支持ajax跨域调用.</p>
<p> CORS的技术在IOS Safari7.1及Android webview2.3中就早已支持, 即使低版本下webview的canvas在使用跨域的video或图片时会有问题, 也丝毫不影响CORS的在移动端的使用. </p>
<h3 id="CORS有关的headers"><a href="#CORS有关的headers" class="headerlink" title="CORS有关的headers"></a>CORS有关的headers</h3><h3 id="CORS请求"><a href="#CORS请求" class="headerlink" title="CORS请求"></a>CORS请求</h3><p>CORS请求分为两种, ① 简单请求; ② 非简单请求.</p>
<p>对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 <code>Origin</code> 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 <code>Access-Control-*</code> 等字段.</p>
<p>对于非简单请求, 比如Method为<code>POST</code>且Content-Type值为 <code>application/json</code> 的请求或者Method为 <code>PUT</code> 或 <code>DELETE</code> 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 <code>Access-Control-*</code> 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发).</p>
<h3 id="HTML启用CORS"><a href="#HTML启用CORS" class="headerlink" title="HTML启用CORS"></a>HTML启用CORS</h3><pre><code class="html">&lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;
</code></pre>
<h3 id="图片启用CORS"><a href="#图片启用CORS" class="headerlink" title="图片启用CORS"></a>图片启用CORS</h3><p>通常, 图片允许跨域访问, 也可以在canvas中使用跨域的图片, 但这样做会污染画布, 一旦画布受污染, 将无法读取其数据. 浏览器的这种安全机制规避了未经许可的远程服务器图片被滥用的风险.</p>
<p>因此如需在canvas中使用跨域的图片资源, 请参考如下apache配置片段(来自<a href="https://github.com/h5bp/server-configs-apache/blob/fc379c45f52a09dd41279dbf4e60ae281110a5b0/src/.htaccess#L36-L53" target="_blank" rel="external">HTML5 Boilerplate Apache server configs</a>).</p>
<h2 id="ajax文件上传"><a href="#ajax文件上传" class="headerlink" title="ajax文件上传"></a>ajax文件上传</h2><p>1) 为了上传文件, 我们得先选中一个文件. 一个type为file的input框就够了.</p>
<pre><code class="html">&lt;input id=&quot;input&quot; type=&quot;file&quot;&gt;
</code></pre>
<p>2) 然后用FormData对象包裹📦选中的文件.</p>
<pre><code class="javascript">var input = document.getElementById(&quot;input&quot;),
    formData = new FormData();
formData.append(&quot;file&quot;,input.files[0]);//key可以随意定义,只要后台能理解就行
</code></pre>
<p>3) 定义上传的URL, 以及方法. github上我搭建了一个 <a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="external">node-webserver</a>, 根据需要可以自行克隆下来npm start后便可调试本篇代码.</p>
<pre><code class="javascript">var url = &quot;http://localhost:10108/test&quot;,
    method = &quot;POST&quot;;
</code></pre>
<h3 id="js文件上传"><a href="#js文件上传" class="headerlink" title="js文件上传"></a>js文件上传</h3><p>4.1) 封装一个用于发送ajax请求的方法.</p>
<pre><code class="javascript">function ajax(url, method, data){
  var xhr = null;
  if(window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
      } catch (e) { 
        alert(&quot;您的浏览器暂不支持Ajax!&quot;);
      }
    }
  }
  xhr.onerror = function(e){
    console.log(e);
  }
  xhr.open(method, url);
  try{
    setTimeout(function(){
      xhr.send(data);
    });
  }catch(e){
    console.log(&#39;error:&#39;,e);
  }
  return xhr;
}
</code></pre>
<p>4.2) 上传文件并绑定事件.</p>
<pre><code class="javascript">var xhr = ajax(url, method, formData);
xhr.upload.onprogress = function(e){
  console.log(&quot;upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;);
};
xhr.upload.onload = function(){
  console.log(&quot;upload onload.&quot;);
};
xhr.onload = function(){
  console.log(&quot;onload.&quot;);
}
</code></pre>
<h3 id="fetch上传"><a href="#fetch上传" class="headerlink" title="fetch上传"></a>fetch上传</h3><p>5) fetch只要发送一个post请求, 并且body属性设置为formData即可. 遗憾的是, fetch无法跟踪上传的进度信息.</p>
<pre><code class="javascript">fetch(url, {
  method: method,
  body: formData
  }).then(function(res){
  console.log(res);
  }).catch(function(e){
  console.log(e);
});
</code></pre>
<h3 id="jquery文件上传"><a href="#jquery文件上传" class="headerlink" title="jquery文件上传"></a>jquery文件上传</h3><p>6) jq的ajax提供了xhr属性用于自定义各种事件.</p>
<pre><code class="javascript">$.ajax({
  type: method,
  url: url,
  data: formData,
  processData : false,
  contentType : false ,//必须false才会自动加上正确的Content-Type
  xhr: function(){
    var xhr = $.ajaxSettings.xhr();//实际上就是return new window.XMLHttpRequest()对象
    if(xhr.upload) {
      xhr.upload.addEventListener(&quot;progress&quot;, function(e){
        console.log(&quot;jq upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;);
      }, false);
      xhr.upload.addEventListener(&quot;load&quot;, function(){
        console.log(&quot;jq upload onload.&quot;);
      });
      xhr.addEventListener(&quot;load&quot;, function(){
        console.log(&quot;jq onload.&quot;);
      });
      return xhr;
    }
  }
});
</code></pre>
<h2 id="ajax请求二进制文件"><a href="#ajax请求二进制文件" class="headerlink" title="ajax请求二进制文件"></a>ajax请求二进制文件</h2><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>处理二进制文件主要使用的是H5的FileReader.</p>
<h2 id="如何等待多个ajax请求完成"><a href="#如何等待多个ajax请求完成" class="headerlink" title="如何等待多个ajax请求完成"></a>如何等待多个ajax请求完成</h2><p>原生js可以使用ES6新增的Promise.</p>
<p>这里先提供一个解析responses的函数.</p>
<pre><code class="javascript">function todo(responses){
  responses.forEach(function(response){
    response.json().then(function(res){
      console.log(res);
    });
  });
}
</code></pre>
<p>原生js使用 <code>Promise.all</code> 方法. 如下:</p>
<pre><code class="javascript">var p1 = fetch(&quot;http://localhost:10108/test1&quot;),
    p2 = fetch(&quot;http://localhost:10108/test2&quot;);
Promise.all([p1, p2]).then(function(responses){
  todo(responses);
  //TODO do somethings
});
//&quot;test1&quot;
//&quot;test2&quot;
</code></pre>
<p>jquery可以使用$.when方法. 该方法接受一个或多个Deferred对象作为参数, 只有全部成功才调用resolved状态的回调函数, 但只要其中有一个失败，就调用rejected状态的回调函数. 其实, jq的Deferred是基于 Promises/A规范实现, 但并非完全遵循. (传送门: <a href="http://www.css88.com/archives/4750/comment-page-1" target="_blank" rel="external">jQuery 中的 Deferred 和 Promises (2)</a> ).</p>
<pre><code class="javascript">var p1 = $.ajax(&quot;http://localhost:10108/test1&quot;),
    p2 = $.ajax(&quot;http://localhost:10108/test2&quot;);
$.when(p1, p2).then(function(res1, res2){
  console.log(res1);//[&quot;test1&quot;, &quot;success&quot;, Object]
  console.log(res2);//[&quot;test2&quot;, &quot;success&quot;, Object]
  //TODO do somethings
});
</code></pre>
<h2 id="ajax与history的兼容"><a href="#ajax与history的兼容" class="headerlink" title="ajax与history的兼容"></a>ajax与history的兼容</h2><p>如今, H5普及, pjax大行其道. pajax 就是 ajax+history.pushState 组合的一种技术. 使用它便可以无刷新通过浏览器前进和后退来改变页面内容.</p>
<p>IE8,9并不能使用 H5的history. 需要使用垫片 <a href="https://github.com/devote/HTML5-History-API" target="_blank" rel="external">HTML5 History API expansion for browsers not supporting pushState, replaceState</a> .</p>
<h3 id="pjax"><a href="#pjax" class="headerlink" title="pjax"></a>pjax</h3><p>pjax简单易用, 仅需要如下三个api:</p>
<ul>
<li>history.pushState(obj, title, url) 表示往页面history末尾新增一个历史项(history entry), 此时history.length会+1.</li>
<li>history.replaceState(obj, title, url) 表示替换当前历史项为新的历史项. 此时history.length保持不变.</li>
<li>window.onpopstate 仅在浏览器前进和后退时触发(history.go(1), history.back() 及location.href=”xxx” 均会触发), 此时可在history.state中拿到刚刚塞进去的state, 即obj对象(其他数据类型亦可).</li>
</ul>
<h2 id="ajax缓存处理"><a href="#ajax缓存处理" class="headerlink" title="ajax缓存处理"></a>ajax缓存处理</h2><p>js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存.</p>
<pre><code class="javascript">xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;);
xhr.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
//或者 URL 参数后加上  &quot;?timestamp=&quot; + new Date().getTime()
</code></pre>
<h2 id="ajax的错误处理"><a href="#ajax的错误处理" class="headerlink" title="ajax的错误处理"></a>ajax的错误处理</h2><p>前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外)</p>
<p>实际上, <code>$.ajax</code>方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 <code>$.ajax</code> 的error回调便会触发.</p>
<h2 id="ajax调试技巧"><a href="#ajax调试技巧" class="headerlink" title="ajax调试技巧"></a>ajax调试技巧</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><h2 id="后端接口测试技巧"><a href="#后端接口测试技巧" class="headerlink" title="后端接口测试技巧"></a>后端接口测试技巧</h2><h3 id="使用命令测试OPTIONS请求"><a href="#使用命令测试OPTIONS请求" class="headerlink" title="使用命令测试OPTIONS请求"></a>使用命令测试OPTIONS请求</h3><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><h2 id="ajax移动端兼容性"><a href="#ajax移动端兼容性" class="headerlink" title="ajax移动端兼容性"></a>ajax移动端兼容性</h2><p>移动端的支持性比较弱, 使用需谨慎. </p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p>
<h2 id="为什么要用ajax"><a href="#为什么要用ajax" class="headerlink" title="为什么要用ajax"></a>为什么要用ajax</h2><p>Ajax应用程序的优势在于：</p>
<ol>
<li>通过异步模式，提升了用户体验</li>
<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li>
<li>Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</li>
</ol>
<h2 id="介绍XMLhttprequest对象"><a href="#介绍XMLhttprequest对象" class="headerlink" title="介绍XMLhttprequest对象"></a>介绍XMLhttprequest对象</h2><p>Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。</p>
<h2 id="AJAX请求总共有多少种CALLBACK"><a href="#AJAX请求总共有多少种CALLBACK" class="headerlink" title="AJAX请求总共有多少种CALLBACK"></a>AJAX请求总共有多少种CALLBACK</h2><p>Ajax请求总共有八种Callback</p>
<ul>
<li>onSuccess</li>
<li>onFailure</li>
<li>onUninitialized</li>
<li>onLoading</li>
<li>onLoaded</li>
<li>onInteractive</li>
<li>onComplete</li>
<li>onException</li>
</ul>
<h2 id="在浏览器端如何得到服务器端响应的XML数据"><a href="#在浏览器端如何得到服务器端响应的XML数据" class="headerlink" title="在浏览器端如何得到服务器端响应的XML数据"></a>在浏览器端如何得到服务器端响应的XML数据</h2><p>XMLHttpRequest对象的responseXMl属性</p>
<h2 id="XMLHttpRequest对象在IE和Firefox中创建方式"><a href="#XMLHttpRequest对象在IE和Firefox中创建方式" class="headerlink" title="XMLHttpRequest对象在IE和Firefox中创建方式"></a>XMLHttpRequest对象在IE和Firefox中创建方式</h2><p>IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到</p>
<h2 id="XMLHttpRequest对象的常用方法和属性"><a href="#XMLHttpRequest对象的常用方法和属性" class="headerlink" title="XMLHttpRequest对象的常用方法和属性"></a>XMLHttpRequest对象的常用方法和属性</h2><p><strong>方法</strong></p>
<p><code>open(“method”,”URL”)</code> 建立对服务器的调用，第一个参数是HTTP请求方式可以为GET，POST或任何服务器所支持的您想调用的方式。第二个参数是请求页面的URL。</p>
<p><code>send()</code>方法，发送具体请求</p>
<p><code>abort()</code>方法，停止当前请求</p>
<p><strong>熟悉</strong></p>
<p><code>readyState</code>属性：请求的状态，有5个可取值</p>
<ul>
<li>0=未初始化</li>
<li>1=正在加载</li>
<li>2=以加载</li>
<li>3=交互中</li>
<li>4=完成</li>
</ul>
<p><code>responseText</code>属性：服务器的响应，表示为一个串</p>
<p><code>reponseXML</code> 属性：服务器的响应，表示为XML</p>
<p><code>status</code>属性：服务器的HTTP状态码，200对应ok，400对应error</p>
<h2 id="AJAX有哪些优点和缺点？"><a href="#AJAX有哪些优点和缺点？" class="headerlink" title="AJAX有哪些优点和缺点？"></a>AJAX有哪些优点和缺点？</h2><p><strong>优点</strong></p>
<ol>
<li>最大的一点是页面无刷新，用户的体验非常好。</li>
<li>使用异步方式与服务器通信，具有更加迅速的响应能力。</li>
<li>可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</li>
<li>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>ajax不支持浏览器back按钮。</li>
<li>安全问题 AJAX暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>破坏了程序的异常机制。</li>
<li>不容易调试。</li>
</ol>
<h2 id="jquery-ajax实现"><a href="#jquery-ajax实现" class="headerlink" title="jquery ajax实现"></a>jquery ajax实现</h2><pre><code class="javascript">$.ajax({
    url:&#39;/comm/test1.php&#39;,
    type:&#39;POST&#39;, //GET
    async:true,    //或false,是否异步
    data:{
        name:&#39;yang&#39;,age:25
    },
    timeout:5000,    //超时时间
    dataType:&#39;json&#39;,    //返回的数据格式：json/xml/html/script/jsonp/text
    beforeSend:function(xhr){
        console.log(xhr)
        console.log(&#39;发送前&#39;)
    },
    success:function(data,textStatus,jqXHR){
        console.log(data)
        console.log(textStatus)
        console.log(jqXHR)
    },
    error:function(xhr,textStatus){
        console.log(&#39;错误&#39;)
        console.log(xhr)
        console.log(textStatus)
    },
    complete:function(){
        console.log(&#39;结束&#39;)
    }
})
</code></pre>
<h2 id="原生js-ajax实现"><a href="#原生js-ajax实现" class="headerlink" title="原生js ajax实现"></a>原生js ajax实现</h2><pre><code class="javascript">$(&#39;#send&#39;).click(function(){
    //请求的5个阶段，对应readyState的值
        //0: 未初始化，send方法未调用；
        //1: 正在发送请求，send方法已调用；
        //2: 请求发送完毕，send方法执行完毕；
        //3: 正在解析响应内容；
        //4: 响应内容解析完毕；
    var data = &#39;name=yang&#39;;
    var xhr = new XMLHttpRequest();   //创建一个ajax对象
    xhr.onreadystatechange = function(event){    //对ajax对象进行监听
        if(xhr.readyState == 4){    //4表示解析完毕
            if(xhr.status == 200){    //200为正常返回
                console.log(xhr)
            }
        }
    };
    xhr.open(&#39;POST&#39;,&#39;url&#39;,true);    //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步
    xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);    //可有可无
    xhr.send(data);        //发送
});
</code></pre>
<h2 id="与-post-get-getJSON-有什么不同"><a href="#与-post-get-getJSON-有什么不同" class="headerlink" title="与$.post , $.get ,$.getJSON 有什么不同"></a>与$.post , $.get ,$.getJSON 有什么不同</h2><p>\$.post，这个函数其实就是对\$.ajax进行了更进一步的封装，减少了参数，简化了操作，但是运用的范围更小了。\$.post简化了数据提交方式，只能采用POST方式提交。只能是异步访问服务器，不能同步访问，不能进行错误处理。在满足这些情况下，我们可以使用这个函数来方便我们的编程，它的主要几个参数，像method，async等进行了默认设置，我们不可以改变的。</p>
<h2 id="jquery-ajax中都支持哪些数据类型"><a href="#jquery-ajax中都支持哪些数据类型" class="headerlink" title="jquery ajax中都支持哪些数据类型"></a>jquery ajax中都支持哪些数据类型</h2><blockquote>
<p>DataType<br>类型：String<br>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。</p>
</blockquote>
<p>可用值: json/xml/html/script/jsonp/text</p>
<h2 id="json-和-jsonp-的区别"><a href="#json-和-jsonp-的区别" class="headerlink" title="json 和 jsonp 的区别"></a>json 和 jsonp 的区别</h2><p>SON是一种数据交换格式，而JSONP是一种s创造出的一种非官方跨域数据交互协议。 </p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000008697448" target="_blank" rel="external">Ajax知识体系大梳理</a></li>
<li><a href="http://blog.csdn.net/chow__zh/article/details/9149811" target="_blank" rel="external">经典的20道AJAX面试题</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WEB安全]]></title>
      <url>/2017/08/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/WEB%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍web安全。</p>
<p>工作中有接触过一部分，系统整理一下。后续需要补上攻防代码。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><p>Node.js 的 <code>crypto</code> 模块封装了诸多的加密功能, 包括 OpenSSL 的哈希、HMAC、加密、解密、签名和验证函数等.</p>
<p>在客户端加密, 是增加传输的过程中被第三方嗅探到密码后破解的成本. 对于游戏, 在客户端加密是防止外挂/破解等. 在服务端加密 (如 md5) 是避免管理数据库的 DBA 或者攻击者攻击数据库之后直接拿到明文密码, 从而提高安全性.</p>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p> SSL (Secure Socket Layer)的主要用途是:</p>
<ol>
<li>认证用户和服务器, 确保数据发送到正确的客户机和服务器;</li>
<li>加密数据以防止数据中途被窃取;</li>
<li>维护数据的完整性, 确保数据在传输过程中不被改变.</li>
</ol>
<p>存在三个特性:</p>
<ul>
<li>机密性：SSL协议使用密钥加密通信数据</li>
<li>可靠性：服务器和客户都会被认证, 客户的认证是可选的</li>
<li><p>完整性：SSL协议会对传送的数据进行完整性检查</p>
<p>IETF 把 SSL 标准化/强化. 标准化之后的名称改为传输层安全协议 (Transport Layer Security, TLS). 很多相关的文章都把这两者并列称呼 (TLS/SSL), 因为这两者可以视作同一个东西的不同阶段.</p>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>公钥基础设施 (Public Key Infrastructure, PKI) 是一种遵循标准的, 利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范. 其基础建置包含认证中心 (Certification Authority, CA) 、注册中心 (Register Authority, RA) 、目录服务 (Directory Service, DS) 服务器.</p>
<p>由 RA 统筹、审核用户的证书申请, 将证书申请送至 CA 处理后发出证书, 并将证书公告至 DS 中. 在使用证书的过程中, 除了对证书的信任关系与证书本身的正确性做检查外, 并透过产生和发布证书废止列表 (Certificate Revocation List, CRL) 对证书的状态做确认检查, 了解证书是否因某种原因而遭废弃. 证书就像是个人的身分证, 其内容包括证书序号、用户名称、公开金钥 (Public Key) 、证书有效期限等.</p>
<p>在 TLS/SLL 中你可以使用 OpenSSL 来生成 TLS/SSL 传输时用来认证的 public/private key. 不过这个 public/private key 是自己生成的, 而通过 PKI 基础设施可以获得权威的第三方证书 (key) 从而加密 HTTP 传输安全. 目前博客圈子里比较流行的是 <a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt 签发免费的 HTTPS 证书</a>.</p>
<p>需要注意的是, 如果 PKI 受到攻击, 那么 HTTPS 也一样不安全.</p>
<p>此外有的 CA 机构以邮件方式认证, 那么当某个网站的邮件服务收到攻击/渗透, 那么攻击者也可能以此从 CA 机构获取权威的正确的证书.</p>
<h3 id="CA工作原理"><a href="#CA工作原理" class="headerlink" title="CA工作原理"></a>CA工作原理</h3><p>现在假设客户A向银行B传送数字信息，为了保证信息传送的真实性、完整性和不可否认性，需要对要传送的信息进行数字加密和数字签名，其传送过程如下： </p>
<ul>
<li>客户A准备好要传送的数字信息（明文）。（<strong>准备明文</strong>） </li>
</ul>
<ul>
<li>客户A对数字信息进行哈希（hash）运算，得到一个信息摘要。（<strong>准备摘要</strong>） </li>
</ul>
<ul>
<li>客户A用自己的私钥（SK）对信息摘要进行加密得到客户A的数字签名，并将其附在数字信息上。（<strong>用私钥对数字信息进行数字签名</strong>）　 </li>
<li>客户A随机产生一个加密密钥（DES密钥），并用此密钥对要发送的信息进行加密，形成密文。（<strong>生成密文</strong>） </li>
<li>客户A用双方共有的公钥（PK）对刚才随机产生的加密密钥进行加密，将加密后的DES密钥连同密文一起传送给乙。（<strong>用公钥对DES密钥进行加密</strong>）　　 </li>
<li>银行B收到客户A传送过来的密文和加过密的DES密钥，先用自己的私钥（SK）对加密的DES密钥进行解密，得到DES密钥。（<strong>用私钥对DES密钥解密</strong>）　　 </li>
<li>银行B然后用DES密钥对收到的密文进行解密，得到明文的数字信息，然后将DES密钥抛弃（即DES密钥作废）。（<strong>解密文</strong>）　　 </li>
<li>银行B用双方共有的公钥（PK）对客户A的数字签名进行解密，得到信息摘要。银行B用相同的hash算法对收到的明文再进行一次hash运算，得到一个新的信息摘要。　　 （<strong>用公钥解密数字签名</strong>） </li>
<li>银行B将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。（<strong>对比信息摘要和信息</strong>） </li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>跨站脚本 (Cross-Site Scripting, XSS) 是一种代码注入方式， 其注入方式很简单包括但不限于 JavaScript / VBScript / CSS / Flash 等.</p>
<p>当其他用户浏览到这些网页时, 就会执行这些恶意脚本, 对用户进行 Cookie 窃取/会话劫持/钓鱼欺骗等各种攻击. 其原理, 如使用 js 脚本收集当前用户环境的信息 (Cookie 等), 然后通过 img.src, Ajax, onclick/onload/onerror 事件等方式将用户数据传递到攻击者的服务器上. </p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><strong>反射型XSS</strong>:非持久化，欺骗用户去点击链接,攻击代码包含在url中,被用户点击之后执行攻击代码.</li>
<li><strong>存储型XSS</strong>:持久型,攻击提交恶意代码到服务器，服务器存储该段代码,这样当其他用户请求后，服务器返回并发给用户，用户浏览此类页面时就可能受到攻击。例如:恶意用户的HTML或JS输入服务器-&gt;进入数据库-&gt;服务器响应时查询数据库-&gt;用户浏览器。</li>
</ul>
<h3 id="防范与过滤"><a href="#防范与过滤" class="headerlink" title="防范与过滤"></a>防范与过滤</h3><ul>
<li>输入编码过滤:对于每一个输入，在客户端和服务器端验证是否合法字符，长度是否合法，格式是否正确,对字符进行转义.非法字符过滤.</li>
<li>输出编码过滤:对所有要动态输出到页面的内容，<strong>进行相关的编码和转义</strong>.主要有HTML字符过滤和转义, JS脚本转义过滤. url转义过滤.</li>
<li>设置http-only,避免攻击脚本读取cookie.</li>
</ul>
<h3 id="攻防流程"><a href="#攻防流程" class="headerlink" title="攻防流程"></a>攻防流程</h3><h4 id="升级攻击"><a href="#升级攻击" class="headerlink" title="升级攻击"></a>升级攻击</h4><h5 id="append的利用"><a href="#append的利用" class="headerlink" title="append的利用"></a>append的利用</h5><p>直接给innerHTML赋值一段js，是无法被执行的。但是，jquery的append可以做到，究其原因，就是因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍。jquery的append使用的方式也是innerHTML。而innerHTML是会将unicode码转换为字符实体的。</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
    $username=&quot;\u003cscript\u003ealert(&#39;okok&#39;);&quot;;
?&gt;
$(&#39;#username_info&#39;).append(&quot;&lt;?php echo htmlentities($username);?&gt;&quot;);
</code></pre>
<p>虽然进行了转义，注入的代码还是会再次被执行。</p>
<h5 id="img标签的再次利用"><a href="#img标签的再次利用" class="headerlink" title="img标签的再次利用"></a>img标签的再次利用</h5><p>img标签，在加载图片失败的时候，会调用该元素上的onerror事件。我们正可以利用这种方式来进行攻击。</p>
<p><strong>Case</strong></p>
<pre><code class="php">&lt;?php
    $imgsrc=&quot;\&quot; onerror=\&quot;javascript:alert(&#39;侯医生&#39;);\&quot;&quot;;
?&gt;
</code></pre>
<p>解决方法：接着进行转义</p>
<pre><code class="javascript">&lt;img src=&quot;&lt;?php echo htmlentities($imgsrc);?&gt;&quot; /&gt;
</code></pre>
<h5 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h5><p>innerHTML赋值的script标签，不会被执行，但是innerHTML赋值一个img标签是可以被识别的。我们把img标签的左右尖括号，使用unicode进行伪装，让转义方法认不出来，即使innerHTML也可以利用上了</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
    $username=&quot;\u003cimg src=\&#39;\&#39; onerror=javascript:alert(\&#39;okok\&#39;);\u003e&quot;;
?&gt;
&lt;script&gt;
      document.getElementById(&#39;username_info&#39;).innerHTML = &quot;&lt;?php echo htmlentities($username);?&gt;&quot;;
&lt;/script&gt;
</code></pre>
<h4 id="升级防御"><a href="#升级防御" class="headerlink" title="升级防御"></a>升级防御</h4><p>将输出的字符串中的<code>\</code>反斜杠进行转义(json转义)。这样，<code>\</code>就不会被当做unicode码的开头来被处理了。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">document.getElementById(&#39;username_info&#39;).innerHTML = &lt;?php echo json_encode(htmlentities($username));?&gt;;
</code></pre>
<h4 id="XSS再升级"><a href="#XSS再升级" class="headerlink" title="XSS再升级"></a>XSS再升级</h4><p>有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。</p>
<p><strong>Case</strong></p>
<pre><code class="html">&lt;script&gt;
  var param = /=(.+)$/.exec(location.search);
  var value = decodeURIComponent(param[1]);
  $(&#39;#username_info&#39;).append(value);
&lt;/script&gt;
</code></pre>
<h4 id="防御再次升级"><a href="#防御再次升级" class="headerlink" title="防御再次升级"></a>防御再次升级</h4><p>这种从url中获取的信息，最好由后端获取，在前端转义后再行输出</p>
<p>使用url中的参数的时候要小心，更不要拿URL中的参数去eval。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">&lt;script&gt;
    var value = decodeURIComponent(&quot;&lt;?php echo htmlentities($_GET[&#39;username&#39;]);?&gt;&quot;);
    $(&#39;#username_info&#39;).append(value);
&lt;/script&gt;
</code></pre>
<h4 id="保护好你的cookie"><a href="#保护好你的cookie" class="headerlink" title="保护好你的cookie"></a>保护好你的cookie</h4><p>使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。</p>
<h3 id="CPS-策略"><a href="#CPS-策略" class="headerlink" title="CPS 策略"></a>CPS 策略</h3><p>计算脚本的 hashes 值，设置 CSP 头</p>
<p>策略指令可以参见 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP Policy Directives</a>以及<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="external">阮一峰的博文</a>, <a href="https://imququ.com/post/content-security-policy-reference.html" target="_blank" rel="external">屈大神的博文</a></p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="什么是CSRF攻击？"><a href="#什么是CSRF攻击？" class="headerlink" title="什么是CSRF攻击？"></a>什么是CSRF攻击？</h3><p>跨站请求伪造 (Cross-Site Request Forgery) 是一种伪造跨站请求的攻击方式.</p>
<p>例如利用你在 A 站 (攻击目标) 的 cookie / 权限等, 在 B 站 (恶意/钓鱼网站) 拼装 A 站的请求.</p>
<h3 id="如何攻击？"><a href="#如何攻击？" class="headerlink" title="如何攻击？"></a>如何攻击？</h3><h4 id="要合理使用post与get"><a href="#要合理使用post与get" class="headerlink" title="要合理使用post与get"></a>要合理使用post与get</h4><p>通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。</p>
<p><strong>Case</strong></p>
<p>你开发的网站中，有一个购买商品的操作，而商品ID图个省事儿，就使用了url中的get参数。</p>
<pre><code class="php+HTML">&lt;?php
// 从cookie中获取用户名，看似稳妥
$username = $_COOKIE[&#39;username&#39;];
$productId = $_GET[&#39;pid&#39;];
?&gt;

&lt;?php
echo $username . &#39;买入商品：&#39; . $productId;
?&gt;

//黑客的网站
&lt;img src=&quot;http://localhost:8082/lab/xsrflab/submit.php?pid=1&quot; /&gt;
</code></pre>
<p>所以，我们日常的开发，还是要遵循提交业务，严格按照post请求去做的。更不要使用jsonp去做提交型的接口，这样非常的危险。</p>
<h4 id="csrf攻击升级"><a href="#csrf攻击升级" class="headerlink" title="csrf攻击升级"></a>csrf攻击升级</h4><p>如果你使用了post请求来处理关键业务的，还是有办法可以破解的。</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
$username = $_COOKIE[&#39;username&#39;];
// 换为post了，可以规避黑客直接的提交
$productId = $_POST[&#39;pid&#39;];
?&gt;

&lt;?php
echo $username . &#39;买入商品：&#39; . $productId;
?&gt;

//黑客的网站
&lt;button id=&quot;clickme&quot;&gt;点我看相册&lt;/button&gt;
&lt;script&gt;
  $(&#39;#clickme&#39;).on(&#39;click&#39;, function () {
    // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。
    $(&#39;#myform&#39;).submit();
  });
&lt;/script&gt;
&lt;form id=&quot;myform&quot; style=&quot;display:none;&quot; target=&quot;myformer&quot; method=&quot;post&quot; action=&quot;http://myhost:8082/lab/xsrflab/submit.php&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;1&quot;&gt;
&lt;/form&gt;
&lt;iframe name=&quot;myformer&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><strong>这种情况如何防御？</strong></p>
<p>最简单的办法就是加<strong>验证码</strong>，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作</p>
<p>另一种方式，就是在用访问的页面中，都种下验证用的<strong>token</strong>，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ol>
<li>在 HTTP 头中自定义属性并验证</li>
<li>检查 CSRF token.</li>
<li>cookie中加入hash随机数.</li>
<li>通过检查来过滤简单的 CSRF 攻击, 主要检查一下两个 header:</li>
</ol>
<ul>
<li><p>Origin Header</p>
</li>
<li><p>Referer Header</p>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. 在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容.</p>
<p>目前比较常见的是在公共场所放置精心准备的免费 wifi, 劫持/监控通过该 wifi 的流量. 或者攻击路由器, 连上你家 wifi 攻破你家 wifi 之后在上面劫持流量等.</p>
<p>对于通信过程中的 MITM, 常见的方案是通过 PKI / TLS 预防, 及时是通过存在第三方中间人的 wifi 你通过 HTTPS 访问的页面依旧是安全的. 而 HTTP 协议是明文传输, 则没有任何防护可言.</p>
<p>如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。</p>
<p>不常见的还有强力的互相认证, 你确认他之后, 他也确认你一下; 延迟测试, 统计传输时间, 如果通讯延迟过高则认为可能存在第三方中间人; 等等.</p>
<h2 id="SQL-NoSQL-注入"><a href="#SQL-NoSQL-注入" class="headerlink" title="SQL/NoSQL 注入"></a>SQL/NoSQL 注入</h2><p>注入攻击是指当所执行的一些操作中有部分由用户传入时, 用户可以将其恶意逻辑注入到操作中. 当你使用 eval, new Function 等方式执行的字符串中有用户输入的部分时, 就可能被注入攻击. 上文中的 XSS 就属于一种注入攻击. </p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>Sql 注入是网站常见的一种注入攻击方式. 其原因主要是由于登录时需要验证用户名/密码</p>
<p><strong>Case</strong></p>
<p>例如上传密码为 <code>&#39;; DROP TABLE users; --</code> 使得最终执行的内容为:</p>
<pre><code class="sql">SELECT * FROM users WHERE usernae = &#39;myName&#39; AND password = &#39;&#39;; DROP TABLE users; --&#39;;
</code></pre>
<p>其能实现的功能, 包括但不限于删除数据 (经济损失), 篡改数据 (密码等), 窃取数据 (网站管理权限, 用户数据) 等. </p>
<p>防治手段常见于:</p>
<ul>
<li>给表名/字段名加前缀 (避免被猜到)</li>
<li>报错隐藏表信息 (避免被看到, 12306 早起就出现过的问题)</li>
<li>过滤可以拼接 SQL 的关键字符</li>
<li>对用户输入进行转义</li>
<li>验证用户输入的类型 (避免 limit, order by 等注入)</li>
<li>等…</li>
</ul>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p><strong>Case</strong></p>
<pre><code class="javascript">let {user, pass, age} = ctx.query;

db.collection.find({
  user, pass,
  $where: `this.age &gt;= ${age}`
})
</code></pre>
<h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><blockquote>
<p>DDoS即Distributed Denial of Service，分布式拒绝服务。也就是攻击者借助或者利用服务器技术，将多个计算机（肉鸡或僵尸机）联合起来作为攻击平台，对一个或者多个目标服务器，同一时间发送大量垃圾信息，或利用某种干扰信息的方式，导致目标服务器无法及时响应正常用户正常请求，或者直接导致目标服务器宕机，从而无法为正常用户提供服务的一种攻击行为。</p>
</blockquote>
<p>攻击方式:</p>
<ul>
<li>端口扫描攻击</li>
<li>ping洪水（flooding）攻击</li>
<li>SYN洪水（flooding）攻击</li>
<li>FTP跳转攻击</li>
</ul>
<p>防范手段:</p>
<ul>
<li>保证服务器系统的安全,确保服务器软件没有任何漏洞，防止攻击者入侵。</li>
<li>确保服务器采用最新系统，并打上安全补丁。</li>
<li>在服务器上删除未使用的服务，关闭未使用的端口。</li>
<li>对于服务器上运行的网站，确保其打了最新的补丁，没有安全漏洞。</li>
<li>隐藏服务器的真实IP地址</li>
</ul>
<h2 id="通用防范措施"><a href="#通用防范措施" class="headerlink" title="通用防范措施"></a>通用防范措施</h2><ol>
<li>开发时要提防用户产生的内容，要对用户输入的信息进行层层检测</li>
<li>要注意对用户的输出内容进行过滤(进行转义等)</li>
<li>重要的内容记得要加密传输(无论是利用https也好，自己加密也好)</li>
<li>get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。</li>
<li>对于URL上携带的信息，要谨慎使用。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000010913697" target="_blank" rel="external">前端需要知道的web安全知识</a></li>
<li><a href="http://wlh269.iteye.com/blog/733398" target="_blank" rel="external">CA认证简单介绍和工作流程</a></li>
<li><a href="https://segmentfault.com/a/1190000006672214" target="_blank" rel="external">[聊一聊系列]聊一聊WEB前端安全那些事儿</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WEB安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>/2017/06/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍跨域的知识</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>页面请求的url地址，必须与浏览器上url地址处于同域上（即域名，端口，协议相同）。</p>
<p>JS出于安全，不允许跨域调用其他页面的对象。</p>
<ul>
<li>其限制之一是不能通过ajax的方法去请求不同源中的文档。 </li>
<li>第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。</li>
</ul>
<p>特别注意两点：</p>
<ul>
<li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的</li>
<li>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名 和 端口 必须匹配”。</li>
</ul>
<p><strong>Case</strong></p>
<p>域名和域名对应ip，不允许：<code>http://www.a.com/a.js</code> 与 <code>http://70.32.92.74/b.js</code></p>
<p>主域相同，子域不同，不允许：<code>http://www.a.com/a.js</code> 与 <code>http://script.a.com/b.js</code></p>
<p>同一域名，不同二级域名，不允许（cookie这种情况下也不允许访问)：<code>http://www.a.com/a.js</code> 与 <code>http://a.com/b.js</code></p>
<h2 id="解决跨域请求的方式"><a href="#解决跨域请求的方式" class="headerlink" title="解决跨域请求的方式"></a>解决跨域请求的方式</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="Ans1"><a href="#Ans1" class="headerlink" title="Ans1"></a>Ans1</h5><p>ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>
<h5 id="Ans2"><a href="#Ans2" class="headerlink" title="Ans2"></a>Ans2</h5><p>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：</p>
<pre><code class="javascript"> callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})
</code></pre>
<p>这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。  </p>
<h5 id="Ans3"><a href="#Ans3" class="headerlink" title="Ans3"></a>Ans3</h5><p>JSONP是一种非正式传输协议，该协议的一个要点就是<strong>允许用户传递一个callback参数给服务端</strong>，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1. $.ajax"></a>1. $.ajax</h5><p><strong>Case</strong></p>
<p>index.html</p>
<pre><code class="javascript">&lt;script&gt;  
    $.ajax({  
        url:&quot;http://localhost:3000/users/userlist&quot;,  
        type:&quot;get&quot;,  
        dataType:&quot;jsonp&quot;,
        dataFilter:function(json){    
          console.log(json);  
          return json;    
        },
        success:function(data){  
            console.log(data);  
        },
        error:function(XMLHttpRequest, textStatus, errorThrown){
          console.log(XMLHttpRequest.status);
          console.log(XMLHttpRequest.readyState);
          console.log(textStatus);
        }  
    });  
&lt;/script&gt;
</code></pre>
<p>Node.js 服务器代码</p>
<pre><code class="javascript">router.get(&quot;/userlist&quot;, function (req, res, next) {  
    var callback=req.query[&quot;callback&quot;];  
    var user = {name: &#39;Mr.Cao&#39;, gender: &#39;male&#39;, career: &#39;IT Education&#39;};  
    res.write(callback+&quot;(&quot;+ JSON.stringify(user)+&quot;)&quot;);  
    res.end();  
});
</code></pre>
<h5 id="2-getJSON"><a href="#2-getJSON" class="headerlink" title="2. $.getJSON"></a>2. $.getJSON</h5><p>jQuery的<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<h5 id="3-原生实现"><a href="#3-原生实现" class="headerlink" title="3. 原生实现"></a>3. 原生实现</h5><p><strong>Case</strong></p>
<p>假设要传输的数据 data 格式如下：</p>
<pre><code class="json">{
    name: &quot;chiaki&quot;,
    id&quot;: &quot;3001&quot;
}
</code></pre>
<p>由于是通过 <code>script</code> 标签进行请求，所以上述传输过程根本上是以下的形式：</p>
<pre><code class="html">&lt;script src = &#39;http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032&#39;&gt;&lt;/script&gt;
</code></pre>
<p><em>服务器 3000</em>请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback：</p>
<pre><code class="html">&lt;script src = &#39;http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback&#39;&gt;&lt;/script&gt;

function jsonpCallback(data) {
    console.log(&quot;jsonpCallback: &quot;+data.name)
}
</code></pre>
<p><em>服务器 3001</em>上对应的处理函数：</p>
<pre><code class="javascript">app.get(&#39;/jsonServerResponse&#39;, function(req, res) {
    var cb = req.query.jsonp //这里得到请求页面的回调函数
    console.log(cb)
      //思考一下为什么这里要这样写
    var data = &#39;var data = {&#39; + &#39;name: $(&quot;#name&quot;).val() + &quot; - server 3001 jsonp process&quot;,&#39; + &#39;id: $(&quot;#id&quot;).val() + &quot; - server 3001 jsonp process&quot;&#39; + &#39;};&#39;
    var debug = &#39;console.log(data);&#39; //打印var data=&quot;&quot;;
    var callback = &#39;$(&quot;#submit&quot;).click(function() {&#39; + data + cb + &#39;(data);&#39; + debug + &#39;});&#39; 
    res.send(callback) //返回的是一个点击按钮的事件  
    res.end()
})
</code></pre>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>这种方式无法发送post请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用比较方便；它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；</li>
<li>兼容性更好，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>在请求完毕后可以通过调用callback的方式回传结果。</li>
</ul>
<h3 id="document-domain跨子域"><a href="#document-domain跨子域" class="headerlink" title="document.domain跨子域"></a>document.domain跨子域</h3><p>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    function test(){
        var iframe = document.getElementById(&#39;￼ifame&#39;);
        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的
        var doc = win.document;//这里获取不到iframe里的document对象
        var name = win.name;//这里同样获取不到window对象的name属性
    }
&lt;/script&gt;
&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;
</code></pre>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a>和<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>
</blockquote>
<p>在页面<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 中设置document.domain:</p>
<pre><code class="javascript">&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    document.domain = &#39;damonare.cn&#39;;//设置成主域
    function test(){
        alert(document.getElementById(&#39;￼iframe&#39;).contentWindow);//contentWindow 可取得子窗口的 window 对象
    }
&lt;/script&gt;
</code></pre>
<p>在页面 <a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>  中也设置document.domain:</p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    document.domain = &#39;damonare.cn&#39;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>Note:修改document.domain的方法只适用于不同子域的框架间的交互。</strong></p>
<p><strong>附：主域名与子域名的区别</strong></p>
<p>主域名：</p>
<p>由两个或两个以上的字母构成，中间由点号隔开，整个域名只有1个点号。比如：csdn.net</p>
<p>子域名：</p>
<p>是在主域名之下的域名，域名内容会有多个点号。比如：blog.csdn.net </p>
</blockquote>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>如果修改了document.domain，则在某些机器上的IE678里，获取location.href有权限异常。</li>
<li>如果页面修改了document.domain，则它包含的iframe，必须也设domain，才能进行交互。就算是同域的页面也必须要设。</li>
<li>设置document.doamin，也会影响到其它跟iframe有关的功能。典型的功能如：富文本编辑器（因为是iframe来做富文本编辑器的）、ajax的前进后退（因为IE67要用到iframe，参见：<a href="http://blog.sina.com.cn/s/blog_6e7f61f30100sddm.html" target="_blank" rel="external">IE6与location.hash和Ajax历史记录</a>）</li>
<li>设置document.doamin，导致ie6下无法向一个iframe提交表单。这一篇文章里列了问题象与解决方案：<a href="http://www.cnblogs.com/pigtail/archive/2012/06/06/2528136.html" target="_blank" rel="external">IE6与location.hash和Ajax历史记录</a></li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。</li>
<li>如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</li>
</ol>
<h3 id="location-hash（两个iframe之间），又称FIM"><a href="#location-hash（两个iframe之间），又称FIM" class="headerlink" title="location.hash（两个iframe之间），又称FIM"></a>location.hash（两个iframe之间），又称FIM</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，<strong>URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录</strong>。此方法的<strong>原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息</strong>（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），<strong>并通过监听自己的URL的变化来接收消息。</strong></p>
</blockquote>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>造成一些不必要的浏览器历史记录</li>
<li>有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变</li>
<li>数据直接暴露在了url中，数据容量和类型都有限等。</li>
</ul>
<p><strong>Case</strong></p>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。</p>
<ul>
<li>a.html传送数据到b.html</li>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
<li>b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”<a href="http://www.baidu.com/proxy.html#data”" target="_blank" rel="external">http://www.baidu.com/proxy.html#data”</a></li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
</ul>
<p>b.html页面的关键代码如下:</p>
<pre><code class="javascript">try {  
    parent.location.hash = &#39;data&#39;;  
} catch (e) {  
    // ie、chrome的安全机制无法修改parent.location.hash，  
    var ifrproxy = document.createElement(&#39;iframe&#39;);  
    ifrproxy.style.display = &#39;none&#39;;  
    ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;;  
    document.body.appendChild(ifrproxy);  
}
</code></pre>
<p>proxy.html页面的关键代码如下 :</p>
<pre><code class="javascript">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  
parent.parent.location.hash = self.location.hash.substring(1);
</code></pre>
<h3 id="通过CORS跨域"><a href="#通过CORS跨域" class="headerlink" title="通过CORS跨域"></a>通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>CORS要前后端同时做配置。</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>纯js的ajax请求。</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest(); //ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
xhr.open(&quot;￼GET&quot;, &quot;/haorooms&quot;,true);
xhr.send();
</code></pre>
<p>以上的haorooms是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest();//ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
xhr.open(&quot;￼GET&quot;, &quot;http://www.haorooms.com/CORS&quot;,true);
xhr.send();
</code></pre>
<p>当然，你也可以用jquery的ajax进行。</p>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>PHP：只需要使用如下的代码设置即可。</p>
<pre><code class="php"> header(&quot;Access-Control-Allow-Origin:http://www.haorooms.com&quot;);
</code></pre>
<h4 id="CORS和JSONP对比"><a href="#CORS和JSONP对比" class="headerlink" title="CORS和JSONP对比"></a>CORS和JSONP对比</h4><ul>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</li>
</ul>
<h3 id="H5新特性window-postMessage"><a href="#H5新特性window-postMessage" class="headerlink" title="H5新特性window.postMessage"></a>H5新特性window.postMessage</h3><p>这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
<p>postMessage的使用方法：</p>
<pre><code class="javascript">otherWindow.postMessage(message, targetOrigin);
</code></pre>
<ul>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)</li>
<li>targetOrigin: 是限定消息接收范围，不限制请使用 *</li>
</ul>
<p><strong>Case</strong></p>
<p>A页面通过postMessage方法发送消息：</p>
<pre><code class="javascript">window.onload = function() {  
    var ifr = document.getElementById(&#39;ifr&#39;);  
    var targetOrigin = &quot;http://www.google.com&quot;;  
    ifr.contentWindow.postMessage(&#39;hello world!&#39;, targetOrigin);  
};
</code></pre>
<p>B页面通过message事件监听并接受消息:</p>
<pre><code class="javascript">var onmessage = function (event) {  
  var data = event.data;//消息  
  var origin = event.origin;//消息来源地址  
  var source = event.source;//源Window对象  
  if(origin==&quot;http://www.baidu.com&quot;){  
    console.log(data);//hello world!  
  }  
};  
if (typeof window.addEventListener != &#39;undefined&#39;) {  
  window.addEventListener(&#39;message&#39;, onmessage, false);  
} else if (typeof window.attachEvent != &#39;undefined&#39;) {  
  //for ie  
  window.attachEvent(&#39;onmessage&#39;, onmessage);  
}
</code></pre>
<h3 id="通过window-name跨域"><a href="#通过window-name跨域" class="headerlink" title="通过window.name跨域"></a>通过window.name跨域</h3><blockquote>
<p>window对象有个name属性，该属性有个特征：<strong>即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</strong></p>
<p>由于安全原因，浏览器始终会保持 window.name 是string 类型。</p>
</blockquote>
<p><strong>如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。</strong><br>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p>
<p>同样这个方法也可以应用到和iframe的交互</p>
<p><strong>Case</strong></p>
<p>我的页面(<a href="http://damonare.cn/index.html" target="_blank" rel="external">http://damonare.cn/index.html</a>)中内嵌了一个iframe：</p>
<pre><code class="html">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.google.com/iframe.html&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>在 index.html 中写了下面的代码：</p>
<pre><code class="javascript">var iframe = document.getElementById(&#39;iframe&#39;);
var data = &#39;&#39;;

iframe.onload = function() {
    iframe.onload = function(){
        data = iframe.contentWindow.name;
    }
    iframe.src = &#39;about:blank&#39;;
};
</code></pre>
<p><strong>或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</strong></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<p>这个方式<strong>非常适合单向的数据请求</strong>，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p>
<h3 id="服务端代理"><a href="#服务端代理" class="headerlink" title="服务端代理"></a>服务端代理</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限，我们可以通过<strong>server proxy的方式来抓取数据</strong>。</p>
<p><strong>Case</strong></p>
<p>例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在Baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/,然后这个代理发送HTTP请求访问google.com下的getUsers.php</p>
<p>跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略的限制），客户端并没有产生跨域的Ajax请求。这个跨域方式下不需要和目标资源签订协议，带有侵略性。</p>
<h3 id="flash-URLLoader"><a href="#flash-URLLoader" class="headerlink" title="flash URLLoader"></a>flash URLLoader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>
<p><strong>Case</strong></p>
<p>当跨域访问资源时，例如从域baidu.com请求域google.com上的数据，我们可以借助flash来发送HTTP请求。</p>
<p>首先，修改域google.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把baidu.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给 JavaScript。</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持<a href="http://lib.csdn.net/base/1" target="_blank" rel="external">iOS</a>的话，这个方案就不可行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>单向的数据请求，我们应该优先选择JSONP或者window.name</li>
<li>双向通信优先采取location.hash</li>
<li>在未与数据提供方达成通信协议的情况下我们也可以用server proxy的方式来抓取数据。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="本地（使用文件协议）的跨域请求问题"><a href="#本地（使用文件协议）的跨域请求问题" class="headerlink" title="本地（使用文件协议）的跨域请求问题"></a>本地（使用文件协议）的跨域请求问题</h2><p>具体操作：右键浏览器快捷方式，选择属性，在目标中添加–allow-file-access-from-files即可。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/lxcao/article/details/52947291" target="_blank" rel="external">Web前端面试指导(四十六)：你了解跨域请求吗？</a></li>
<li><a href="https://www.zhihu.com/question/19966531" target="_blank" rel="external">JSONP 的工作原理是什么？</a></li>
<li><a href="http://blog.csdn.net/zhang070514/article/details/77604517" target="_blank" rel="external">前端面试之跨域请求</a></li>
<li><a href="http://web.jobbole.com/88519/" target="_blank" rel="external">前端跨域知识总结</a></li>
<li><a href="http://www.cnblogs.com/jkisjk/archive/2013/05/30/change_document_domain.html" target="_blank" rel="external">修改document.domain的注意事项</a></li>
<li><a href="http://www.cnblogs.com/greatluoluo/p/6273463.html" target="_blank" rel="external">深入理解前端跨域问题的解决方案——前端面试</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事件机制]]></title>
      <url>/2017/05/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍事件机制</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="标准事件流"><a href="#标准事件流" class="headerlink" title="标准事件流"></a>标准事件流</h3><p>EMCAScript标准规定事件流包含三个阶段，分别为事件捕获阶段，处于目标阶段，事件冒泡阶段。</p>
<p><strong>Case</strong></p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;button&gt;click&lt;/button&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果点击按钮button，则标准事件触发分别经历以下三个阶段：</p>
<p><img src="http://images.cnitblog.com/blog2015/697856/201504/080003152437715.png" alt=""></p>
<p>事件触发一次经历三个阶段，所以我们在一个元素上注册事件也就可以在对应阶段注册事件，移除事件也同样</p>
<pre><code class="javascript">//标准注册事件函数
//target:target： 文档节点、document、window 或 XMLHttpRequest。
//函数的参数，分别为 注册事件类型---type不包含on，事件的回调函数，事件注册在捕获期间还是冒泡期间，true：捕获，false：冒泡
target.addEventListener(type, listener, useCapture);  

//在某一个元素上撤销已注册的事件。这里强调的是:这里的函数必须与已注册的函数是同一个函数！
target.removeEventListener(type, listener, useCapture);
</code></pre>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><ol>
<li>点击时<strong>是先判断是否处于事件阶段二</strong>，这个时候，我们已经处于了事件阶段，所以根本不存在捕获或者冒泡。<strong>这个时候会按照事件注册顺序，由事件队列中取出回调函数，执行之！</strong></li>
<li><code>addEventListener（function(),true）（将函数注册到捕获阶段和处于阶段）</code>,<code>addEventListener（function(),false）（将函数注册到处于阶段和冒泡阶段）</code>，注意注册的两个函数都是可以认为是在处于阶段的，因此函数是按注册的顺序来执行，第二个参数为true或者false都没有影响。</li>
</ol>
<h3 id="IE中事件流"><a href="#IE中事件流" class="headerlink" title="IE中事件流"></a>IE中事件流</h3><p>IE中事件流只有两个阶段： 处于目标阶段，冒泡阶段。 </p>
<p><strong>Case</strong></p>
<p><img src="http://images.cnitblog.com/blog2015/697856/201504/080003359931643.png" alt=""></p>
<p>对应着在IE中的事件注册和撤销事件函数</p>
<pre><code class="javascript">//target： 文档节点、document、window 或 XMLHttpRequest。
//函数参数： type----包含on.type一般为“onclick”,&quot;onkeydown&quot;
//          listener：事件触发时的回调函数。
target.attachEvent(type, listener);  
target.detachEvent(type,listener);   //参数与注册参数相对应。
</code></pre>
<h3 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h3><p>一般事件的执行顺序： <strong>事件的捕获阶段====&gt;处于目标阶段====&gt;事件的冒泡阶段====&gt;事件的默认行为</strong>。</p>
<p>正因为事件的默认行为是最后执行的，我们才得以机会阻止事件的默认行为。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">//阻止文本框获取焦点  
  var input=document.getElementById(&quot;inputText&quot;);
    input.onmousedown=function(event){
        event=event||window.event;
        if(event.preventDefault){  //非IE浏览器阻止事件默认行为
            event.preventDefault();
        }else{
            event.returnValue=false;//IE浏览器阻止事件默认行为
        }
    }
</code></pre>
<h3 id="跨浏览器注册事件"><a href="#跨浏览器注册事件" class="headerlink" title="跨浏览器注册事件"></a>跨浏览器注册事件</h3><pre><code class="javascript">var EventUtil =  {
    addEventListener: function (element, type, callback) {  //注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的冒泡阶段
        if (element.addEventListener) {
            element.addEventListener(type, callback, false);
        } else if (element.attachEvent) {
            element.attachEvent(&#39;on&#39; + type, callback);
        } else {
            element[&#39;on&#39; + type] = callback;
        }
    },                   
    removeEventListener: function(element, type, callback) {  //撤销事件
        if (element.removeEventListener) {
            element.removeEventListener(type, callback, false);
        } else if (element.detachEvent) {
            element.detachEvent(&#39;on&#39; + type, callback);
        } else {
            element[&#39;on&#39; + type] = null;
        }
    }
};
</code></pre>
<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><p>将一个函数赋值给一个事件处理程序的属性。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var btn = document.getElementById(&#39;mybtn&#39;);
btn.onclick = function () {
  alert(&#39;click&#39;);
}
</code></pre>
<p><strong>优点</strong></p>
<ol>
<li>简单</li>
<li>具有跨浏览器优势。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>某一个属性只能赋值给一个函数，也就导致在某一个元素上的某一个事件属性只能对应着一个函数。多次注册时，已最后一次注册为准。</li>
<li>DOM0级事件全部都是默认在冒泡阶段执行。</li>
</ol>
<h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><pre><code class="javascript">var btn = document.getElementById(&#39;mybtn&#39;);

function fun1(){ alert(&quot;1&quot;);}
function fun2(){ alert(&quot;2&quot;);}

EventUtil.addEventListener(btn,&quot;click&quot;,fun1);  //注册事件
EventUtil.addEventListener(btn,&quot;click&quot;,fun1); //触发事件的时候会 先弹出 1 在弹出 2
</code></pre>
<p><strong>优点</strong></p>
<ol>
<li>可以多次注册</li>
<li>执行顺序与注册顺序一致。</li>
</ol>
<blockquote>
<p>一般因兼容性考虑，我们很少在事件的捕获阶段注册事件</p>
</blockquote>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有事件有关的信息。</p>
<h3 id="标准浏览器中的事件对象"><a href="#标准浏览器中的事件对象" class="headerlink" title="标准浏览器中的事件对象"></a>标准浏览器中的事件对象</h3><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bubbles</td>
<td>boolean</td>
<td>只读</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>cancelable</td>
<td>boolean</td>
<td>只读</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>
</tr>
<tr>
<td>currentTarget</td>
<td>Element</td>
<td>只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>eventPhase</td>
<td>Intenger</td>
<td>只读</td>
<td>返回事件传播的当前阶段。</td>
</tr>
<tr>
<td>target</td>
<td>Element</td>
<td>只读</td>
<td>返回触发此事件的元素（事件的目标节点）。</td>
</tr>
<tr>
<td>timeStamp</td>
<td>Date</td>
<td>只读</td>
<td>返回事件生成的日期和时间。</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>只读</td>
<td>返回当前 Event 对象表示的事件的名称。</td>
</tr>
<tr>
<td>trusted</td>
<td>boolean</td>
<td>只读</td>
<td>该事件是否是浏览器生成（true代表是，false代表是开发人员创建</td>
</tr>
<tr>
<td>preventDefault</td>
<td>Function</td>
<td>只读</td>
<td>取消事件的默认行为在<a href="http://www.w3school.com.cn/jsref/event_cancelable.asp" target="_blank" rel="external">cancelable</a>=true时有效</td>
</tr>
<tr>
<td>stopPropagation</td>
<td>Function</td>
<td>只读</td>
<td>取消事件的捕获或者冒泡行为在<a href="http://www.w3school.com.cn/jsref/event_bubbles.asp" target="_blank" rel="external">bubbles</a>=true时有效</td>
</tr>
</tbody>
</table>
<p>在事件处理程序内部，对象this始终指向currentTarget的值，而target则只包含事件的实际目标。</p>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelBubble</td>
<td>boolean</td>
<td>读/写</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>returnValue</td>
<td>boolean</td>
<td>读/写</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>
</tr>
<tr>
<td>srcElement</td>
<td>Element</td>
<td>只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>只读</td>
<td>被触发事件的类型</td>
</tr>
</tbody>
</table>
<p><strong>与标准浏览器事件对象对应关系</strong></p>
<ul>
<li>srcElement 对应 target;</li>
<li>event.returnValue=false 对应event.preventDefault();</li>
<li>event.cancelBubble=true 对应event.stopPropagation();</li>
<li>fromElement和toElement 对应 relatedTarget</li>
</ul>
<h3 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h3><pre><code class="javascript">var EventUtil =  {
  addEventListener: function (element, type, callback) {  //注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的捕获阶段
    if (element.addEventListener) {
      element.addEventListener(type, callback, false);
    } else if (element.attachEvent) {
      element.attachEvent(&#39;on&#39; + type, callback);
    } else {
      element[&#39;on&#39; + type] = callback;
    }
  }, 
  getEvent:function(event){           //获取事件
    return event||window.event;
  },                
  getTarget:function(event){           //获取事件的触发目标
    return event.target||event.srcElement;
  },
  preventDefault:function(event){        //阻止事件的默认行为
    event.preventDefault?event.preventDefault():event.returnValue=false;
  },
  stopPropagation:function(event){          //阻止事件冒泡
    event.stopPropagation?event.stopPropagation:event.cancelBubble=true;
  },
  removeEventListener: function(element, type, callback) {  //撤销事件
    if (element.removeEventListener) {
      element.removeEventListener(type, callback, false);
    } else if (element.detachEvent) {
      element.detachEvent(&#39;on&#39; + type, callback);
    } else {
      element[&#39;on&#39; + type] = null;
    }
  }
};
</code></pre>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>这块更新较大，后续补上</p>
<h3 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a>模拟鼠标事件</h3><p>具体请查<a href="https://developer.mozilla.org/en-US/docs/Web/API/" target="_blank" rel="external">MDN APIs</a></p>
<h4 id="非IE浏览器"><a href="#非IE浏览器" class="headerlink" title="非IE浏览器"></a>非IE浏览器</h4><p>使用 <strong>MouseEvent()构造器来创建一个</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent" target="_blank" rel="external"><code>MouseEvent</code></a>.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent" target="_blank" rel="external">API:MouseEvent</a></p>
<pre><code class="javascript">event = new MouseEvent(typeArg, mouseEventInit);
</code></pre>
<h4 id="IE浏览器模拟鼠标事件"><a href="#IE浏览器模拟鼠标事件" class="headerlink" title="IE浏览器模拟鼠标事件"></a>IE浏览器模拟鼠标事件</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="external">API:createEventObject</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/fireEvent" target="_blank" rel="external">API:fireEvent</a> IE11已废弃</p>
<pre><code class="javascript">var event=document.createEventObject();
event.screenX=100;
event.screenY=100;
event.clientX=100;
event.clientX=100;
event.ctrlKey=false;

btn.fireEvent(&quot;onclick&quot;,event);   //在这一步会设置event.serElement,以及触发事件类型
</code></pre>
<h3 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a>模拟键盘事件</h3><h4 id="DOM3标准"><a href="#DOM3标准" class="headerlink" title="DOM3标准"></a>DOM3标准</h4><p>createEvent()传入字符串“KeyboardEvent”.返回的对象有initKeyEvent()方法</p>
<h4 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/fireEvent" target="_blank" rel="external">API:fireEvent</a> IE11已废弃</p>
<pre><code class="javascript">var event=document.createEventObject();
event.altKey=false;
event.ctrlKey=false;
event.shiftKey=false;
event.keyCode=65;

textbox.fireEvent(&quot;onkeydown&quot;,event);
</code></pre>
<h3 id="自定义DOM事件"><a href="#自定义DOM事件" class="headerlink" title="自定义DOM事件"></a>自定义DOM事件</h3><p>…</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="事件委托或是事件代理详解"><a href="#事件委托或是事件代理详解" class="headerlink" title="事件委托或是事件代理详解"></a>事件委托或是事件代理详解</h2><h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；<strong>如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p>
<h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p>事件委托是利用事件的<strong>冒泡原理</strong>来实现的</p>
<h3 id="事件委托怎么实现"><a href="#事件委托怎么实现" class="headerlink" title="事件委托怎么实现"></a>事件委托怎么实现</h3><p><strong>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源</strong>，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，<strong>标准浏览器用ev.target，IE浏览器用event.srcElement</strong>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p>
<pre><code class="javascript">window.onload = function(){
  var oUl = document.getElementById(&quot;ul1&quot;);
  oUl.onclick = function(ev){
    var ev = ev || window.event;
    var target = ev.target || ev.srcElement;
    if(target.nodeName.toLowerCase() == &#39;li&#39;){
      //...
    }
  }
}
</code></pre>
<p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/renlong0602/p/4401113.html" target="_blank" rel="external">JavaScript系列—-事件机制</a></li>
<li><a href="http://www.cnblogs.com/yexiaochai/p/3567597.html" target="_blank" rel="external">【前端盲点】事件的几个阶段你真的了解么？？？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http]]></title>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/http/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍http。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p>TCP/IP协议族可以分为4层，分别是应用层、传输层、网络层和链路层。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。FTP（File Transfer Protocol， 文件传输协议）、DNS（Domain Name System，域名系统）和HTTP都属于该层。</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据协议）都属于该层。</li>
<li>网络层：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</li>
<li>链路层：用来处理网络的硬件部分，包括操作系统、硬件的设备驱动、NIC（Network Interface Card，网卡）、光纤、诸如连接器之类的传输媒介等物理可见部分。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的过程使用了TCP 标志——SYN（synchronize）和ACK（acknowledgement）：</p>
<ol>
<li>发送端发送一个带SYN标志的数据包给对方。</li>
<li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。</li>
<li>发送端回传一个带ACK标志的数据包，表示握手结束。</li>
</ol>
<h2 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h2><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通讯。以HTTP举例来说，过程是这样的：</p>
<ol>
<li>客户端在应用层（HTTP协议）发出一项想看某个Web页面的HTTP请求。</li>
<li>在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li>
<li>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。</li>
</ol>
<p>发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的<strong>首部信息</strong>；反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法，也叫封装（encapsulate）。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p><strong>Case</strong></p>
<blockquote>
<p>GET /search.jsp HTTP/1.1<br>Host: g.hxgoogle.com</p>
</blockquote>
<p>一个完整的请求报文由Header和Body组成，Header包括请求方法、请求URI、协议版本、可选的请求首部字段等，Body指报文主体。下面重点介绍一下请求URI和HTTP方法。</p>
<h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI表示统一资源标识符，是Uniform Resource Identifier的缩写。</p>
<p>URI就是由某个协议方案（如http、ftp）表示的资源的定位标识符。</p>
<p><strong>Case</strong></p>
<blockquote>
<p>ftp://ftp.is.co.za/rfc/rfc1808.txt<br><a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2396.txt</a><br>ldap://[2001:db8::7]/c=GB?objectClass?one<br>mailto:John.Doe@example.com<br>tel:+1-816-555-1212</p>
</blockquote>
<p>URI用字符串标识某一互联网资源，而我们相对来说更熟悉的URL（UniformResource Locator，统一资源定位符）则是表示资源的地点。显然URL是URI的子集</p>
<p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：<code>http://host[&quot;:&quot;port][abs_path]</code></p>
<p>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP/1.1中的方法：</p>
<ul>
<li>GET：请求访问已被URI识别的资源，资源经服务器端解析后返回响应内容。</li>
<li>POST：虽然GET方法也可以在Body中包含内容进行传输，不过一般不用，而是使用POST方法。POST在RESTful架构中一般用来修改资源。</li>
<li>PUT：用于传输资源到URI指定位置进行保存。由于PUT方法自身不带验证机制，存在安全问题，因此一般Web网站不使用该方法。若配合Web应用程序的验证机制或采用RESTful架构设计，可能会开放使用。PUT在RESTful架构中一般用来添加资源。</li>
<li>DELETE：删除资源。与PUT情况类似，一般不开放。</li>
<li>HEAD：获得报文首部（Header），用于确认URI的有效性及资源的更新日期等。</li>
<li>TRACE：追踪路径。发送请求时，在请求Header中加上Max-Forwards字段，譬如Max-Forwards: 2这样，每经过一个服务器就将该数字减1，当数字为0时停止传输，最后接收到请求的服务器返回状态码200 OK响应，响应包含最初的请求内容（将HTTP请求原样返回）。</li>
<li>CONNECT：要求在于代理服务器通信时建立隧道，用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer， 安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。格式为CONNECT 代理服务器名:端口号 HTTP版本号。</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>HTTP响应同样可分为Header和Body，它一般长这样：</p>
<blockquote>
<p>HTTP/1.1 200 ok<br>Date: …<br>Server: ..<br>…<br>空行(CR + LF)</p>
<html><br>…<br></html>

</blockquote>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的第一位数字指定了响应类别，共可分为5类：</p>
<ul>
<li>1XX：Informational（信息性状态码），表明接受的请求正在处理。</li>
<li>2XX：Success（成功状态码），表明请求正常处理完毕。</li>
<li>3XX：Redirection（重定向状态码），表明需进行附加操作以完成请求。</li>
<li>4XX：Client Error（客户端错误状态码），表明服务器无法处理请求。</li>
<li>5XX：Server Error（服务器错误状态码），表明服务器处理请求出错。</li>
</ul>
<p>下面列举几种常见的错误码和原因短语：</p>
<ul>
<li>200 OK：请求正常处理。</li>
<li>204 No Content：请求正常处理，但没有资源可返回。</li>
<li>206 Partial Content： 客户端进行了范围请求，服务器成功执行这部分GET请求。</li>
<li>301 Moved Permanently： 永久性重定向，表明该资源已被分配了新的URI。</li>
<li>302 Found： 临时性重定向，表明该资源暂时被分配了新的URI。</li>
<li>303 See Other：表明请求的资源存在另一个URI，明确要求客户端采用GET方法重定向请求资源。</li>
<li>400 Bad Request：请求报文中存在语法错误，需修改请求内容后再次发送。</li>
<li>401 Unauthorized*：请求需包含通过HTTP认证（BASIC认证、DIGEST认证等）的认证信息，浏览器初次接收401响应会弹出认证窗口。若之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden：请求资源的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，不过也可以在响应主体部分对原因进行描述。未获得文件系统的访问授权（比如在IIS上部署网站时默认不能通过浏览器访问文件）、访问权限出现问题（比如从未授权的发送源IP地址试图访问）都有可能返回403响应。</li>
<li>404 Not Found：服务器无法找到请求的资源（也可在服务器端拒绝访问且不想说明理由时使用）。</li>
<li>500 Internal Server Error：服务器端执行请求时发生内部错误。多为服务器端程序出现Bug。</li>
<li>503 Service Unavailable：服务器处于超负载或正在停机维护，暂时无法处理请求。</li>
</ul>
<h2 id="HTTP消息报头"><a href="#HTTP消息报头" class="headerlink" title="HTTP消息报头"></a>HTTP消息报头</h2><p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。</p>
<h3 id="1-普通报头"><a href="#1-普通报头" class="headerlink" title="1. 普通报头"></a>1. 普通报头</h3><p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息</p>
<h4 id="常用的普通报头"><a href="#常用的普通报头" class="headerlink" title="常用的普通报头"></a>常用的普通报头</h4><p><strong>Cache-Control</strong><br>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。</p>
<p>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.</p>
<p><strong>Date</strong><br>Date普通报头域表示消息产生的日期和时间</p>
<p><strong>Connection</strong><br>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>
<h3 id="2-请求报头"><a href="#2-请求报头" class="headerlink" title="2. 请求报头"></a>2. 请求报头</h3><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。</p>
<h4 id="常用的请求报头"><a href="#常用的请求报头" class="headerlink" title="常用的请求报头"></a>常用的请求报头</h4><p><strong>Accept</strong><br>Accept请求报头域用于指定客户端接受哪些类型的信息。</p>
<p><strong>Accept-Charset</strong><br>Accept-Charset请求报头域用于指定客户端接受的字符集。</p>
<p><strong>Accept-Encoding</strong><br>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。</p>
<p><strong>Accept-Language</strong><br>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。</p>
<p><strong>Authorization</strong><br>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>
<p><strong>Host</strong>（发送请求时，该报头域是必需的）<br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>
<p><strong>User-Agent</strong><br>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的</p>
<h3 id="3-响应报头"><a href="#3-响应报头" class="headerlink" title="3. 响应报头"></a>3. 响应报头</h3><p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>
<h4 id="常用的响应报头"><a href="#常用的响应报头" class="headerlink" title="常用的响应报头"></a>常用的响应报头</h4><p><strong>Location</strong><br>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</p>
<p><strong>Server</strong><br>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。</p>
<h3 id="4-实体报头"><a href="#4-实体报头" class="headerlink" title="4. 实体报头"></a>4. 实体报头</h3><p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。</p>
<h4 id="常用的实体报头"><a href="#常用的实体报头" class="headerlink" title="常用的实体报头"></a>常用的实体报头</h4><p><strong>Content-Encoding</strong><br>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p>
<p><strong>Content-Language</strong><br>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。</p>
<p><strong>Content-Length</strong><br>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</p>
<p><strong>Content-Type</strong><br>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。</p>
<p><strong>Last-Modified</strong><br>Last-Modified实体报头域用于指示资源的最后修改日期和时间。</p>
<p><strong>Expires</strong><br>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。</p>
<h2 id="HTTP协议的一些特性"><a href="#HTTP协议的一些特性" class="headerlink" title="HTTP协议的一些特性"></a>HTTP协议的一些特性</h2><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。增加通信量的开销，而且频繁断开又重连会导致页面加载缓慢，影响用户体验。</p>
<h3 id="持久连接（HTTP-Persistent-Connections）"><a href="#持久连接（HTTP-Persistent-Connections）" class="headerlink" title="持久连接（HTTP Persistent Connections）"></a>持久连接（HTTP Persistent Connections）</h3><p>HTTP/1.1和一部分HTTP/1.0开始支持持久连接。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。HTTP/1.1中所有的连接默认都是持久连接。</p>
<h3 id="管线化（pipelining）"><a href="#管线化（pipelining）" class="headerlink" title="管线化（pipelining）"></a>管线化（pipelining）</h3><p>持久连接使得多数请求以管线化方式发送成为可能。以往发送请求后需等待并收到响应后才能发送下一个请求，管线化技术出现后，无需等待亦可发送下一个请求。这就实现了多个请求的并行发送，提高了网络通信效率。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应状态进行管理。HTTP协议中引入的Cookie技术，也是为了解决状态管理问题。</p>
<p>具体来说，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态，过程如下：</p>
<ol>
<li><p>客户端第一次发送请求，请求报文中没有Cookie信息。</p>
</li>
<li><p>服务器端生成Cookie信息，在响应报文中通过Set-Cookie这个首部字段，通知客户端保存Cookie，大概长这样：</p>
<blockquote>
<p>HTTP/1.1 200 ok<br>…<br><set-cookie: sid="1345077140226724;path=/;expires=Fri,=">23-Oct-15 07:12:20 GMT&gt;<br>Content-Type: text/plain; charset=UTF-8</set-cookie:></p>
</blockquote>
</li>
<li><p>客户端再次发送请求时，自动在请求报文中加入Cookie值后发送出去。大概长这样：</p>
<blockquote>
<p>GET /image/ HTTP/1.1<br>Host: github.com<br>Cookie: sid=1345077140226724</p>
</blockquote>
</li>
<li><p>服务器端收到Cookie信息后，会去检查从哪个客户端发来的连接请求，然后对比服务器上的记录，得到之前的状态信息。</p>
</li>
</ol>
<h2 id="HTTP协议相关技术补充"><a href="#HTTP协议相关技术补充" class="headerlink" title="HTTP协议相关技术补充"></a>HTTP协议相关技术补充</h2><h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><p>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)。</p>
<h4 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理(Proxy)"></a>代理(Proxy)</h4><p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p>
<p>一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。</p>
<h4 id="网关-Gateway"><a href="#网关-Gateway" class="headerlink" title="网关(Gateway)"></a>网关(Gateway)</h4><p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p>
<p>网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。</p>
<h4 id="通道-Tunnel"><a href="#通道-Tunnel" class="headerlink" title="通道(Tunnel)"></a>通道(Tunnel)</h4><p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
<p>一个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h2><ol>
<li>支持客户/服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jianshu.com/p/2ecd288d27ad" target="_blank" rel="external">HTTP知识点总结</a></li>
<li><a href="http://www.cnblogs.com/puyaoyao/p/3705970.html" target="_blank" rel="external">HTTP协议详解（前端面试常考知识点）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型与原型链]]></title>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍原型和原型链的概念，参考多篇热门博客，持续总结和更新思想。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h2><p>任何一个对象Object都有<code>_proto_</code>，它是每一个对象的私有属性，是天生自带的。</p>
<p>又叫做隐式原型</p>
<p>JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。ES5中有了对于这个内置属性标准的<strong>Get方法Object.getPrototypeOf()</strong></p>
<blockquote>
<p>Note: Object.prototype 这个对象是个例外，它的<code>__proto__</code>值为null </p>
</blockquote>
<p>隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</p>
<p>一个对象的<strong>proto</strong>记录着自己的原型链，决定了自身的数据类型，改变<strong>proto</strong>就等于改变对象的数据类型。</p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><strong>原型对象</strong>。不是任何对象都有prototype，只有构造函数有prototype，是后天赋予的。</p>
<p>每创建一个函数都会有一个prototype属性，这个属性是一个指针，<strong>指向一个对象（通过该构造函数创建实例对象的原型对象）</strong>。</p>
<p>原型对象是包含特定类型的所有实例共享的属性和方法。<strong>原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。</strong></p>
<p>原型对象属于普通对象。</p>
<p>又叫做显式原型。</p>
<blockquote>
<p><strong>Note</strong>：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性</p>
</blockquote>
<p>函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。</p>
<p>在原型对象上定义方法和属性的目的是为了被子类继承和使用。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p>
<h2 id="获取对象的原型"><a href="#获取对象的原型" class="headerlink" title="获取对象的原型"></a>获取对象的原型</h2><pre><code class="javascript">dog1.__proto__  //不推荐  
Object.getPrototypeOf(dog1) === Dog.prototype   //推荐
</code></pre>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的存在，主要是为了实现对象的<code>继承</code>。</p>
<p>原型链基本思路（图解）：</p>
<p><img src="http://img.blog.csdn.net/20161006191631510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="原型链查找"><a href="#原型链查找" class="headerlink" title="原型链查找"></a>原型链查找</h2><p><strong>调用一个对象的属性或方法，一但这个对象中没有，就去这个对象的<code>_proto_</code>中查找。这个对象的<code>_proto_</code>指向自己构造函数的prototype属性</strong></p>
<p>关键的点在于找到创建这个对象的构造函数，本质上只有一种方式，也就是通过new来创建。</p>
<p>由Object.create(o)创建出来的对象它的隐式原型指向o。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的<code>__proto__</code>属性</p>
<p>当使用<code>new</code>去调用构造函数时，相当于执行了</p>
<pre><code class="javascript">var o = {};
o.__proto__ = F.prototype;
F.call(o);
</code></pre>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型对象prototype上都有个预定义的<code>constructor</code>属性，用来引用它的函数对象。这是一种循环引用。</p>
<pre><code class="javascript">function F(){};
F.prototype.constructor === F;
</code></pre>
<p>在实际运用中，经常会有下列的写法</p>
<pre><code class="javascript">function F(){};
F.prototype = {
    constructor : F,
    doSomething : function(){}
}
</code></pre>
<p>这里要加<code>constructor</code>是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。</p>
<p>实例对象的constructor属性指向其构造函数, 因此</p>
<pre><code class="javascript">Object.constructor === Function;
Function.constructor === Function;
</code></pre>
<p>由 Object.create() 创建出来的对象没有构造函数</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Function-prototype没有prototype属性"><a href="#Function-prototype没有prototype属性" class="headerlink" title="Function.prototype没有prototype属性"></a>Function.prototype没有prototype属性</h2><p><strong>原型对象属于普通对象。</strong>Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。</p>
<pre><code class="javascript">function person(){};  

console.log(typeof person.prototype) //Object  
console.log(typeof Object.prototype) // Object  
console.log(typeof Function.prototype) // 特殊 Function  
console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性
</code></pre>
<h2 id="构造函数的显示原型的隐式原型"><a href="#构造函数的显示原型的隐式原型" class="headerlink" title="构造函数的显示原型的隐式原型"></a>构造函数的显示原型的隐式原型</h2><p>内建对象(built-in object)比如Array()，<code>Array.prototype.__proto__</code>指向什么？</p>
<p><code>Array.prototype.__proto__ === Object.prototype</code>，或者也可以这么理解，所有的内建对象都是由Object()创建而来。</p>
<p>Array是函数对象，是Function的实例对象，Array是通过new Function创建出来的。因为Array是Function的实例，所以<code>Array.__proto__ ===  Function.prototype</code></p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><h3 id="解释1"><a href="#解释1" class="headerlink" title="解释1"></a>解释1</h3><p>instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>内部实现原理：</p>
<pre><code class="javascript">//设 L instanceof R 
//通过判断
 L.__proto__.__proto__ ..... === R.prototype ？
//最终返回true or false
</code></pre>
<h3 id="解释2"><a href="#解释2" class="headerlink" title="解释2"></a>解释2</h3><p><code>A instanceof B</code> 是在 A 的原型链里查找 B 的 constructor，找到返回 true，找不到返回 false。</p>
<pre><code class="javascript">Function instanceof Object === true
Object instanceof Function === true

Object.__proto__ === Function.prototype; // true
Object.__proto__ == Object.prototype; // false
Function.prototype.__proto__ === Object.prototype; // true
</code></pre>
<h2 id="Function、Object关系"><a href="#Function、Object关系" class="headerlink" title="Function、Object关系"></a>Function、Object关系</h2><p><code>Object.prototype</code>是所有对象的根源<br><code>Object.prototype</code>只是挂载在<code>Object</code>函数对象上<br><code>Function.prototype</code>构造自<code>Object.prototype</code><br><code>Function.prototype</code> 只是挂载在<code>Function</code>函数对象上<br><code>Object</code>函数和<code>Function</code>函数构造自<code>Function.prototype</code><br><code>Object</code>字面量对象{}构造自<code>Object.prototype</code><br><code>Object</code>字面量对象<code>{}.__proto__</code>（原构造对象） === <code>Object.prototype</code><br><code>Function</code>函数 和 自定义函数 都继承（构造而成）自<code>Function.prototype</code><br><code>Function.prototype</code> 和 <code>Function.__proto__</code>（原构造对象）相同<br>所以，是先有的<code>Object.prototype</code>,再有的<code>Function.prototype</code>，再有的<code>Function</code>和<code>Object</code>函数对象</p>
<h2 id="Function、Object、Prototype、proto内存关系图"><a href="#Function、Object、Prototype、proto内存关系图" class="headerlink" title="Function、Object、Prototype、proto内存关系图"></a>Function、Object、Prototype、<strong>proto</strong>内存关系图</h2><ol>
<li>所有对象所有对象，包括函数对象的原型链最终都指向了Object.prototype，而<code>Object.prototype.__proto__===null</code>，原型链至此结束。</li>
<li>Animal.prototype是一个普通对象。</li>
<li>Object是一个函数对象，也是Function构造的，Object.prototype是一个普通对象。</li>
<li><code>Object.prototype.__type__</code>指向null。</li>
<li>Function.prototype是一个函数对象，前面说函数对象都有一个显示的prototype属性，但是Function.prototype却没有prototype属性，即Function.prototype.prototype===undefined，所有Function.prototype函数对象是一个特例，没有prototype属性。</li>
<li>Object虽是Function构造的一个函数对象，但是Object.prototype没有指向Function.prototype，即Object.prototype!==Function.prototype。</li>
</ol>
<p><img src="http://images.blogjava.net/blogjava_net/heavensay/web-front/8199006.png" alt=""></p>
<h2 id="经典原型链"><a href="#经典原型链" class="headerlink" title="经典原型链"></a>经典原型链</h2><p><img src="https://pic2.zhimg.com/50/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt=""></p>
<h2 id="《JavaScript-世界万物诞生记》"><a href="#《JavaScript-世界万物诞生记》" class="headerlink" title="《JavaScript 世界万物诞生记》"></a>《JavaScript 世界万物诞生记》</h2><p>Object作为一个机器可以看做是有由Function制造出来的，而Function作为一个对象可以看做是由Object制造出来的。</p>
<p><img src="https://pic2.zhimg.com/v2-52726a7f86690c0663452112d66836c5_r.png" alt=""></p>
<h2 id="《什么是-JS-原型链？》"><a href="#《什么是-JS-原型链？》" class="headerlink" title="《什么是 JS 原型链？》"></a>《什么是 JS 原型链？》</h2><blockquote>
<p>这篇流程讲的很清晰</p>
</blockquote>
<pre><code class="javascript">var obj = { name: &#39;obj&#39; }
</code></pre>
<h3 id="valueOf-toString-constructor-是怎么来？"><a href="#valueOf-toString-constructor-是怎么来？" class="headerlink" title="valueOf / toString / constructor 是怎么来？"></a>valueOf / toString / constructor 是怎么来？</h3><ol>
<li><code>obj.__proto__</code> 有很多属性，包括 valueOf、toString、constructor 等</li>
<li><code>obj.__proto__</code> 其实也有一个叫做 <code>__proto__</code> 的属性，值为 null</li>
</ol>
<h3 id="共享原型链"><a href="#共享原型链" class="headerlink" title="共享原型链"></a>共享原型链</h3><p>如果我们改写 <code>obj2.__proto__.toString</code>，那么 obj.toString 其实也会变！</p>
<h3 id="差异化"><a href="#差异化" class="headerlink" title="差异化"></a>差异化</h3><p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？</p>
<p>直接赋值就好了：</p>
<pre><code class="javascript">obj.toString = function(){ return &#39;新的 toString 方法&#39; }
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>「读」属性时会<strong>沿着原型链搜索</strong>。</p>
<p>「新增」属性时<strong>不会</strong>去看原型链（但是如果你给这个属性加了一些配置，则不一样）。</p>
<h2 id="《最详尽的-JS-原型与原型链终极详解》"><a href="#《最详尽的-JS-原型与原型链终极详解》" class="headerlink" title="《最详尽的 JS 原型与原型链终极详解》"></a>《最详尽的 JS 原型与原型链终极详解》</h2><h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p>对象也有区别，大致可以分为两类，即：普通对象（Object）和函数对象（Function）。<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p>
<h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p><strong>实例的构造函数属性（constructor）指向构造函数。</strong></p>
<h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数,即：<code>Person.prototype.constructor == Person</code></p>
<p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p>
<p><code>Function.prototype</code> 为什么是函数对象呢？</p>
<pre><code class="javascript">var A = new Function ();
Function.prototype = A;
</code></pre>
<p><strong>凡是通过 new Function( ) 产生的对象都是函数对象</strong>。因为 A 是函数对象，所以<code>Function.prototype</code> 是函数对象。</p>
<h3 id="四-原型链"><a href="#四-原型链" class="headerlink" title="四. 原型链"></a>四. 原型链</h3><p><code>Person.prototype.__proto__</code> 是什么？</p>
<p><code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。所以 <code>Person.prototype.__proto__ === Object.prototype</code></p>
<h3 id="五-函数对象"><a href="#五-函数对象" class="headerlink" title="五. 函数对象"></a>五. 函数对象</h3><h5 id="所有函数对象的-proto-都指向Function-prototype，它是一个空函数"><a href="#所有函数对象的-proto-都指向Function-prototype，它是一个空函数" class="headerlink" title="所有函数对象的__proto__都指向Function.prototype，它是一个空函数"></a>所有<em>函数对象</em>的<code>__proto__</code>都指向Function.prototype，它是一个空函数</h5><p><strong>所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind</strong></p>
<p><code>Function.prototype</code>也是唯一一个<code>typeof XXX.prototype</code>为 <code>function</code>的<code>prototype</code>。其它的构造器的<code>prototype</code>都是一个对象</p>
<p><code>Function.prototype</code>的<code>__proto__</code>是谁呢？</p>
<pre><code class="javascript">Function.prototype.__proto__ === Object.prototype
</code></pre>
<p>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<h3 id="六-Prototype"><a href="#六-Prototype" class="headerlink" title="六. Prototype"></a>六. Prototype</h3><p>可以用一个 ES5 提供的新方法：<code>Object.getOwnPropertyNames</code>获取所有（<strong>包括不可枚举的属性</strong>）的属性名<strong>不包括 prototy 中的属性</strong>，返回一个数组</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="external">JS重点整理之JS原型链彻底搞清楚</a></li>
<li><a href="http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html" target="_blank" rel="external">Js中Prototype、<strong>proto</strong>、Constructor、Object、Function关系介绍</a></li>
<li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="external">js中<strong>proto</strong>和prototype的区别和关系？</a></li>
<li><a href="https://segmentfault.com/a/1190000005363885" target="_blank" rel="external">JavaScript之原型链</a></li>
<li><a href="https://segmentfault.com/q/1010000000249140" target="_blank" rel="external">Function为何是Object的实例呢</a></li>
<li><a href="https://segmentfault.com/q/1010000002736664" target="_blank" rel="external">js 原型的问题 Object 和 Function 到底是什么关系？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22989691" target="_blank" rel="external">JavaScript 世界万物诞生记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23090041?refer=study-fe" target="_blank" rel="external">「每日一题」什么是 JS 原型链？</a></li>
<li><a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解，没有「可能是」</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[json]]></title>
      <url>/2017/04/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/json/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍json。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。是前后台数据交互最常见的一种数据格式。</p>
<p><strong>特点</strong></p>
<ul>
<li>JavaScript 对象表示法（JavaScript Object Notation）。 </li>
<li>JSON 是存储和交换文本信息的语法。类似 XML。 </li>
<li>JSON 比 XML 更小、更快，更易解析。</li>
</ul>
<h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><ol>
<li>数据在键值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ol>
<blockquote>
<p>注：JSON 值可以是 null ，不能是 undefined</p>
</blockquote>
<h2 id="JSON-文件"><a href="#JSON-文件" class="headerlink" title="JSON 文件"></a>JSON 文件</h2><ul>
<li>JSON 文件的文件类型是 “.json”</li>
<li>JSON 文本的 MIME 类型是 “application/json”</li>
</ul>
<h2 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h2><h3 id="1-JSON字符串转换为JSON对象"><a href="#1-JSON字符串转换为JSON对象" class="headerlink" title="1. JSON字符串转换为JSON对象:"></a>1. JSON字符串转换为JSON对象:</h3><pre><code class="javascript">var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);
var obj = JSON.parse(str);
</code></pre>
<h3 id="2-JSON对象转换为JSON字符串："><a href="#2-JSON对象转换为JSON字符串：" class="headerlink" title="2. JSON对象转换为JSON字符串："></a>2. JSON对象转换为JSON字符串：</h3><pre><code class="javascript">var last=JSON.stringify(obj);
</code></pre>
<h3 id="3-数组转JSON字符串"><a href="#3-数组转JSON字符串" class="headerlink" title="3. 数组转JSON字符串"></a>3. 数组转JSON字符串</h3><pre><code class="javascript"> var array=[1,2,3,4];
 JSON.stringify($(array));
</code></pre>
<h3 id="4-JSON字符串转数组，使用jquery"><a href="#4-JSON字符串转数组，使用jquery" class="headerlink" title="4. JSON字符串转数组，使用jquery"></a>4. JSON字符串转数组，使用jquery</h3><pre><code class="javascript"> $(JSON.parse(&#39;{&quot;0&quot;:1,&quot;1&quot;:2,&quot;2&quot;:3,&quot;length&quot;:3}&#39;));
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="JSON与XML的差异化"><a href="#JSON与XML的差异化" class="headerlink" title="JSON与XML的差异化"></a>JSON与XML的差异化</h2><p><strong>相似</strong></p>
<ul>
<li>JSON 是纯文本</li>
<li>JSON 具有“自我描述性”（人类可读）</li>
<li>JSON 具有层级结构（值中存在值）</li>
<li>JSON 可通过 JavaScript 进行解析</li>
<li>JSON 数据可使用 AJAX 进行传输</li>
</ul>
<p><strong>不同</strong></p>
<ul>
<li>没有结束标签</li>
<li>更短</li>
<li>读写的速度更快</li>
<li>能够使用内建的 JavaScript eval() 方法进行解析</li>
<li>使用数组</li>
<li>不使用保留字</li>
</ul>
<h2 id="JSON与XML使用地方"><a href="#JSON与XML使用地方" class="headerlink" title="JSON与XML使用地方"></a>JSON与XML使用地方</h2><p><strong>使用 XML</strong></p>
<ul>
<li>读取 XML 文档</li>
<li>使用 XML DOM 来循环遍历文档</li>
<li>读取值并存储在变量中</li>
</ul>
<p><strong>使用 JSON</strong></p>
<ul>
<li>读取 JSON 字符串</li>
<li>用 eval() 处理 JSON 字符串</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/lxcao/article/details/52735632" target="_blank" rel="external">Web前端面试指导(二十六)：JSON 格式是什么？你了解吗？</a></li>
<li><a href="http://blog.csdn.net/crper/article/details/45625283" target="_blank" rel="external">JSON知识点汇总_W3SCHOOL</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄漏]]></title>
      <url>/2017/04/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍JS内存泄漏</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="js的回收机制"><a href="#js的回收机制" class="headerlink" title="js的回收机制"></a>js的回收机制</h2><p>垃圾收集算法所依赖的主要概念之一就是内存引用。</p>
<p>在内存管理情况下，如果一个对象访问变量（可以是隐含的或显式的），则称该对象引用另一个对象。</p>
<p>通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记和扫描算法经过以下3个步骤：</p>
<ol>
<li>roots：通常，root是代码中引用的全局变量。例如，在JavaScript中，可以充当root的全局变量是“窗口”对象。Node.js中的相同对象称为“全局”。所有root的完整列表由垃圾收集器构建。</li>
<li>然后算法会检查所有root和他们的子对象并且标记它们是活动的（即它们不是垃圾）。任何root不能达到的，将被标记为垃圾。</li>
<li>最后，垃圾回收器释放所有未标记为活动的内存块，并将该内存返回给操作系统。</li>
</ol>
<p><img src="http://jbcdn2.b0.upaiyun.com/2017/11/f3a624c2b1f1a9a511deffc4ad1bd57a.gif" alt=""></p>
<p>这个算法比引用计数垃圾收集算法更好。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<h2 id="抵制垃圾收集器的直观行为"><a href="#抵制垃圾收集器的直观行为" class="headerlink" title="抵制垃圾收集器的直观行为"></a>抵制垃圾收集器的直观行为</h2><p>垃圾收集是不可预测的。你不能真正知道什么时候进行收集，这意味着在某些情况下，程序会使用更多的内存，虽然这是实际需要的。在其它情况下，在特别敏感的应用程序中，短暂暂停是很可能出现的。尽管非确定性意味着不能确定何时进行集合，但大多数垃圾收集实现了共享在分配期间进行收集的通用模式。如果没有执行分配，大多数垃圾收集会保持空闲状态。如以下情况：</p>
<ol>
<li>大量的分配被执行。</li>
<li>大多数这些元素（或所有这些元素）被标记为无法访问（假设我们将一个引用指向不再需要的缓存）。</li>
<li>没有进一步的分配执行。</li>
</ol>
<h2 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window。如果不小心创建一个全局变量this，会有一些问题。</p>
<p>通过加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.</p>
<p>意外的全局变量当然是一个问题。更多的时候，你的代码会受到显式的全局变量的影响，而这些<strong>全局变量在垃圾收集器中是无法收集的</strong>。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，那么确保将其分配为空值，或者在完成后重新分配。</p>
<h3 id="闭包引起的内存泄漏"><a href="#闭包引起的内存泄漏" class="headerlink" title="闭包引起的内存泄漏"></a>闭包引起的内存泄漏</h3><ul>
<li>将事件处理函数定义在外部，解除闭包,</li>
</ul>
<ul>
<li>在定义事件处理函数的外部函数中，删除对dom的引用</li>
</ul>
<h3 id="超出DOM引用"><a href="#超出DOM引用" class="headerlink" title="超出DOM引用"></a>超出DOM引用</h3><p>在某些情况下，开发人员会在数据结构中存储DOM节点，例如你想快速更新表格中的几行内容的情况。如果在字典或数组中存储对每个DOM行的引用，则会有两个对同一个DOM元素的引用：一个在DOM树中，另一个在字典中。如果你不再需要这些行，则需要使两个引用都无法访问。</p>
<p>在涉及DOM树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（标签）的引用，并决定从DOM中删除该表格，还需要保留对该特定单元格的引用，则可能会出现严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元之外的所有东西，但情况并非如此。由于单元格是表格的一个子节点，并且子节点保留着对父节点的引用，所以对表格单元格的这种引用，会将整个表格保存在内存中。</p>
<h3 id="被遗忘的定时器或者回调"><a href="#被遗忘的定时器或者回调" class="headerlink" title="被遗忘的定时器或者回调"></a>被遗忘的定时器或者回调</h3><p>对于提供监视的库和其它接受回调的工具，通常在确保所有回调的引用在其实例无法访问时，会变成无法访问的状态。</p>
<p>当使用监视器时，你需要确保做了一个明确的调用来删除它们。</p>
<p>幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当被监测对象变得无法访问，它们就会自动收集监测处理器。这是过去的一些浏览器无法处理的情况（例如旧的IE6）。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="IE7-8引用计数使用循环引用产生的问题"><a href="#IE7-8引用计数使用循环引用产生的问题" class="headerlink" title="IE7/8引用计数使用循环引用产生的问题"></a>IE7/8引用计数使用循环引用产生的问题</h2><pre><code class="javascript">function fn(){
  var a = {};
  var b= {};
  a.pro = b;
  b.pro = a;
}
fn();
</code></pre>
<p>在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。</p>
<p>IE中有一部分对象并不是原生js对象。例如，其内存泄漏DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p>
<p>IE9+并不存在循环引用导致Dom内存泄漏问题</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jianshu.com/p/763ba9562864" target="_blank" rel="external">JS哪些操作会造成内存泄漏？</a></li>
<li><a href="http://web.jobbole.com/93078/" target="_blank" rel="external">JavaScript 中的内存泄漏以及如何处理</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据类型]]></title>
      <url>/2017/04/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这篇文章整理一些数据类型的点和坑。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>String、boolean、Number、undefined、null</p>
<p>ECMAScript 2015新增:Symbol(创建后独一无二且不可变的数据类型)</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在JavaScript中字符串是一组由16位值组成的不可变的有序序列，每个字符通常来自Unicode字符集。（《JavaScript权威指南》）</p>
<p><strong>在JavaScript中所有基础类型都不可以修改</strong></p>
<p> String()方法同样能实现 toString()的效果，但是 <strong>可以对 null 和undefined进行操作</strong>。</p>
<blockquote>
<p>内部原理：先调用 toString(),如果可以转换成字符串，就将结果直接返回。否则，再进行判断是 null 还是 undefined，然后返回‘null’ 或 ‘undefined’</p>
</blockquote>
<p>如果知道变量不可能是 null  或 undefined，就使用 toString()性能比 String(), 因为 String()内部还要做判断，所以有损性能。</p>
<h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>if() 语句的 ()  内部就是调用了 Boolean函数</p>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>和大多数编程语言不同，JavaScript的number类型不区分整数和浮点数，所有数字都适用浮点数表示。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ol>
<li>var d=0/0;  注意：在js里是不会报错的，而是返回 NaN </li>
<li>可以通过Number.NaN 来获取 </li>
<li>NaN和 任何 对象做运算都会返回 NaN</li>
<li>isNaN()判断是不是 NaN</li>
</ol>
<blockquote>
<p>isNaN()内部执行原理：同样适用于对象。实现原理：首相调用对象的valueOf()方法，如果能转换成数字就直接做判断；如果不能就再调用toString()方法，然后测试返回值。</p>
</blockquote>
<h4 id="将其他数据类型转换成Number类型"><a href="#将其他数据类型转换成Number类型" class="headerlink" title="将其他数据类型转换成Number类型"></a>将其他数据类型转换成Number类型</h4><ul>
<li>Number():可以针对所有的数据类型进行转换；</li>
<li>parseInt()和parseFloat() 只针对字符串进行转化。</li>
</ul>
<blockquote>
<p>Number()内部实现的原理：同isNaN(), 也是先调用 valueOf(), 然后调用 toString()。所以可想而知，性能是比较差的。优先使用 parseInt()  或者 parseFloat()</p>
</blockquote>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>表示未定义（声明）过的变量</p>
<p>Note：如果Object类型的 对象变量开始不知道赋值什么，不要  <code>var demo={}</code>；最好设置成null；</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>已声明未赋值</p>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>Object、Array、Date、RegExp、Function</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p><strong>Case</strong></p>
<pre><code class="javascript">var s=&#39;test&#39;;
s.len=4;
console.log(s.len);//undefined
</code></pre>
<p><strong>只要引用了字符串属性，JavaScript就会通过调用 new String(s) 来创建一个临时对象</strong>，我们使用的indexOf方法和length属性正是来源于这个临时对象，<strong>每次使用都创建一次，然后销毁。这个临时对象就是包装对象</strong>，不只是string，number和boolean类型同样有包装对象。</p>
<p>上面代码可以这样解析</p>
<pre><code class="javascript">var s=&#39;test&#39;;//创建字符串类型变量
s.len=4;//创建包装对象，为包装对象添加属性len
//引用完毕，销毁包装对象
console.log(s.len);//创建包装对象，查找其len属性，没有找到，返回undefined
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>函数转换：parseInt()、parseFloat()、toString()<br>强类型转换：Boolean()、Number()、String()<br>弱类型转换：“==”、“-”、“+”、if（）</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a=[0], b=a, b=[1];
console.log(a+b);
</code></pre>
<p>最后问题可以变为[0]+[1]，一不小心就会写为1，但是这时候我们调用的是数组的toString方法，实际是’0’+’1’=’01’</p>
<p><strong>类型转换表</strong>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>转换为字符串</th>
<th>转换为数字</th>
<th>转换为布尔值</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>“undefined”</td>
<td>NaN</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>“null”</td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>“true”</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td>“false”</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>“”</td>
<td></td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>“2.5”</td>
<td></td>
<td>2.5</td>
<td>true</td>
</tr>
<tr>
<td>“string”</td>
<td></td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>1</td>
<td>“1”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>“NaN”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>Infinity</td>
<td>“Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>[2]</td>
<td>“2”</td>
<td>2</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><strong>Case</strong></p>
<pre><code class="javascript">Boolean([]);//true
Object(3);//new Number(3)
5+&quot;&quot;;//String(5)
+&quot;5&quot;;//5，变成了数字 Number(&quot;5&quot;)
&quot;5&quot;-0;//5,也是数字
</code></pre>
<h2 id="toString和valueOf"><a href="#toString和valueOf" class="headerlink" title="toString和valueOf"></a>toString和valueOf</h2><p>valueOf()内部调用了toObject()方法。</p>
<p>toString()方法 将其他数据类型转换成 String类型。但是如果对 null 或undefined  进行操作的话就会报错。</p>
<h3 id="对象转为字符串"><a href="#对象转为字符串" class="headerlink" title="对象转为字符串"></a>对象转为字符串</h3><p>对象转换为字符串过程大概是这样</p>
<ol>
<li>如果对象具有toString方法则调用该方法，如果方法返回的是一个基本类型（有坑爹的toString方法不返回string类型的），JavaScript把这个值转换为字符串返回</li>
<li>如果对象没有toString方法，或者该方法返回的不是一个基本类型，那么就会调用valueOf方法，如果存在valueOf方法并且valueOf返回的是基本类型，那么将值转换为字符串输出</li>
<li>再如果就只能报错了</li>
</ol>
<h3 id="对象转为数字"><a href="#对象转为数字" class="headerlink" title="对象转为数字"></a>对象转为数字</h3><p>对象转换为数字过程大概是这样</p>
<ol>
<li>如果对象有valueOf方法，并且方法返回基本类型，则把值转换为数字返回</li>
<li>如果对象具有toString方法，且方法返回基本类型，则转换为数字返回</li>
<li>否则就报错</li>
</ol>
<p>上面情况只是针对强制转换，也就是我们显示的调用String或者Number构造函数的时候的处理，在平常使用中，<strong>在”显示“相关操作中会优先调用toString方法，而在运算相关操作中会优先调用valueOf方法</strong>。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var o = {
        x: 8,
        valueOf: function(){
            return this.x + 2;
        },
        toString: function(){
            return this.x;
        }
    };
console.log(String(o));//&quot;8&quot;
console.log(Number(o)); //10
console.log(o+1);//11，运算相关
alert(o);//&quot;8&quot;，显现相关
</code></pre>
<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><p>有几个看起来比较蹊跷需要我们注意</p>
<ol>
<li>typeof是运算符，不是方法，也就是说和加减号一样用，不考虑优先级问题，没必要给操作数加括号，当然加了也没事儿，说实话可读性还挺高</li>
<li>typeof返回值都是小写字符串</li>
<li>null的类型不是null，而是”object”</li>
<li>NaN这个不是数字的类型也是”number”</li>
<li>function明明也是对象，但是typeof却给了”function”类型</li>
<li>其它对象都返回”object”,很没有识别性</li>
</ol>
<h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p><strong>对于基本类型，instanceof 永远返回false</strong></p>
<pre><code class="javascript">1 instanceof Number; //false
new Number(1) instanceof Number; //true
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="undefined-和null-的区别和注意点"><a href="#undefined-和null-的区别和注意点" class="headerlink" title="undefined 和null 的区别和注意点"></a>undefined 和null 的区别和注意点</h2><ol>
<li>如果用 “==” 进行比较，他们是相等的，因为比较的是值</li>
<li><p>区分他们有两种方法（他们的核心都是比较他们的数据类型）</p>
<p>1）使用typeof将他们区分开  </p>
<p>2）使用<strong>全等“===”: 比较的是 值和 数据类型</strong>，只有全都相同才返回 true</p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3521118.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——数据类型</a></li>
<li><a href="https://www.2cto.com/kf/201312/266358.html" target="_blank" rel="external">javascript之六种数据类型以及特殊注意点</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上下文]]></title>
      <url>/2017/03/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这篇文章介绍上下文以及Apply, call and bind的概念和常用方法。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><code>this</code>的指向就是我们这里所说的<strong>执行上下文（执行环境）</strong></p>
<p><code>this</code>指向的永远是调用该方法的对象</p>
<p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong></p>
<h3 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h3><h4 id="使用-ES6-的箭头函数"><a href="#使用-ES6-的箭头函数" class="headerlink" title="使用 ES6 的箭头函数"></a>使用 ES6 的箭头函数</h4><p>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</p>
<p><strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</strong></p>
<h4 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h4><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>基本作用: <strong>改变对象的执行上下文</strong></p>
<p>call 的语法为：<code>fun.call(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p>如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 thisArg 会指向该原始值的自动包装对象。</p>
<p>call是apply的语法糖。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>基本作用: <strong>改变对象的执行上下文</strong></p>
<p>语法：<code>fun.apply(thisArg, [argsArray])</code></p>
<blockquote>
<p>Note: argsArray从ECMAScript 5 开始可以使用类数组对象。</p>
</blockquote>
<p>当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>
<p>MDN的解释是：<code>bind()</code>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <code>bind()</code>方法的第一个参数作为 <code>this</code>，传入 <code>bind()</code> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p><strong>注意：<code>bind</code>方法的返回值是函数。所以，bind 是创建一个新的函数，要手动去调用</strong></p>
<p><code>bind()</code>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="上下文指向"><a href="#上下文指向" class="headerlink" title="上下文指向"></a>上下文指向</h2><h3 id="执行上下文结果"><a href="#执行上下文结果" class="headerlink" title="执行上下文结果"></a>执行上下文结果</h3><pre><code class="javascript">function func () {
    this.a = 1;
    console.log(this.a);
}
func();  // 1
a或window.a; //1
</code></pre>
<p>由于<code>func</code>是全局对象<code>window</code>下的一个方法，那么调用该方法的对象就应该是全局对象<code>window</code>，所以<code>this</code>理论上指向的对象就应该是<code>window</code></p>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>e.g.1</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
function a() {
 var name = &quot;Cherry&quot;;
 console.log(this.name);   // windowsName
 console.log(&quot;inner:&quot; + this); // inner: Window
}
a();
console.log(&quot;outer:&quot; + this)   // outer: Window
</code></pre>
<p>e.g.2</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
 var a = {
  name: &quot;Cherry&quot;,
  fn : function () {
   console.log(this.name);  // Cherry
  }
 }
 a.fn();
</code></pre>
<p>e.g.3</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
  name: &quot;Cherry&quot;,
  fn : function () {
    console.log(this.name);  // Cherry
  }
}
window.a.fn();
</code></pre>
<p>e.g.4</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 // name: &quot;Cherry&quot;,
 fn : function () {
  console.log(this.name);  // undefined
 }
}
window.a.fn();
</code></pre>
<p>e.g.5</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : null,
 // name: &quot;Cherry&quot;,
 fn : function () {
  console.log(this.name);  // windowsName
 }
}
var f = a.fn;
f();
</code></pre>
<p>e.g.6</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
function fn() {
 var name = &#39;Cherry&#39;;
 innerFunction();
 function innerFunction() {
  console.log(this.name);  // windowsName
 }
}
fn()
</code></pre>
<h2 id="call-与-apply"><a href="#call-与-apply" class="headerlink" title="call 与 apply"></a>call 与 apply</h2><h3 id="为什么需要改变执行上下文"><a href="#为什么需要改变执行上下文" class="headerlink" title="为什么需要改变执行上下文"></a>为什么需要改变执行上下文</h3><p>A对象有一个方法，而B对象因为某种不可言说的情况也需要用到一样的方法，那么这时候我们是单独为B扩展个方法呢，还是借用一下A的方法呢？当然是借用A的啦，既完成了需求，又减少了内存的占用</p>
<h3 id="call-与-apply-异同"><a href="#call-与-apply-异同" class="headerlink" title="call 与 apply 异同"></a>call 与 apply 异同</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，立即执行</p>
<p>都用来改变当前函数调用的对象。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><code>call</code>方法从第二个参数开始可以接收任意个参数</p>
<p><code>apply</code>方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入func中</p>
<p><code>foo.call(this,arg1,arg2) == foo.apply(this, arguments)==this.foo(arg1, arg2)</code></p>
<h3 id="call和apply常用用法"><a href="#call和apply常用用法" class="headerlink" title="call和apply常用用法"></a>call和apply常用用法</h3><h4 id="1-数组之间追加"><a href="#1-数组之间追加" class="headerlink" title="1.数组之间追加"></a>1.数组之间追加</h4><pre><code class="javascript">var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; 
var array2 = [&quot;Doe&quot; , 555 , 100]; 
Array.prototype.push.apply(array1, array2); 
/* array1 值为  [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */
</code></pre>
<h4 id="2-获取数组中的最大值和最小值"><a href="#2-获取数组中的最大值和最小值" class="headerlink" title="2. 获取数组中的最大值和最小值"></a>2. 获取数组中的最大值和最小值</h4><pre><code class="javascript">var  numbers = [5, 458 , 120 , -215 ]; 
var maxInNumbers = Math.max.apply(Math, numbers),   //458
    maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458
</code></pre>
<h4 id="3-验证是否是数组（前提是toString-方法没有被重写过）"><a href="#3-验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="3.验证是否是数组（前提是toString()方法没有被重写过）"></a>3.验证是否是数组（前提是toString()方法没有被重写过）</h4><pre><code class="javascript">functionisArray(obj){ 
    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ;
}
</code></pre>
<h4 id="4-类（伪）数组使用数组方法"><a href="#4-类（伪）数组使用数组方法" class="headerlink" title="4.类（伪）数组使用数组方法"></a>4.类（伪）数组使用数组方法</h4><pre><code class="javascript">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));
</code></pre>
<h4 id="5-给每一个-log-消息添加一个”-app-”的前辍"><a href="#5-给每一个-log-消息添加一个”-app-”的前辍" class="headerlink" title="5. 给每一个 log 消息添加一个”(app)”的前辍"></a>5. 给每一个 log 消息添加一个”(app)”的前辍</h4><pre><code class="javascript">function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift(&#39;(app)&#39;);
  console.log.apply(console, args);
};
</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h3><pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : &quot;Cherry&quot;,
 func1: function () {
  console.log(this.name)  
 },
 func2: function () {
  setTimeout( () =&gt; {
   this.func1()
  },100);
 }
};
a.func2()  // Cherry
</code></pre>
<p>替代方法：在函数内部使用 _this = this</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : &quot;Cherry&quot;,
 func1: function () {
  console.log(this.name)  
 },
 func2: function () {
  var _this = this;
  setTimeout( function() {
   _this.func1()
  },100);
 }
};
a.func2()  // Cherry
</code></pre>
<h2 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h2><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p><code>bind</code> 是返回<strong>对应函数</strong>，便于<strong>稍后调用</strong>；<code>apply</code> 、<code>call</code> 则是立即调用 。</p>
<pre><code class="javascript">var a ={
 name : &quot;Cherry&quot;,
 fn : function (a,b) {
  console.log( a + b)
 }
}
var b = a.fn;
b.bind(a,1,2)    //没有输出
</code></pre>
<p>bind 是创建一个新的函数，我们必须要手动去调用：</p>
<pre><code class="javascript">var a ={
  name : &quot;Cherry&quot;,
  fn : function (a,b) {
   console.log( a + b)
  }
 }
 var b = a.fn;
 b.bind(a,1,2)()   // 3
</code></pre>
<h3 id="连续-bind-多次输出的值"><a href="#连续-bind-多次输出的值" class="headerlink" title="连续 bind() 多次输出的值"></a>连续 bind() 多次输出的值</h3><pre><code class="javascript">var bar = function(){
    console.log(this.x);
}
var foo = {
    x:3
}
var sed = {
    x:4
}
var func = bar.bind(foo).bind(sed);
func(); //3

var fiv = {
    x:5
}
var func = bar.bind(foo).bind(sed).bind(fiv);
func(); //3
</code></pre>
<p>原因是，在Javascript中，<strong>多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</strong>可以理解成每次bind后生成一个新函数，而这个新函数的没有this指向。</p>
<h3 id="bind使用"><a href="#bind使用" class="headerlink" title="bind使用"></a>bind使用</h3><h4 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h4><pre><code class="javascript">var foo = {
    bar : 1,
    eventBind: function(){
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) {
            /* Act on the event */
            console.log(this.bar);      //1
        }.bind(this));
    }
}
</code></pre>
<h4 id="偏函数（Partial-Functions）"><a href="#偏函数（Partial-Functions）" class="headerlink" title="偏函数（Partial Functions）"></a>偏函数（Partial Functions）</h4><p>这是一个很好的特性，使用<code>bind()</code>我们设定函数的预定义参数，然后调用的时候传入其他参数即可：</p>
<pre><code class="javascript">function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

// 预定义参数37
var leadingThirtysevenList = list.bind(undefined, 37);

var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
</code></pre>
<h4 id="和setTimeout一起使用"><a href="#和setTimeout一起使用" class="headerlink" title="和setTimeout一起使用"></a>和setTimeout一起使用</h4><p>一般情况下<code>setTimeout()</code>的this指向window或global对象。当使用类的方法时需要this指向类实例，就可以使用<code>bind()</code>将this绑定到回调函数来管理实例。</p>
<p><strong>注意：对于事件处理函数和setInterval方法也可以使用上面的方法</strong></p>
<pre><code class="javascript">function Bloomer() {
  this.petalCount = Math.ceil(Math.random() * 12) + 1;
}

// 1秒后调用declare函数
Bloomer.prototype.bloom = function() {
  window.setTimeout(this.declare.bind(this), 1000);
};

Bloomer.prototype.declare = function() {
  console.log(&#39;我有 &#39; + this.petalCount + &#39; 朵花瓣!&#39;);
};
</code></pre>
<h4 id="绑定函数作为构造函数"><a href="#绑定函数作为构造函数" class="headerlink" title="绑定函数作为构造函数"></a>绑定函数作为构造函数</h4><p>绑定函数也适用于使用new操作符来构造目标函数的实例。当使用绑定函数来构造实例，<strong>注意：this会被忽略</strong>，但是传入的参数仍然可用。</p>
<pre><code class="javascript">function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function() { 
  return this.x + &#39;,&#39; + this.y; 
};

var p = new Point(1, 2);
p.toString(); // &#39;1,2&#39;


var emptyObj = {};
var YAxisPoint = Point.bind(emptyObj, 0/*x*/);
// 实现中的例子不支持,
// 原生bind支持:
var YAxisPoint = Point.bind(null, 0/*x*/);

var axisPoint = new YAxisPoint(5);
axisPoint.toString(); // &#39;0,5&#39;

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new Point(17, 42) instanceof YAxisPoint; // true
</code></pre>
<p>Point和YAxisPoint共享原型，因此使用<code>instanceof</code>运算符判断时为true。</p>
<h4 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h4><p><code>bind()</code>也可以为需要特定this值的函数创造捷径。</p>
<pre><code class="javascript">var slice = Array.prototype.slice;
// ...
slice.call(arguments);
</code></pre>
<p>如果使用<code>bind()</code>的话，情况变得更简单：</p>
<pre><code class="javascript">var unboundSlice = Array.prototype.slice;
var slice = Function.prototype.call.bind(unboundSlice);
// ...
slice(arguments);
</code></pre>
<h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply()实现"></a>apply()实现</h2><p>模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<pre><code class="javascript">Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&#39;arr[&#39; + i + &#39;]&#39;);
        }
        result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
    }

    delete context.fn
    return result;
}
</code></pre>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind()实现"></a>bind()实现</h2><p>通过给目标函数指定作用域来简单实现:</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  self = this;  //保存this，即调用bind方法的目标函数
  return function(){
      return self.apply(context,arguments);
  };
};
</code></pre>
<p>考虑到<a href="http://blog.jobbole.com/77956/" target="_blank" rel="external">函数柯里化</a>的情况，我们可以构建一个更加健壮的<code>bind()</code>：</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  var args = Array.prototype.slice.call(arguments, 1),
  self = this;
  return function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply(context,finalArgs);
  };
};
</code></pre>
<p>这次的<code>bind()</code>方法可以绑定对象，也支持在绑定的时候传参。</p>
<p>Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  var args = Array.prototype.slice(arguments, 1),
  F = function(){},
  self = this,
  bound = function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply((this instanceof F ? this : context), finalArgs);
  };

  F.prototype = self.prototype;
  bound.prototype = new F();
  retrun bound;
};
</code></pre>
<p>这是《JavaScript Web Application》一书中对<code>bind()</code>的实现：通过设置一个中转构造函数F，使绑定后的函数与调用<code>bind()</code>的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的<code>bind()</code>实现。</p>
<p>对于为了在浏览器中能支持<code>bind()</code>函数，只需要对上述函数稍微修改即可：</p>
<pre><code class="javascript">Function.prototype.bind = function (oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1), 
      fToBind = this, 
      fNOP = function () {},
      fBound = function () {
        return fToBind.apply(
          this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000002662251" target="_blank" rel="external">Javascript中bind()方法的使用与实现</a></li>
<li><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="external">JavaScript深入之call和apply的模拟实现</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>/2017/03/25/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍继承的写法，参考《JS高程》。<br>封装、多态待补。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><pre><code class="javascript">function Parent0(){
    this.name = &quot;parent0&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child0(){
    Parent0.call( this ); // 或apply
    this.type = &quot;child0&quot;;
}
</code></pre>
<p>问题：</p>
<p>这种方式，父类原型上的东西（<strong>原型对象</strong>）是没法继承的，因此函数复用也就无从谈起，（部分继承）</p>
<h3 id="原型链式继承（借用原型链实现继承）"><a href="#原型链式继承（借用原型链实现继承）" class="headerlink" title="原型链式继承（借用原型链实现继承）"></a>原型链式继承（借用原型链实现继承）</h3><pre><code class="javascript">function Parent1(){
    this.name = &quot;parent1&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child1(){
    this.name = &quot;child1&quot;;
}
Child1.prototype = new Parent1();
</code></pre>
<p>这种方式确实解决了上面借用构造函数继承方式的缺点。</p>
<p>问题：</p>
<ol>
<li><strong>注意：包含引用类型会被共享</strong></li>
<li><strong>构造子类型无法向超类型构造函数传参。</strong></li>
</ol>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>这里所谓的组合是指组合借用构造函数和原型链继承两种方式。</p>
<pre><code class="javascript">//2.原型连继承和借用构造函数 组合实现继承 （组合继承解决原型链继承的引用类型原型属性被实例共享问题）  
function father(name) {  
  this.faName = &#39;father&#39;;  
}  
father.prototype.getfaName = function() {  
  console.log(this.faName);  
};  
function child(args) {  
  this.chName = &#39;child&#39;;  
  father.apply(this,[]); //第二次调用父类构造函数  
}  
child.prototype = new father(); //第一次调用父类构造函数  
child.prototype.constructor = child;  
child.prototype.getchName = function() {  
  console.log(this.chName);  
};  
/* 
缺点：1.两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部） 
     2.子类继承父类的属性，第二次一组在子类实例上，第一次一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低 
*/
</code></pre>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><pre><code class="javascript">function object (o) {
    function F() {}
    F.prototype = o;
    return new F();
}
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person1 = object (person);
person1.name = &quot;Gerg&quot;;
person1.friends.push(&quot;Job&quot;);
console.log(person1.name);
console.log(person1.friends);

var person2 = object(person);
console.log(person2.name);
console.log(person2.friends);

或es5
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person2 = object.create(person);
</code></pre>
<p>object函数就是改变构造函数的prototype对象的，比如说你要继承person中的属性，那么就写一个空函数，把空函数的prototype对象修改成person。</p>
<p>问题：</p>
<p>引用类型有问题，同原型链式继承</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><pre><code class="javascript">function createAnother(original){
 var clone = Object.create(original); //通过调用函数创建一个新对象
 clone.sayHi = function(){    //以某种方式来增强这个对象
  alert(&quot;Hi&quot;);
 };

 return clone;      //返回这个对象
}

var person = {
 name: &quot;Bob&quot;,
 friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();
</code></pre>
<p>问题：</p>
<p>添加函数，不能复用</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><pre><code class="javascript">function inheritPrototype(subType, superType){
 var protoType = Object.create(superType.prototype); //创建对象
 protoType.constructor = subType;     //增强对象
 subType.prototype = protoType;      //指定对象
}

function SuperType(name){
 this.name = name;
 this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
 alert(this.name);
}

function SubType(name, age){
 SuperType.call(this, name);　　//第二次调用SuperType()

 this.age = age;
}
inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function(){
 alert(this.age);
}

var instance = new SubType(&quot;Bob&quot;, 18);
instance.sayName();
instance.sayAge();
</code></pre>
<p>将新创建的对象（即副本）赋值给子类型的原型这种方法只调用了一次SuperType构造函数，instanceof 和isPrototypeOf()也能正常使用。</p>
<h3 id="ES6中继承"><a href="#ES6中继承" class="headerlink" title="ES6中继承"></a>ES6中继承</h3><p><code>Class</code> 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code class="javascript">class Parent {
}
class Child1 extends Parent {
    constructor(x, y, colors) {
         super(x, y); // 调用父类的constructor(x, y)
         this.colors = colors;
    }
    toString() {
         return this.colors + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}
</code></pre>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
<p>另一个需要注意的地方是， 在子类的构造函数中， 只有调用super之后， 才可以使用this关键字， 否则会报错。 这是因为子类实例的构建， 是基于对父类实例加工， 只有super方法才能返回父类实例。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="ES6继承的原理"><a href="#ES6继承的原理" class="headerlink" title="ES6继承的原理"></a>ES6继承的原理</h2>]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象]]></title>
      <url>/2017/02/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文介绍面向对象编程的思想</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="方法一：Object"><a href="#方法一：Object" class="headerlink" title="方法一：Object()"></a>方法一：Object()</h3><h3 id="方法二：对象字面量"><a href="#方法二：对象字面量" class="headerlink" title="方法二：对象字面量"></a>方法二：对象字面量</h3><p><strong>Case</strong></p>
<pre><code class="javascript">var bitch = new Object();
bitch.boobs = &#39;huge&#39;;
bitch[&#39;bf&#39;] = {name:Jhon,age:22};
</code></pre>
<p>在调用Object()构造函数时，new运算符实际上是可以省略的，这点可以推广到其他很多构造函数上，但有两个是例外：String() 和 Number()。<strong>对这两个函数而言，如果不加new，只是作一次数据类型的转换，得到的将是基本数据类型的值；而带new运算符的话，得到的将是String/Number的实例。</strong></p>
<p>这两种方法创建对象简单直观，但也存在问题，那就是<strong>无法批量生产对象</strong>。由此，工厂模式应运而生。</p>
<h3 id="方法三：工厂模式（注意区别于设计模式中的工厂模式）"><a href="#方法三：工厂模式（注意区别于设计模式中的工厂模式）" class="headerlink" title="方法三：工厂模式（注意区别于设计模式中的工厂模式）"></a>方法三：工厂模式（注意区别于设计模式中的工厂模式）</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    var bitch = new Object();
    bitch.boobs = boobs;
    bitch.bf = {name:bfName,age:bfAge};
    bitch.cry = function(){console.log(&#39;Crying&#39;);}
　　return bitch;
}
　　bitch=Bitch(&#39;huge&#39;,&#39;Jhon&#39;,22);
</code></pre>
<p><strong>工厂模式解决了对象的批量生产问题，但还有个问题没有解决——对象的识别问题</strong>。也就是说，这样创建出来的对象是独立的个体，跟其他对象没关系，即使是用同一个函数创建出来的对象，也是互不相识的:</p>
<p><code>bitch instanceof Bitch //false</code></p>
<h3 id="方法四：构造函数模式"><a href="#方法四：构造函数模式" class="headerlink" title="方法四：构造函数模式"></a>方法四：构造函数模式</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    this.boobs=boobs;
    this.bf={name:bfName, age:bfAge};
　  this.cry = function(){console.log(&#39;Crying&#39;);}
}
bitch=new Bitch(&#39;huge&#39;,&#39;Jhon&#39;,22);
</code></pre>
<p>对比工厂模式可以发现构造函数模式的特点：一，没有显示创建对象，而是直接将对象属性赋给了this指针；二，没有return语句；三，调用时需要用new运算府。其实，最关键的地方在于这个new运算符，如果不加这个new，那构造函数就是个普通函数；而任何普通函数在调用时前面加new运算符的话就会变成构造函数。</p>
<p>对象识别没有问题，但存在一个问题：对象的所有函数属性在每个对象上都要重新创建一遍，而这些函数实际上完全相同</p>
<h3 id="方法五：原型模式"><a href="#方法五：原型模式" class="headerlink" title="方法五：原型模式"></a>方法五：原型模式</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    this.boobs=boobs;
    this.bf={name:bfName, age:bfAge};
}
Bitch.prototype.cry = function(){console.log(&#39;Crying&#39;);};
</code></pre>
<p>组合使用构造函数模式和原型模式，前者负责个性，后者负责共性</p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>通过闭包访问</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boo,bfName,bfAge){
    var boobs = boo; // 私有属性
    this.bf={name:bfName, age:bfAge}; // 公共属性
    this.watchBoobs = function(){ return &#39;huge&#39;; }; // 私有属性的访问接口
}
Bitch.prototype.cry = function(){console.log(&#39;Crying&#39;);};
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>Case</strong></p>
<pre><code class="javascript">function Sup(a){
    this.a = a;
}
Sup.prototype.foo = function(){console.log(&#39;Function of Sup.prototype&#39;);}
function Sub(a,b){
    this.a = a;
    this.b = b;
}
Sub.prototype = new Sup();
Sub.prototype.bar = function(){console.log(&#39;Function of Sub.prototype&#39;);}
</code></pre>
<p>注意比较JS继承与传统OO语言继承之间的差别，我觉得区别主要有两点：</p>
<ul>
<li>传统OO语言的继承是类的继承，是抽象概念之间的继承，实现继承并不需要父类的实例；而JS的继承则是实例的继承，子类继承的是父类的一个实例。</li>
<li>传统OO语言的继承分public/private/protected等不同的继承方式，而JS本身连私有变量的概念都没有，就更不可能区分共有继承和私有继承了。</li>
</ul>
<p>上述JS实现继承的方式称为“原型模式”，这种方式存在几个缺点：</p>
<ul>
<li>在创建子类实例时，不能向父类的构造函数传递参数</li>
<li>当父类属性存在引用类型值时，会造成致命问题。</li>
</ul>
<p>解决方法：借用构造函数模式，将二者结合起来</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Sup(a){
    this.a = a;
}
Sup.prototype.foo = function(){console.log(&#39;Function of Sup.prototype&#39;);}
function Sub(a,b){
    Sup.apply(this,arguments);    //Sup.call(this,a);不方便扩展
    this.b = b;
}
Sub.prototype = new Sup();
Sub.prototype.construtor = Sub;
Sub.prototype.bar = function(){console.log(&#39;Function of Sub.prototype&#39;);}
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/zhangjianhu/p/4548693.html" target="_blank" rel="external">由几道JS笔试题引发的知识点探究十五——JS面向对象编程</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逗号、冒号与括号]]></title>
      <url>/2017/02/27/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E9%80%97%E5%8F%B7%E3%80%81%E5%86%92%E5%8F%B7%E4%B8%8E%E6%8B%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>有看见一些很好的博文做这点，感觉有必要对这些坑总结记录一下。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><p><strong>连续声明一些变量</strong></p>
<p><strong>方法参数，对象属性</strong>我们使用逗号隔开</p>
<p><strong>赋值表达式</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a=(1,2,3);
</code></pre>
<p>在表达式与运算符中提到过逗号运算符就是对应这种情况，这时表达式计算结果是最后一个子表达式结果，也就是3。千万不要误会前面的子表达式不会执行，每个子表达式都会执行，只不过“返回值”是最后一个表达式结果。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a,b;
a=(b=1,2);
console.log(a);//2
console.log(b);//1
</code></pre>
<h2 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h2><p><strong>?:运算符</strong></p>
<p><strong>对象字面量</strong></p>
<p><strong>switch语句</strong></p>
<p><strong>声明label</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">x:y:z:1,2,3;
//相当于
x:
 y:
  z:1,2,3
</code></pre>
<p>其实冒号还有个作用：声明label，JavaScript中语句可以有个标签前缀，我们称之为标记语句</p>
<h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p><strong>对象直接量声明</strong></p>
<p><strong>函数声明或者函数直接量</strong></p>
<p><strong>组织复合语句</strong></p>
<h3 id="大括号没有带来块级作用域"><a href="#大括号没有带来块级作用域" class="headerlink" title="大括号没有带来块级作用域"></a>大括号没有带来块级作用域</h3><ol>
<li>在function外使用声明变量（无论是否使用var）</li>
<li>在function内不是用var 声明变量</li>
<li>直接赋值于window属性</li>
<li>除了这三种剩下的就是function范围内的局部变量了</li>
</ol>
<p><strong>Case</strong></p>
<pre><code class="javascript">{a:1};        //1
var x={a:1};
{a:1,b:2};    //报错
var y={a:1,b:2};
</code></pre>
<p><strong>{a:1}</strong> JavaScript有传说中的“语句优先”，也就是当大括号既可以被理解为复合语句块也可以被理解为对象直接量的时候，JavaScript会将其理解为复合语句快。{a:1}其实就是 <strong>a: 1</strong>，想想冒号的作用是不是知道为什么返回值是1了。</p>
<p><strong>{a:1,b:2};</strong> 看了上面这个就简单了，可以翻译为：<strong>a:1,b:2</strong> 结合逗号和冒号作用，结果似乎显而易见了，就是2嘛。然而其实报错了，这是为什么？在<strong>逗号运算符后面必须是表达式</strong>，而标签语句十个label statement，是条语句，所以就报错了。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">{foo:[1,2,3]}[0];
{a:1}+2;
2+{a:1};
</code></pre>
<p><strong>大括号虽然看起来没什么作用，但起到了语句分隔符作用</strong>，{foo:[1,2,3]}[0]可以理解为</p>
<pre><code class="javascript">{foo:[1,2,3]};
[0];
</code></pre>
<p>所以返回值是[0]，同样{a:1}+2变为</p>
<pre><code class="javascript">{a:1};
+2
</code></pre>
<p>但是！为什么2+{a:1}就不一样了呢？这时加法运算符导致的，加号是左结合的，{}被解析为表达式（得是表达式相加嘛），根据<a href="http://www.cnblogs.com/dolphinX/p/3521118.html" target="_blank" rel="external">数据类型</a>中知识对象{a:1}转换为NaN</p>
<h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h2><p><strong>函数声明或调用表达式参数表</strong></p>
<p><strong>与一些关键字组成条件语句</strong></p>
<p><strong>分组运算符</strong></p>
<p>对于简单的json字符串转为对象的时候，因为浏览器兼容性原因，不能使用JSON对象，又懒得引入json2，所以就会用eval()处理，大概写法这样</p>
<pre><code class="javascript">var jsonStr=...;
var jsonObj=eval(&#39;(&#39; + jsonStr + &#39;)&#39;);
</code></pre>
<p>为什么还要加上个小括号呢？像我们上面解释的大括号的作用，json字符串 “{a:1,b:2}” 这样的格式会被理解为语句，也就是传说中的label statement，上面提到过逗号运算符不能在label statement后面，所以会报错，而加上括号后由于分组运算符只能包含表达式，所以{}变成直接量语法，这样就是我们希望的内容了。</p>
<h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h3><p>函数表达式和函数声明区别:</p>
<p>常用的区分方式是根据上下文，如果function fn(){}作为右值出现（赋值表达式右边）那么就是表达式，否则就是函数声明。有几种看起来不常规的方式需要我们注意</p>
<pre><code class="javascript">new function fn(){}; //表达式，因为在new 表达式中
(function(){}());//表达式，在分组运算符中
</code></pre>
<p>所以应该称立即执行函数为立即调用的函数表达式！</p>
<h2 id="中括号"><a href="#中括号" class="headerlink" title="中括号"></a>中括号</h2><p><strong>数组相关</strong></p>
<p><strong>获取对象属性值</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">[1,2,3,4,5][0..toString.length];    // 2
&#39;foo&#39;.split(&#39;&#39;) + [];    //&quot;f,o,o&quot;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3529249.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——逗号、冒号与括号</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[表达式与运算符]]></title>
      <url>/2017/02/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/JavaScript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这篇文章整理一些表达式和运算符的点和坑。</p>
<a id="more"></a>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="表达式形式"><a href="#表达式形式" class="headerlink" title="表达式形式"></a>表达式形式</h3><ol>
<li><p>原始表达式</p>
<blockquote>
<p>常量、变量、保留字</p>
</blockquote>
</li>
<li><p>对象、数组初始化表达式</p>
<blockquote>
<p>var obj={a:1,b:2};<br>var a=[1,2,3];</p>
</blockquote>
</li>
<li><p>函数定义表达式</p>
<blockquote>
<p>var fn=function(){}</p>
</blockquote>
</li>
<li><p>属性访问表达式</p>
<blockquote>
<p>Math.abs</p>
</blockquote>
</li>
<li><p>调用表达式</p>
<blockquote>
<p>alert(‘hello’);</p>
</blockquote>
</li>
<li><p>对象创建表达式</p>
<blockquote>
<p>new object();</p>
</blockquote>
</li>
</ol>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p><strong>Case</strong></p>
<pre><code class="javascript">var f = function g(){ console.log(g);};
f();//function g(){ console.log(g);};
typeof g();//g is not defined
</code></pre>
<p>当我们使用函数声明的方式定义一个函数的时候，实际上声明了一个变量，在上面例子中就是f，并把函数赋值给这个变量，<strong>普通的函数表达式没有创建该变量，也就是我们所说的创建了一个匿名函数，但是如果函数表达式包含名称，也就是上面例子的g，那么函数的局部作用域将包含将包含该名称，并且把创建的函数绑定到该名称上</strong>，在上面例子中g变成了函数的局部变量，变量指向函数本身，所以我们调用f的时候会把其本身打印出来。但是g只作为函数的局部变量存在，我们在外部调用g的时候就会报错了。</p>
<blockquote>
<p>命名函数表达式在创建的时候，会在当前作用域最前段添加一个新的对象{func_name:refer_function_expression},然后，将作用域链添加到<br>函数表达式的[[scope]]中，接着在删除该对象。</p>
</blockquote>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><pre><code class="javascript">(function(){})();
</code></pre>
<blockquote>
<p>(函数定义表达式)函数调用表达式</p>
</blockquote>
<p>当函数执行有命名冲突的时候，函数依次填入 变量＝》函数＝》参数，所以最后被填入的参数f会覆盖函数定义f</p>
<h3 id="表达式返回值"><a href="#表达式返回值" class="headerlink" title="表达式返回值"></a>表达式返回值</h3><h4 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h4><p><strong>函数定义表达式</strong>返回的是函数对象本身，我们在调用alert或者console.log的时候会调用其toString方法</p>
<pre><code class="javascript">console.log(function(){alert(&#39;a&#39;);}) //function (){alert(&#39;a&#39;);}
</code></pre>
<h4 id="函数调用表达式"><a href="#函数调用表达式" class="headerlink" title="函数调用表达式"></a>函数调用表达式</h4><p><strong>函数调用表达式</strong>自然是返回函数的return结果，但在JavaScript中并不是所有的函数都有return语句，对于没有return语句的function，其调用表达式返回undefined，对于只写个return的坑爹做法同样也是返回undefined</p>
<pre><code class="javascript">(function(){})(); //undefined
(function(){return;})();//undefined
</code></pre>
<h4 id="对象创建表达式"><a href="#对象创建表达式" class="headerlink" title="对象创建表达式"></a>对象创建表达式</h4><p><strong>对象创建表达式</strong>本来也应该很简单，返回new的对象就可以了</p>
<pre><code class="javascript">typeof new Date(); //&quot;object&quot;
</code></pre>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Test(){
    return new Date();
}
var test=new Test();
console.log(test instanceof Test);//false
console.log(test);//Sat Jan 18 2014 14:57:08 GMT+0800 (CST)
</code></pre>
<pre><code class="javascript">function Test(){
    return new Date();
}
function Test2(){
    return 2;
}
typeof new Test();
new Test2() instanceof Test2;//true，竟然是true
</code></pre>
<p><strong>当使用function的构造函数创建对象（new XXX）的时候，如果函数return基本类型或者没有return（其实就是return undefined）的时候， new 返回的是对象的实例；如果函数return的是一个对象，那么new 将返回这个对象而不是函数实例</strong>。</p>
<p>这里千万别把构造函数（使用new）和普通函数调用混淆了，普通函数调用还是该返回什么返回什么的。见Case1。</p>
<pre><code class="javascript">&#39;foo&#39; == new function(){ return String(&#39;foo&#39;); }; //false,后者为{}
&#39;foo&#39; == new function(){ return new String(&#39;foo&#39;); };//true
</code></pre>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h3><p>运算符的优先级《JavaScript权威指南》中有个表阐述的很好（我去掉了位运算部分），其中R/L代表结合性是右结合还是左结合，num-&gt;num表示操作符期望的数据类型和计算结果类型，lval指左值</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>结合性</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>++</td>
<td>自增</td>
<td>R</td>
<td>lval-&gt;num</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>R</td>
<td>lval-&gt;num</td>
</tr>
<tr>
<td>-</td>
<td>求反</td>
<td>R</td>
<td>num-&gt;num</td>
</tr>
<tr>
<td>+（一个操作数）</td>
<td>转换为数字</td>
<td>R</td>
<td>num-&gt;num</td>
</tr>
<tr>
<td>~</td>
<td>按位求反</td>
<td>R</td>
<td>int-&gt;int</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>R</td>
<td>bool-&gt;bool</td>
</tr>
<tr>
<td>delete</td>
<td>删除属性</td>
<td>R</td>
<td>lval-&gt;bool</td>
</tr>
<tr>
<td>typeof</td>
<td>检测数据类型</td>
<td>R</td>
<td>any-&gt;str</td>
</tr>
<tr>
<td>void</td>
<td>返回undefined</td>
<td>R</td>
<td>any-&gt;undefined</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘、除、求余</td>
<td>L</td>
<td>num,num-&gt;num</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+、-</td>
<td>加、减</td>
<td>L</td>
<td>num,num-&gt;num</td>
</tr>
<tr>
<td>+</td>
<td>字符串拼接</td>
<td>L</td>
<td>str,str-&gt;str</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>数字大小或字母表顺序</td>
<td>L</td>
<td>num/str,num/str-&gt;bool</td>
</tr>
<tr>
<td>instanceof</td>
<td>对象类型</td>
<td>L</td>
<td>obj,function-&gt;bool</td>
</tr>
<tr>
<td>in</td>
<td>测试属性是否存在</td>
<td>L</td>
<td>str,obj-&gt;bool</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>==</td>
<td>判断相等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>！=</td>
<td>判断不等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>===</td>
<td>判断恒等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>!==</td>
<td>判断非恒等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>逻辑或</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
<td>R</td>
<td>bool,any,any-&gt;any</td>
</tr>
<tr>
<td>=赋值 *=、/=、+=、-=</td>
<td>赋值 运算且赋值</td>
<td>R</td>
<td>lval,any-&gt;any</td>
</tr>
<tr>
<td>,</td>
<td>忽略第一个操作数，返回第二个操作数</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
</tbody>
</table>
<p>有几个我们需要注意的地方</p>
<ul>
<li>typeof的优先级相当的高，比加减乘除神马的都高，所以虽然是操作符，在在复杂表达式的时候我们还是习惯家括号，看个例子</li>
</ul>
<pre><code class="javascript">  typeof 2*3;//NaN
  typeof (2*3);//&quot;number&quot;
  typeof 2+3;// &quot;number3&quot;
</code></pre>
<ul>
<li>++、–是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数</li>
</ul>
<pre><code class="javascript">  var a=0,b=0;
  a+++b;//0
  a;//1，++优先级比+高，所以相当于(a++)+b
  b;//0
</code></pre>
<ul>
<li><p>赋值运算符的优先级相当的低</p>
</li>
<li><p>逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除</p>
</li>
</ul>
<h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>在JavaScript中严格按照从左到右的顺序计算表达式，然后再按照优先级和结合性计算各个表达式和运算符作用结果。</p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p>“===”是严格意义的相等，只需注意NaN和NaN不等就行了。</p>
<p>使用”==”的时候会在哪些情况下做类型转换，又会换成什么样子？</p>
<ol>
<li>如果两个值类型相同，则执行严格相等的运算</li>
<li>如果两个值的类型不同<ul>
<li>如果一个是null，一个是undefined，那么相等</li>
<li>如果一个是数字，一个是字符串，先将字符串转为数字，然后比较</li>
<li>如果一个值是true/false则将其转为1/0比较</li>
<li>如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较</li>
<li>其它就不相等了</li>
</ul>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-function与new-function"><a href="#Case1-function与new-function" class="headerlink" title="Case1.function与new function"></a>Case1.function与new function</h2><p>只要new 表达式之后的constructor返回一个引用对象（数组，对象，函数等），都将覆盖new创建的匿名对象。如果返回一个原始类型，那么就返回一个new创建的匿名对象。</p>
<pre><code class="javascript">var result=new function(){return &quot;圆心&quot;};
alert(result);//[object object]
</code></pre>
<p>此时等于：</p>
<pre><code class="javascript">function 匿名类(){
  return &quot;圆心&quot;;
}
var result= new 匿名类(); 
alert(result);  //此时为对象
</code></pre>
<p>如果改成</p>
<pre><code class="javascript">var result=new function(){return new String(&quot;圆心&quot;)};
alert(result);//圆心
</code></pre>
<p>返回一个对象，覆盖了new创建的匿名函数对象。</p>
<p>由于 new String 会构造一个对象，而不是一个 string 直接量，且new String(x) 如果带参数，那么alert它的时候就会返回 x。所以 result将返回 new String(”圆心”) 这个对象，而 alert result则显示 “圆心”。</p>
<pre><code class="javascript">//A
var result=function(){return&quot;圆心&quot;}();
alert(result());  //圆心
//B
var result=function(){return&quot;圆心&quot;};
alert(result);// function(){return&quot;圆心&quot;};
alert(result());  //圆心
</code></pre>
<p>A等于</p>
<pre><code class="javascript">var 匿名函数=function(){return&quot;圆心&quot;};
result=匿名函数();//返回匿名函数的执行结果
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3524977.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——表达式与运算符</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML基础]]></title>
      <url>/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>HTML的一些基础概念理解。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="对Web标准的理解"><a href="#对Web标准的理解" class="headerlink" title="对Web标准的理解"></a>对Web标准的理解</h2><p>1.html：</p>
<ul>
<li>标签字母要小写</li>
<li>标签要闭合</li>
<li>标签不允许随意嵌套</li>
</ul>
<p>2.css和js:</p>
<ul>
<li>尽量使用外链css样式表和js脚本。</li>
<li>样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快。</li>
<li>不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</li>
</ul>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h3 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h3><p>渲染引擎 + JS引擎</p>
<h3 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h3><ul>
<li>Trident内核：IE，360，搜狗浏览器；</li>
<li>Gecko内核：Netscape6及以上版本，Mozilla FireFox(火狐浏览器)</li>
<li>Presto内核：Opera</li>
<li>Blink内核：Opera；</li>
<li>Webkit内核：Safari，Chrome</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>Trident内核</strong>：和W3C标准脱节，大量Bug等安全问题</li>
<li><strong>Presto内核</strong>：速度最快，缺点是兼容性。</li>
<li><strong>Gecko内核</strong>：功能强大，消耗很多的资源。</li>
<li><strong>Webkit内核</strong>：速度较快，兼容性较低</li>
</ul>
<h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><h3 id="为什么要语义化"><a href="#为什么要语义化" class="headerlink" title="为什么要语义化"></a>为什么要语义化</h3><ul>
<li>有利于seo</li>
<li>方便其他设备监听 屏幕阅读设备 盲人阅读器</li>
<li>方便团队协作开发</li>
</ul>
<h3 id="语义化元素"><a href="#语义化元素" class="headerlink" title="语义化元素"></a>语义化元素</h3><ul>
<li>header, footer, hgroup, nav, article, section</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><h3 id="Doctype作用？"><a href="#Doctype作用？" class="headerlink" title="Doctype作用？"></a>Doctype作用？</h3><p>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>
<h3 id="标准模式与兼容模式各有什么区别"><a href="#标准模式与兼容模式各有什么区别" class="headerlink" title="标准模式与兼容模式各有什么区别?"></a>标准模式与兼容模式各有什么区别?</h3><p>标准模式的排版和JS运作模式是以浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容方式显示。</p>
<h3 id="HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;？"></a>HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;？</h3><p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为；</p>
<p>而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><h3 id="html加载顺序"><a href="#html加载顺序" class="headerlink" title="html加载顺序"></a>html加载顺序</h3><p>正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载HTML网页，一边开始解析</li>
<li>解析过程中，发现<code>&lt;script&gt;</code>标签</li>
<li>暂停解析，网页渲染的控制权转交给JavaScript引擎</li>
<li>如果<code>&lt;script&gt;</code>标签引用了外部脚本，就下载该脚本，否则就直接执行</li>
<li>执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</li>
</ol>
<h3 id="js放在网页尾部加载"><a href="#js放在网页尾部加载" class="headerlink" title="js放在网页尾部加载"></a>js放在网页尾部加载</h3><ul>
<li>js放在head中会立即执行，阻塞后续的资源下载与执行。</li>
<li>因为js有可能会修改dom，如果不阻塞后续的资源下载，dom的操作顺序不可控。在DOM结构生成之前就调用DOM，JavaScript会报错</li>
</ul>
<h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><p>1.css需要分块，首页的css独立，其余的css需要动态加载，因为html的绘制会被css阻塞，这样可以减少首次进入时的白屏时间。</p>
<blockquote>
<p>js的执行依赖前面的样式。即只有前面的样式全部下载完成后才会执行js，但是此时外链css和外链js是并行下载的。</p>
</blockquote>
<p>2.defer=”true”属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。</p>
<blockquote>
<p>对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，<code>defer</code>属性不起作用。</p>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><blockquote>
<p><code>DOCTYPE html</code></p>
</blockquote>
<p>IE6+兼容，都是标准模式，IE6-是怪异模式</p>
<h3 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h3><blockquote>
<p><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</code></p>
</blockquote>
<p>xmlns是XHTML namespace的缩写。</p>
<p>作用：xml采用名字空间声明，通过网址来识别标记。</p>
<p>XHTML是HTML先xml过度的标记语言，它需要符合xml文档规则，因此，也需要定义名字空间，又因为XHTML1.0不能自定义标识，所以，它的名字空间都相同</p>
<h3 id="webkit"><a href="#webkit" class="headerlink" title="webkit"></a>webkit</h3><blockquote>
<p><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></p>
</blockquote>
<p>对于双核浏览器，如果用户手动调节成兼容模式，那么无法切换为极速模式</p>
<h3 id="X-UA-Compatible"><a href="#X-UA-Compatible" class="headerlink" title="X-UA-Compatible"></a>X-UA-Compatible</h3><blockquote>
<p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code></p>
</blockquote>
<p>IE8的专用标记，指定IE8去模拟某个版本IE浏览器的渲染方式(比如IE6)，以此来解决部分兼容问题</p>
<p>谷歌做了个外挂：Google Chrome Frame(谷歌内嵌浏览器框架GCF)。这个插件可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</p>
<p>这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果为安装GCF，则使用最高版本的IE内核进行渲染。</p>
<h3 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h3><blockquote>
<p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;...&quot; type=&quot;image/x-icon&quot; /&gt;</code></p>
</blockquote>
<p>固定写法，定义网站图标</p>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《阮一峰--React入门实例教程》笔记]]></title>
      <url>/2017/01/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/%E3%80%8A%E9%98%AE%E4%B8%80%E5%B3%B0--React%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>《阮一峰 –React 入门实例教程》笔记 </p>
<p>个人认为讲的太浅，无门槛但是收获也低。推荐官方文档。</p>
<a id="more"></a>
<h2 id="《React-入门实例教程》笔记"><a href="#《React-入门实例教程》笔记" class="headerlink" title="《React 入门实例教程》笔记"></a>《React 入门实例教程》笔记</h2><blockquote>
<p>作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a></p>
</blockquote>
<h3 id="一、HTML-模板"><a href="#一、HTML-模板" class="headerlink" title="一、HTML 模板"></a>一、HTML 模板</h3><p>首先，最后一个 <code>&lt;script&gt;</code> 标签的 <code>type</code> 属性为 <code>text/babel</code> 。这是因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 <code>type=&quot;text/babel&quot;</code> 。</p>
<p>上面代码一共用了三个库： <code>react.js</code> 、<code>react-dom.js</code> 和 <code>Browser.js</code> ，它们必须首先加载。其中，<code>react.js</code> 是 React 的核心库，<code>react-dom.js</code> 是提供与 DOM 相关的功能，<code>Browser.js</code>的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>
<h3 id="二、ReactDOM-render"><a href="#二、ReactDOM-render" class="headerlink" title="二、ReactDOM.render()"></a>二、ReactDOM.render()</h3><p>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。</p>
<p>注意：有逗号无分号</p>
<pre><code class="javascript">ReactDOM.render(
  &lt;HelloMessage name=&quot;john&quot;&gt;&lt;/HelloMessage&gt;,
  document.getElementById(&#39;example&#39;)
)
</code></pre>
<h3 id="三、JSX-语法"><a href="#三、JSX-语法" class="headerlink" title="三、JSX 语法"></a>三、JSX 语法</h3><p> JSX 的基本语法规则：遇到 HTML 标签（以 <code>&lt;</code> 开头），就用 HTML 规则解析；遇到代码块（以 <code>{</code> 开头），就用 JavaScript 规则解析。</p>
<p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员</p>
<h3 id="四、组件"><a href="#四、组件" class="headerlink" title="四、组件"></a>四、组件</h3><ul>
<li>所有组件类都必须有自己的 <code>render</code> 方法，用于输出组件。</li>
</ul>
<ul>
<li>组件类的第一个字母必须大写，否则会报错</li>
<li>组件类只能包含一个顶层标签，否则也会报错。</li>
<li>组件的属性可以在组件类的 <code>this.props</code> 对象上获取</li>
<li>添加组件属性，有一个地方需要注意，就是 <code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code> ，这是因为 <code>class</code> 和 <code>for</code> 是 JavaScript 的保留字。</li>
</ul>
<h3 id="五、this-props-children"><a href="#五、this-props-children" class="headerlink" title="五、this.props.children"></a>五、this.props.children</h3><p><code>this.props.children</code> 属性。它表示组件的所有子节点</p>
<p>需要注意， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</p>
<p>React 提供一个工具方法 <a href="https://facebook.github.io/react/docs/top-level-api.html#react.children" target="_blank" rel="external"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</p>
<h3 id="六、PropTypes"><a href="#六、PropTypes" class="headerlink" title="六、PropTypes"></a>六、PropTypes</h3><p>组件类的<code>PropTypes</code>属性，就是用来验证组件实例的属性是否符合要求</p>
<p>此外，<code>getDefaultProps</code> 方法可以用来设置组件属性的默认值。s</p>
<h3 id="七、获取真实的DOM节点"><a href="#七、获取真实的DOM节点" class="headerlink" title="七、获取真实的DOM节点"></a>七、获取真实的DOM节点</h3><p>组件是virtual DOM，只有当它插入文档以后，才会变成真实的 DOM 。</p>
<p>有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性</p>
<p>需要注意的是，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。</p>
<p>React 组件支持很多事件，除了 <code>Click</code> 事件以外，还有 <code>KeyDown</code> 、<code>Copy</code>、<code>Scroll</code> 等</p>
<p>注意：引用是refs，定义是ref</p>
<pre><code class="javascript">var MyComponent = React.createClass({
  handleClick: function() {
    this.refs.myTextInput.focus();
  },
  render: function() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<h3 id="八、this-state"><a href="#八、this-state" class="headerlink" title="八、this.state"></a>八、this.state</h3><p>将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI </p>
<p><code>getInitialState</code> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。</p>
<p>由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p>
<h3 id="九、表单"><a href="#九、表单" class="headerlink" title="九、表单"></a>九、表单</h3><p>用户在表单填入的内容，属于用户跟组件的互动，所以不能用 <code>this.props</code> 读取</p>
<p>文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。</p>
<h3 id="十、组件的生命周期"><a href="#十、组件的生命周期" class="headerlink" title="十、组件的生命周期"></a>十、组件的生命周期</h3><p>组件的<a href="https://facebook.github.io/react/docs/working-with-the-browser.html#component-lifecycle" target="_blank" rel="external">生命周期</a>分成三个状态：</p>
<blockquote>
<ul>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ul>
</blockquote>
<p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<blockquote>
<ul>
<li>componentWillMount()</li>
<li>componentDidMount()</li>
<li>componentWillUpdate(object nextProps, object nextState)</li>
<li>componentDidUpdate(object prevProps, object prevState)</li>
<li>componentWillUnmount()</li>
</ul>
</blockquote>
<p>React 还提供两种特殊状态的处理函数。</p>
<blockquote>
<ul>
<li>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</li>
</ul>
</blockquote>
<p>注意setinterval()方法中，回调函数一定要加.bind(this)方法，原因是：在setInterval()中定义的回调函数，是在同步代码执行完后，随着事件触发来异步执行的，此时函数的上下文Context已经由定义该函数的Script文件变为全局变量，如果不通过bind(this)来指定由组件实例作为上下文的话，回调函数中的this会指向全局变量中的Window变量，显然不是我们想要的结果。</p>
<p>组件的<code>style</code>属性的设置方式也值得注意：</p>
<pre><code class="javascript">style={{opacity: this.state.opacity}}
</code></pre>
<p>这是因为 <a href="https://facebook.github.io/react/tips/inline-styles.html" target="_blank" rel="external">React 组件样式</a>是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>
<h3 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h3><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 <code>componentDidMount</code> 方法设置 Ajax 请求，等到请求成功，再用 <code>this.setState</code> 方法重新渲染 UI</p>
<p>甚至可以把一个Promise对象传入组件</p>
]]></content>
      
        <categories>
            
            <category> 框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> React </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS]]></title>
      <url>/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/CSS/CSS/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>整理CSS知识点。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="流动布局"><a href="#流动布局" class="headerlink" title="流动布局"></a>流动布局</h3><p>需了解实现块居中常见的几种方式</p>
<h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><ul>
<li>仍处于标准文档流中。</li>
<li>没设置宽度值，设置了浮动属性，元素的宽度随内容的变化而变化。</li>
<li>设置为浮动属性，会对紧邻之后的元素造成影响，紧邻之后的元素会紧挨着该元素显示。</li>
<li>当父元素包含块缩成一条时，用clear:both方法无效，它一般用于紧邻后面的元素的清除浮动，要用overflow属性。</li>
<li>清除浮动的方法有两种:<ul>
<li>使用clear属性 - clear: both; 这种方法需要在浮动元素后面添加一个空的节点。兼容IE6需要添加zoom:1;</li>
<li>同时设置width:100%(或固定宽度) + overflow:hidden。浮动元素得有一个父元素。</li>
<li>使用after伪类，这种方式公认最好</li>
</ul>
</li>
<li>浮动布局可实现横向多列布局；文字环绕效果。</li>
</ul>
<h3 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>static是默认值</li>
<li>它表示块保留在原本应该在的位置，不会重新定位</li>
</ul>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><ul>
<li>相对于自身原有位置进行偏移</li>
<li>仍处于标准文档流中</li>
<li>随即拥有偏移属性和z-index属性</li>
</ul>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><ul>
<li>一个固定定位（position属性的值为fixed）元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。</li>
<li>一个固定定位元素不会保留它原本在页面应有的空隙。</li>
</ul>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><ul>
<li>相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 并且它会随着页面滚动而移动。</li>
<li>完全脱离了标准文档流。</li>
<li>随即拥有偏移属性和z-index属性。</li>
</ul>
<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p>Flexbox又叫弹性盒模型。它可以简单使用一个元素居中（包括水平垂直居中），可以让扩大和收缩元素来填充容器的可利用空间，可以改变源码顺序独立布局，以及还有其他的一些功能。合理使用它能够大大减少布局方面的工作。此外在移动端使用flex也比较常见。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>display:flex;</li>
<li>justify-content (水平对齐方式)</li>
<li>align-items (垂直对齐方式)</li>
</ul>
<p>使用请参考:</p>
<ul>
<li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">CSS flex完全指南</a></li>
<li><a href="http://gold.xitu.io/entry/57675f8f80dda4005f9bbe0c" target="_blank" rel="external">flex历险记</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></li>
<li><a href="http://www.cnblogs.com/lixuemin/p/6110434.html" target="_blank" rel="external">3分钟看懂flex布局</a></li>
</ul>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局是指，网页可以自动识别设备屏幕宽度，根据不同的宽度采用不同的CSS的样式，从而达到兼容各种设备的效果。</p>
<p>响应式布局使用媒体查询(CSS3 Media Queries), 根据不同屏幕分辨率采用不同CSS规则, 使用方式如下:</p>
<pre><code class="css">@media screen and (max-width:1024px) {
  /* 视窗宽度小于1024px时 */
  ....
}
</code></pre>
<h4 id="Bootstrap-grid系统的实现"><a href="#Bootstrap-grid系统的实现" class="headerlink" title="Bootstrap grid系统的实现"></a>Bootstrap grid系统的实现</h4><p>它提供了一套响应式，移动优先的流式栅格系统(grid system)，将屏幕分成12列来实现响应式的。它的实现原理非常简单，Media Query加上float布局，如果想了解实现细节，请参考我另外一篇博客<a href="https://segmentfault.com/a/1190000005771076" target="_blank" rel="external">Boostrap网格系统</a>。</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>每一个盒子有四条边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。</p>
<p><strong>IE盒模型和W3C盒模型区别</strong>：</p>
<ul>
<li>在W3C模型中: 总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</li>
<li>在IE模型中: 总宽度 = margin-left + width + margin-right</li>
</ul>
<p>在CSS3中引入了<strong>box-sizing属性</strong>, 它可以允许改变默认的CSS盒模型对元素宽高的计算方式.共包括两个选项：</p>
<ul>
<li><strong>content-box：标准盒模型，CSS定义的宽高只包含content的宽高</strong></li>
<li><strong>border-box：IE盒模型，CSS定义的宽高包括了content，padding和border</strong></li>
</ul>
<h2 id="定位机制"><a href="#定位机制" class="headerlink" title="定位机制"></a>定位机制</h2><p>css有三种基本定位机制: 标准文档流, 浮动和绝对定位。</p>
<h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><ul>
<li>从左到右，从上向下，输出文档内容</li>
<li>由块级元素和行级元素组成</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul>
<li>行内元素不能设置宽高，默认没高度和宽度，宽度由其内容决定。</li>
<li>行内元素虽然不能设置宽高，但是设置成绝对定位后，可以设置宽高。</li>
<li>行内元素：<code>a font(em strong i) img span</code></li>
</ul>
<h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><ul>
<li>块元素默认没高度，可以设置宽高，默认占据一行。</li>
<li><strong>一行只有一个块元素</strong></li>
<li><strong>空的块元素将在布局中消失</strong></li>
<li>块元素：<code>div p ul li table form html5(header section footer)</code></li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><ul>
<li>设置为浮动的元素将会往左(float:left)或者往右(float:right)漂移, 直到遇到阻挡 - 其他浮动元素或者父元素的边框。浮动元素不在标准文档流中占据空间,但会对其后的浮动元素造成影响。</li>
</ul>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul>
<li>设置为绝对定位的元素(posistion:absolute)将从标准文档流中删除，其所占据的标准流空间也不存在。然后通过top,left,right,bottom属性对其相对父元素进行定位。</li>
</ul>
<h2 id="选择器优先级及使用"><a href="#选择器优先级及使用" class="headerlink" title="选择器优先级及使用"></a>选择器优先级及使用</h2><h3 id="css选择器分类"><a href="#css选择器分类" class="headerlink" title="css选择器分类　"></a>css选择器分类　</h3><ol>
<li>标签选择器(如：body,div,p,ul,li)</li>
<li>类选择器(如：class=”head”,class=”head_logo”)</li>
<li>ID选择器(如：id=”name”,id=”name_txt”)</li>
<li>全局选择器(如：*号)</li>
<li>组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</li>
<li>后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</li>
<li>群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</li>
<li>继承选择器(如：div p,注意两选择器用空格键分开)</li>
<li>伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</li>
<li>字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</li>
<li>子选择器 (如：div&gt;p ,带大于号&gt;)</li>
<li>CSS 相邻兄弟选择器器 (如：h1+p,带加号+)</li>
</ol>
<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><h4 id="不同级别"><a href="#不同级别" class="headerlink" title="不同级别"></a>不同级别</h4><ol>
<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>
<li>作为style属性写在元素内的样式</li>
<li>id选择器</li>
<li>类选择器</li>
<li>标签选择器</li>
<li>通配符选择器</li>
<li>浏览器自定义或继承</li>
</ol>
<p>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<h4 id="同一级别"><a href="#同一级别" class="headerlink" title="同一级别"></a>同一级别</h4><p>同一级别中后写的会覆盖先写的样式</p>
<h4 id="多个级别"><a href="#多个级别" class="headerlink" title="多个级别"></a>多个级别</h4><p>计算方法（权值实际并不是按十进制，用数字表示只是说明思想，一万个class也不如一个id权值高）</p>
<ul>
<li>内联样式表的权值为 1000</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ul>
<p>css选择器使用强烈建议采用低权重原则，利于充分发挥css的继承性，复用性，模块化、组件化。</p>
<h3 id="CSS选择器的解析原则"><a href="#CSS选择器的解析原则" class="headerlink" title="CSS选择器的解析原则"></a>CSS选择器的解析原则</h3><p>郑重的声明选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。<a href="http://blog.csdn.net/jinboker/article/details/52126021" target="_blank" rel="external">为什么CSS选择器是从右往左解析 ？？？</a></p>
<p>简要概括：</p>
<ul>
<li>遍历节点树小很多</li>
<li>匹配的是dom元素的父节点，避免HTML、CSS没下载完需要等待</li>
</ul>
<h2 id="CSS3新特性及应用"><a href="#CSS3新特性及应用" class="headerlink" title="CSS3新特性及应用"></a>CSS3新特性及应用</h2><h3 id="新的元素选择器"><a href="#新的元素选择器" class="headerlink" title="新的元素选择器"></a>新的元素选择器</h3><p>E:nth-last-child(n), E:nth-of-type(n), E:nth-last-of-type(n), E:last-child, E:first-of-type, E:only-child, E:only-of-type, E:empty, E:checked, E:enabled, E:disabled, E::selection, E:not(s)</p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><p>confont是指使用字体文件取代图片文件，来展示图标和一些特殊字体等元素。它使用CSS3中的@font-face属性，它允许加载自定义字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。</p>
<p>它有很多优势: 首先它的体积要比图片小得多; 特定的属性(颜色,大小,透明)等修改起来就像是操作字体一样简单;iconfont具有矢量性, 放大缩小不会失真;</p>
<h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p>又称圆角属性，通常使用该属性将图片圆角化，如头像。</p>
<pre><code class="css">border-radius: 50%;
</code></pre>
<p>border-radius另外一个常用的手段是CSS动画。</p>
<h3 id="word-wrap-amp-text-overflow"><a href="#word-wrap-amp-text-overflow" class="headerlink" title="word-wrap &amp; text-overflow"></a>word-wrap &amp; text-overflow</h3><p>word-wrap属性用来指出浏览器在单词内进行断句，防止字符串太长而找不到它的自然断句点时产生的溢出。</p>
<pre><code class="css">word-wrap: break-word;
</code></pre>
<p>text-overflow用于文本溢出:</p>
<pre><code class="css">text-overflow: ellipsis; //对溢出部分加上...
</code></pre>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>主要是以下三个属性:</p>
<ul>
<li>background-clip 规定背景的绘制区域, 取值为border-box | padding-box | content-box | no-clip</li>
<li>background-origin 规定背景的定位区域, 取值为border | padding | content</li>
<li>background-size 规定背景图片的尺寸, 取值为[<length> | <percentage> | auto]{1,2} | cotain</percentage></length></li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="通用浏览器"><a href="#通用浏览器" class="headerlink" title="通用浏览器"></a>通用浏览器</h3><h4 id="不同浏览器的标签默认的外补丁和内补丁不同"><a href="#不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="不同浏览器的标签默认的外补丁和内补丁不同"></a>不同浏览器的标签默认的外补丁和内补丁不同</h4><p><strong>问题症状</strong>：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>
<p><strong>解决方案</strong>：CSS里加 <em>{margin:0;padding:0;},<em>*但不推荐，而且它也并不完善。</em></em></p>
<p>淘宝的样式初始化：</p>
<pre><code class="css">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
    body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
    h1, h2, h3, h4, h5, h6{ font-size:100%; }
    address, cite, dfn, em, var { font-style:normal; }
    code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
    small{ font-size:12px; }
    ul, ol { list-style:none; }
    a { text-decoration:none; }
    a:hover { text-decoration:underline; }
    sup { vertical-align:text-top; }
    sub{ vertical-align:text-bottom; }
    legend { color:#000; }
    fieldset, img { border:0; }
    button, input, select, textarea { font-size:100%; }
    table { border-collapse:collapse; border-spacing:0; }
</code></pre>
<h4 id="上下margin重合问题"><a href="#上下margin重合问题" class="headerlink" title="上下margin重合问题"></a>上下margin重合问题</h4><p><strong>问题症状</strong>：相邻的两个div margin-left margin-right 不会重合，但相邻的margin-top margin-bottom会重合。有两种情况：</p>
<ol>
<li>兄弟级的块之间，margin这个属性上下边距，经常会发生重叠的情况，以数值大的为准，而不会相加。</li>
<li>父子级的块之间，子级的上下margin会与父级上下margin重叠，以数值大的为准，而不会相加。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>第一种情况：</p>
<ol>
<li>float浮动</li>
<li>inline-block</li>
</ol>
<p>第二种情况：</p>
<ol>
<li>父级加overflow:hidden</li>
</ol>
<ol>
<li>父级加加padding </li>
<li>父级加加border </li>
<li>子级加position:absolute</li>
</ol>
<h4 id="img默认有间距"><a href="#img默认有间距" class="headerlink" title="img默认有间距"></a>img默认有间距</h4><p><strong>问题症状</strong>：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p>
<p><strong>解决方案</strong>：使用float属性为img布局</p>
<p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。</p>
<h4 id="标签最低高度设置min-height不兼容"><a href="#标签最低高度设置min-height不兼容" class="headerlink" title="标签最低高度设置min-height不兼容"></a>标签最低高度设置min-height不兼容</h4><p><strong>问题症状</strong>：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p>
<p><strong>解决方案</strong>：如果我们要设置一个标签的最小高度200px，需要进行的设置为：</p>
<pre><code class="css">.box{min-height:200px; height:auto !important; height:200px; overflow:visible;}
</code></pre>
<p>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p>
<h4 id="超链接访问过后样式就混乱了，hover样式不出现"><a href="#超链接访问过后样式就混乱了，hover样式不出现" class="headerlink" title="超链接访问过后样式就混乱了，hover样式不出现"></a>超链接访问过后样式就混乱了，hover样式不出现</h4><p><strong>问题症状</strong>：主要是其CSS属性的排序问题。</p>
<p><strong>解决方案</strong>：一般来说，最好按照这个顺序：L-V-H-A</p>
<pre><code class="css">a:link{}  a:visited{}  a:hover{}  a:active{}
</code></pre>
<h4 id="chrome默认会将小于12px的文本强制按照12px来解析"><a href="#chrome默认会将小于12px的文本强制按照12px来解析" class="headerlink" title="chrome默认会将小于12px的文本强制按照12px来解析"></a>chrome默认会将小于12px的文本强制按照12px来解析</h4><p><strong>解决方案</strong>：给其添加属性：</p>
<pre><code class="css">-webkit-text-size-adjust: none;
</code></pre>
<h4 id="鼠标的手势问题"><a href="#鼠标的手势问题" class="headerlink" title="鼠标的手势问题"></a>鼠标的手势问题</h4><p><strong>问题症状</strong>：FireFox的cursor属性不支持hand，但是支持pointer，IE两个都支持；</p>
<p><strong>解决方案</strong>：为了兼容都用pointer</p>
<h4 id="消除ul、ol等列表的缩进"><a href="#消除ul、ol等列表的缩进" class="headerlink" title="消除ul、ol等列表的缩进"></a>消除ul、ol等列表的缩进</h4><p><strong>解决方案</strong>：样式应写成:</p>
<pre><code class="css">list-style:none;margin:0px;padding:0px;
</code></pre>
<p>其中margin属性对IE有效，padding属性对FireFox有效</p>
<h4 id="透明度问题"><a href="#透明度问题" class="headerlink" title="透明度问题"></a>透明度问题</h4><p><strong>解决方案</strong>：</p>
<pre><code class="css">opacity: 0.6 ;     //一般 
filter: alpha(opacity=60)    //IE
filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60);        //IE6
</code></pre>
<h3 id="IE6常见BUG"><a href="#IE6常见BUG" class="headerlink" title="IE6常见BUG"></a>IE6常见BUG</h3><h4 id="IE6双倍边距bug-1"><a href="#IE6双倍边距bug-1" class="headerlink" title="IE6双倍边距bug(1)"></a>IE6双倍边距bug(1)</h4><p><strong>问题症状</strong>：块属性标签添加了浮动float之后，若在浮动方向上也有margin值，则margin值会加倍。其实这种问题主要就是会把某些元素挤到了第二行</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>给float元素添加display：inline</li>
<li>就是hack处理了，对IE6进行 _margin-left:5px;(原先为10px)</li>
</ul>
<h4 id="IE6双倍边距bug-2"><a href="#IE6双倍边距bug-2" class="headerlink" title="IE6双倍边距bug(2)"></a>IE6双倍边距bug(2)</h4><p><strong>问题症状</strong>：行内属性标签，为了设置宽高，我们经常就会设置成display：block; 后采用float布局，又有横行的margin的情况这样一来就产生上述的问题。</p>
<p><strong>解决方案</strong>：在display:block;后面加入display:inline;display:table;</p>
<h4 id="IE6中3像素问题"><a href="#IE6中3像素问题" class="headerlink" title="IE6中3像素问题"></a>IE6中3像素问题</h4><p><strong>问题症状</strong>：当元素使用float浮动后，元素与相邻的元素之间会产生3px的间隙。诡异的是如果右侧的容器没设置高度时3px的间隙在相邻容器的内部，当设定高度后又跑到容器的相反侧了。</p>
<p><strong>解决方案</strong>：需要使布局在同一行的元素都加上float浮动。</p>
<h4 id="IE6中奇数宽高的BUG"><a href="#IE6中奇数宽高的BUG" class="headerlink" title="IE6中奇数宽高的BUG"></a>IE6中奇数宽高的BUG</h4><p><strong>问题症状</strong>：IE6中奇数的高宽显示大小与偶数高宽显示大小存在一定的不同。其中要问题是出在奇数高宽上。</p>
<p><strong>解决方案</strong>：需要尽量将外部定位的div高宽写成偶数即可。</p>
<h4 id="IE6和FF中图片链接的下方有间隙"><a href="#IE6和FF中图片链接的下方有间隙" class="headerlink" title="IE6和FF中图片链接的下方有间隙"></a>IE6和FF中图片链接的下方有间隙</h4><p><strong>问题症状</strong>：IE6中图片的下方会存在一定的间隙，尤其在图片垂直挨着图片的时候，即可看到这样的间隙。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>需要将img标签定义为display:block </li>
<li>定义vertical-align对应的属性。</li>
<li>为img对应的样式写入font-size:0</li>
</ol>
<h4 id="IE6下空元素的高度BUG"><a href="#IE6下空元素的高度BUG" class="headerlink" title="IE6下空元素的高度BUG"></a>IE6下空元素的高度BUG</h4><p><strong>问题症状</strong>：如果一个元素中没有任何内容，当在样式中为这个元素设置了0-19px之间的高度时。此元素的高度始终为19px。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>在元素的css中加入：overflow:hidden</li>
<li>在元素中插入html注释：&lt;!– &gt;</li>
<li>在元素中插入html的空白符：&nbsp;</li>
<li>在元素的css中加入：font-size:0</li>
</ol>
<h4 id="重复文字的BUG"><a href="#重复文字的BUG" class="headerlink" title="重复文字的BUG"></a>重复文字的BUG</h4><p><strong>问题症状</strong>：在某些比较复杂的排版中，有时候浮动元素的最后一些字符会出现在clear清除元素的下面。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>确保元素都带有display:inline</li>
<li>在最后一个元素上使用“margin-right:-3px</li>
<li>为浮动元素的最后一个条目加上条件注释，&lt;!–[if !IE]&gt;xxx&lt;![endif]–&gt;</li>
<li>在容器的最后元素使用一个空白的div，为这个div指定不超过容器的宽度。</li>
</ol>
<h4 id="IE6中-z-index失效"><a href="#IE6中-z-index失效" class="headerlink" title="IE6中 z-index失效"></a>IE6中 z-index失效</h4><p><strong>问题症状</strong>：具体BUG为，元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的BUG</p>
<p>原因：z-index起作用有个小小前提，就是元素的position属性要 是relative，absolute或是fixed。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>position:relative改为position:absolute；</li>
<li>去除浮动；</li>
<li>浮动元素添加position属性（如relative，absolute等）。</li>
</ol>
<p><strong>IE6结语：实际上中，很多BUG的解决方法都可以使用display:inline、font-size:0、float解决。因此我们在书写代码时要记住，一旦使用了float浮动，就为元素增加一个display:inline样式，可以有效的避免浮动造成的样式错乱问题。使用空DIV时，为了避免其高度影响布局美观，也可以为其加上font-size:0 这样就很容易避免一些兼容上的问题。</strong></p>
<h4 id="png24位的图片在IE6下面会出现背景"><a href="#png24位的图片在IE6下面会出现背景" class="headerlink" title="png24位的图片在IE6下面会出现背景"></a>png24位的图片在IE6下面会出现背景</h4><p><strong>解决方案</strong>：使用png8格式的</p>
<h4 id="IE6下在使用margin-0-auto-无法使其居中"><a href="#IE6下在使用margin-0-auto-无法使其居中" class="headerlink" title="IE6下在使用margin:0 auto;无法使其居中"></a>IE6下在使用margin:0 auto;无法使其居中</h4><p><strong>解决方案</strong>：为其父容器设置<code>text-align:center;</code></p>
<h4 id="IE6-7标签高度无法小于10px"><a href="#IE6-7标签高度无法小于10px" class="headerlink" title="IE6/7标签高度无法小于10px"></a>IE6/7标签高度无法小于10px</h4><p><strong>问题症状</strong>：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>给超出高度的标签设置overflow:hidden;</li>
<li>或者设置行高line-height 小于你设置的高度</li>
<li>或设置fontsize大小为高度大小</li>
</ul>
<p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>
<h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>我们为了让页面形成统一的效果，要针对不同的浏览器或不同版本写出对应可解析的CSS样式，所以我们就把这个针对不同浏览器/版本而写CSS的过程叫做 CSS hack.</p>
<p>CSS hack主要有三种：IE条件注释法、CSS属性前缀法、选择器前缀法。</p>
<h3 id="IE条件注释法"><a href="#IE条件注释法" class="headerlink" title="IE条件注释法"></a>IE条件注释法</h3><p>在正常代码之外添加判别IE浏览器或对应版本的条件注释，符合条件的浏览器或者版本号才回执行里边的代码。</p>
<pre><code class="html">&lt;!-- [if IE]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;

&lt;!-- [if lt IE 8]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;

&lt;!-- [if ! IE 8]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;
</code></pre>
<h3 id="CSS属性前缀法"><a href="#CSS属性前缀法" class="headerlink" title="CSS属性前缀法"></a>CSS属性前缀法</h3><p>给css的属性添加前缀。比如 * 可以被IE6/IE7识别，但 <em> 只能被IE6识别，IE6-IE10都可以识别 “\9”，IE6不能识别!important ,FireFox不能识别 * </em>  \9</p>
<pre><code class="css">//可以先使用“\9&quot;标记，将IE分离出来，再用”*&quot;分离出IE6/IE7，最后可以用“_”分离出IE6
.type{
        color: #111; /* all */
        color: #222\9; /* IE */
        *color: #333; /* IE6/IE7 */
        _color: #444; /* IE6 */
        }

//所以可以按着优先级就能给特定的版本捎上特定颜色
</code></pre>
<p>说明：在标准模式中</p>
<ul>
<li>“-″减号是IE6专有的hack</li>
<li>“\9″ IE6/IE7/IE8/IE9/IE10都生效</li>
<li>“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>
<li>“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</li>
</ul>
<h3 id="选择器前缀法"><a href="#选择器前缀法" class="headerlink" title="选择器前缀法"></a>选择器前缀法</h3><pre><code class="css">*div{color:red;}              //IE6可识别 
*+div{color:red;}            //IE7可识别 
@media screen\9{...}        //只对IE6/7生效
@media \0screen {body { background: red; }}                //只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}    //只对IE6/7/8有效
@media screen\0 {body { background: green; }}             //只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }}     //只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }}         //只对IE10有效 等等
</code></pre>
<h2 id="移动端适应"><a href="#移动端适应" class="headerlink" title="移动端适应"></a>移动端适应</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="谈谈兼容性的问题"><a href="#谈谈兼容性的问题" class="headerlink" title="谈谈兼容性的问题"></a>谈谈兼容性的问题</h3><p>自己遇到的最严重的兼容性case，需求是什么，一开始怎么做的，怎么发现有问题，怎么找到问题的原因，有哪些解决方案，最后选了哪一种，为什么选这种方式，这个过程里学到了什么，再做一次类似case会有什么改变，将来怎么避免等等。</p>
<h2 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h2><h3 id="CSS中使用列布局是什么？"><a href="#CSS中使用列布局是什么？" class="headerlink" title="CSS中使用列布局是什么？"></a>CSS中使用列布局是什么？</h3><pre><code class="css">&lt;style&gt;
//我们需要把text划分为多少列
.magazine
{
  -moz-column-count:3; /* Firefox */
  -webkit-column-count:3; /* Safari and Chrome */
  column-count:3;

  //两列之间我们想要多少差距
  -moz-column-gap:40px; /* Firefox */
  -webkit-column-gap:40px; /* Safari and Chrome */
  column-gap:20px;

  //你想在这些列之间画一条线么？如果是，那么多厚呢？
  -moz-column-rule:4px outset #ff00ff; /* Firefox */
  -webkit-column-rule:4px outset #ff00ff; /* Safari and Chrome */
  column-rule:6px outset #ff00ff;
}
&lt;/style&gt;
</code></pre>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix:after {
  content:&quot;.&quot;; 
  display:block; 
  height:0; 
  visibility:hidden; 
  clear:both; }
.clearfix { *zoom:1; }
</code></pre>
<h2 id="垂直水平居中实现"><a href="#垂直水平居中实现" class="headerlink" title="垂直水平居中实现"></a>垂直水平居中实现</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="行内或类行内元素"><a href="#行内或类行内元素" class="headerlink" title="行内或类行内元素"></a>行内或类行内元素</h4><p>在块级父容器中让行内元素居中，只需使用 <code>text-align: center;</code></p>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>设置 <code>margin-left</code> 和 <code>margin-right</code> 为 <code>auto</code>（前提是已经为元素设置了适当的 <code>width</code> 宽度，否则块级元素的宽度会被拉伸为父级容器的宽度）</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a><code>float</code></h4><p>float 属性是不能简单实现元素居中。</p>
<p>可以使用伪元素充当占位符</p>
<h4 id="多个块级元素"><a href="#多个块级元素" class="headerlink" title="多个块级元素"></a>多个块级元素</h4><p>修改<code>display</code> 值。使用了 <code>inline-block</code> 的显示方式，另一个使用了 <code>flexbox</code> 的显示方式</p>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="行内或类行内元素-1"><a href="#行内或类行内元素-1" class="headerlink" title="行内或类行内元素"></a>行内或类行内元素</h4><ul>
<li>等值的 <code>padding-top</code> 和 <code>padding-bottom</code></li>
<li><code>line-height</code> 和 <code>center</code> 相等</li>
</ul>
<h4 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h4><ul>
<li>等值的 <code>padding-top</code> 和 <code>padding-bottom</code></li>
<li><code>table-cell</code> 的父级容器，然后使用 <a href="http://www.w3cplus.com/css/what-is-vertical-align.html" target="_blank" rel="external"><code>vertical-align</code></a> 属性</li>
<li><code>flexbox</code> 实现垂直居中，对于父级容器为 <code>display: flex</code> 的元素来说，它的每一个子元素都是垂直居中</li>
<li>幽灵元素，在垂直居中的元素上添加伪元素，设置伪元素的高等于父级容器的高，然后为文本添加 <code>vertical-align: middle;</code> 样式</li>
</ul>
<h4 id="块级元素-1"><a href="#块级元素-1" class="headerlink" title="块级元素"></a>块级元素</h4><h5 id="已知元素的高度"><a href="#已知元素的高度" class="headerlink" title="已知元素的高度"></a>已知元素的高度</h5><pre><code class="css">position: absolute;
top: 50%;
height: 100px;
margin-top: -50px;
</code></pre>
<h5 id="未知元素的高度"><a href="#未知元素的高度" class="headerlink" title="未知元素的高度"></a>未知元素的高度</h5><p>需要先将元素定位到容器的中心位置，然后使用 <code>transform</code> 的 <code>translate</code> 属性，将元素的中心和父容器的中心重合，从而实现垂直居中</p>
<pre><code class="css">position: absolute; 
top: 50%; 
transform: translateY(-50%);
</code></pre>
<h4 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h4><pre><code class="css">display: flex; 
flex-direction: column; 
justify-content: center;
</code></pre>
<h3 id="水平且垂直居中"><a href="#水平且垂直居中" class="headerlink" title="水平且垂直居中"></a>水平且垂直居中</h3><h4 id="宽高固定元素"><a href="#宽高固定元素" class="headerlink" title="宽高固定元素"></a>宽高固定元素</h4><p>设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%，最后使用负向 margin 实现水平和垂直居中，margin 的值为宽高（具体的宽高需要根据实际情况计算 padding）的一半。</p>
<pre><code class="css">width: 300px; 
height: 100px;
padding: 20px; 
position: absolute; 
top: 50%; 
left: 50%; 
margin: -70px 0 0 -170px;
</code></pre>
<h4 id="宽高不固定元素"><a href="#宽高不固定元素" class="headerlink" title="宽高不固定元素"></a>宽高不固定元素</h4><p>设定父级容器为相对定位的容器，设定子元素绝对定位的位置 <code>position: absolute; top: 50%; left: 50%</code>。不同的是，接下来需要使用 <code>transform: translate(-50%, -50%);</code> 实现垂直居中</p>
<pre><code class="css">position: absolute; 
top: 50%; 
left: 50%; 
transform: translate(-50%, -50%);
</code></pre>
<p>使用 <code>transform</code> 有一个缺陷，就是当计算结果含有小数时（比如 <code>0.5</code>），会让整个元素看起来是模糊的，一种解决方案就是为父级元素设置 <code>transform-style: preserve-3d;</code> 样式</p>
<h4 id="flexbox-1"><a href="#flexbox-1" class="headerlink" title="flexbox"></a>flexbox</h4><pre><code class="css">display: flex; 
justify-content: center; 
align-items: center;
</code></pre>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="CSS3中的文本效果"><a href="#CSS3中的文本效果" class="headerlink" title="CSS3中的文本效果"></a>CSS3中的文本效果</h3><p>阴影文本效果</p>
<pre><code class="css">.specialtext
{
    text-shadow: 5px 5px 5px #FF0000;
}
</code></pre>
<p>文字包装效果：允许长单词换行到下一行</p>
<pre><code class="css">&lt;style&gt;
.breakword
    {word-wrap:break-word;}
&lt;/style&gt;
</code></pre>
<h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><pre><code class="css">div
{
  animation:mymove 5s infinite;
  -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */
}
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000006890725" target="_blank" rel="external">前端面试之CSS总结(上)</a></li>
<li><a href="http://www.cnblogs.com/bergwhite/p/6417800.html" target="_blank" rel="external">前端总结·基础篇·CSS（一）布局</a></li>
<li><a href="http://blog.csdn.net/icesschen/article/details/52443364" target="_blank" rel="external">关于margin上下重叠的问题</a></li>
<li><a href="http://www.cnblogs.com/guhui1994/p/5906268.html" target="_blank" rel="external">CSS常见兼容性问题总结</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer]]></title>
      <url>/2017/01/02/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>剑指offer一刷留念</p>
<a id="more"></a>
<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><blockquote>
<p>A：完全不理解写不出，B：思想理解写不出，C：思想不理解提示能写出</p>
</blockquote>
<h2 id="一刷"><a href="#一刷" class="headerlink" title="一刷"></a>一刷</h2><h3 id="1-二维数组中的查找-C"><a href="#1-二维数组中的查找-C" class="headerlink" title="1. 二维数组中的查找(C)"></a>1. 二维数组中的查找(C)</h3><blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>思路：因为矩阵的特殊性，所以先从<strong>第一列最后一行</strong>开始比较，小于则向上查找，大于则向后查找</p>
<h3 id="2-替换空格-B"><a href="#2-替换空格-B" class="headerlink" title="2.替换空格(B)"></a>2.替换空格(B)</h3><blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>思路：使用正则表达式，<strong>\s+代表多个空格，？则表示取尽可能少的空格</strong>，然后通过replace函数替换为%20</p>
<pre><code class="javascript">return str.replace(/\s+?/g,&#39;%20&#39;)
</code></pre>
<h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>
<p>思路1：先将链表每个结点的值存入数组中，然后通过数组的<strong>reverse</strong>方法，即可从尾到头打印</p>
<p>我的思路：直接用<strong>unshift</strong></p>
<pre><code class="javascript">res.unshift(head.val);
</code></pre>
<h3 id="4-重建二叉树-B"><a href="#4-重建二叉树-B" class="headerlink" title="4.重建二叉树(B)"></a>4.重建二叉树(B)</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p>思路：二叉树前序遍历第一个点为根节点，中序遍历顺序为先左子树然后根节点最后右子树。所以<strong>先通过前序遍历找出根节点，然后将中序遍历分为左右子树两组，最后对于每个子树依次递归调用。</strong></p>
<pre><code class="javascript">function reConstructBinaryTree(pre, vin)
{
    // write code here
    if(pre.length==0 || vin.length==0) return null;
    var index=vin.indexOf(pre[0]);
    var left=vin.slice(0,index);//中序左子树
    var right=vin.slice(index+1);//中序右子树
    return {
        val:pre[0],
        //递归左右子树的前序，中序 
        left:reConstructBinaryTree(pre.slice(1,index+1),left),
        right:reConstructBinaryTree(pre.slice(index+1),right)
     }; 
}
</code></pre>
<h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h3><blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</p>
</blockquote>
<p>思路：push + shift</p>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>Math.min</li>
<li>排序:直接将数组按从小到大排序，返回第一个元素即可。</li>
<li>二分法:mid = Math.floor((left+right)/2),直到左右差1个元素</li>
</ol>
<pre><code class="javascript">return Math.min.apply(Math,rotateArray);
</code></pre>
<h3 id="7-斐波那契数列-C"><a href="#7-斐波那契数列-C" class="headerlink" title="7.斐波那契数列(C)"></a>7.斐波那契数列(C)</h3><blockquote>
<p>输入一个整数n，请你输出斐波那契数列的第n项。</p>
</blockquote>
<p>思路：F(n) = F(n-2)+F(n-1)</p>
<ol>
<li>递归版本：不好</li>
<li><strong>动态规划版本</strong></li>
</ol>
<pre><code class="javascript">//2.动态规划版本：
for(var i=2;i&lt;=n;i++)
{
  temp = f1 + f2;
  f1=f2;
  f2 = temp;
}
</code></pre>
<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>思路：和7题本质一样</p>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>思路：<strong>F(n) = 2* F(n-1)</strong></p>
<pre><code class="javascript">return 2 * jumpFloorII(number - 1)
</code></pre>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><blockquote>
<p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<p>思路：依旧是斐波那契数列</p>
<h3 id="11-二进制中1的个数-C"><a href="#11-二进制中1的个数-C" class="headerlink" title="11.二进制中1的个数(C)"></a>11.二进制中1的个数(C)</h3><blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>思路:</p>
<ol>
<li><strong>把一个整数减去1，再和原来的整数做与运算</strong>，会把该整数最右边的一个1变为0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</li>
<li>如果是负数，对其进行位操作,然后<strong>toString</strong></li>
</ol>
<pre><code class="javascript">//思路1:n=n&amp;(n-1);
//思路2: n = n&gt;&gt;&gt;0;;n.toString(2);
</code></pre>
<h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h3><blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<p>思路:</p>
<ol>
<li>先判断浮点数的正负情况，然后通过累乘的方式, 注意exponent正负</li>
<li><code>return base**exponent;</code></li>
</ol>
<h3 id="13-调整数组顺序"><a href="#13-调整数组顺序" class="headerlink" title="13.调整数组顺序"></a>13.调整数组顺序</h3><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>思路: 通过map函数</p>
<pre><code class="javascript">array.map(a =&gt; (a%2!=0?arr1.push(a):arr2.push(a)));
</code></pre>
<h3 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h3><blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>思路: <strong>通过prev和tail来获取距离为k的一段</strong>，然后就tail指向链表最后，</p>
<h3 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h3><blockquote>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p>思路：<strong>三个指针</strong>。通过prev固定反转后链表头，通过head来反转，通过next指向剩下的链表头部</p>
<h3 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h3><blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<p>思路：两个指针分别指向链表元素，然后比较两个元素大小，小的则连到合成后链表，直到达到一个链表的末尾。然后如果哪一个链表还有元素，直接连到合成后链表后面即可。</p>
<h3 id="17-树的子结构-C"><a href="#17-树的子结构-C" class="headerlink" title="17.树的子结构(C)"></a>17.树的子结构(C)</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>思路：比较B是不是A的子树，B是不是A的右子树的子树，B是不是A的左子树的子树。如果根元素相同，则开始判断左子树和右子树</p>
<pre><code class="javascript">function isSubtree(pRoot1,pRoot2){
    if (pRoot2 == null) return true;//pRoot2为null，表示子树已经遍历完
    if (pRoot1 == null) return false;
    if(pRoot1.val==pRoot2.val){
        return isSubtree(pRoot1.left,pRoot2.left) &amp;&amp; isSubtree(pRoot1.right,pRoot2.right);
    }else{
        return false;
    }
}

function HasSubtree(pRoot1, pRoot2)
{
    if(pRoot1==null||pRoot2==null) return false;   
    return isSubtree(pRoot1,pRoot2)||HasSubtree(pRoot1.left,pRoot2)||HasSubtree(pRoot1.right,pRoot2);
}
</code></pre>
<h3 id="18-二叉树镜像"><a href="#18-二叉树镜像" class="headerlink" title="18.二叉树镜像"></a>18.二叉树镜像</h3><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像</p>
</blockquote>
<p>思路：先将根的<strong>左右节点互换，然后就是递归调用</strong>，对左右子树进行分别处理</p>
<h3 id="19-顺时针打印矩阵-B"><a href="#19-顺时针打印矩阵-B" class="headerlink" title="19.顺时针打印矩阵(B)"></a>19.顺时针打印矩阵(B)</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<p>思路：</p>
<ol>
<li>选坐标为(0,0),(1,1)…的点记为(start,start)，作为开始坐标,下一圈开始坐标为(start+1,start+1)；</li>
<li>关键：<strong>判断是否进入下一圈(即是否打印完成)的条件</strong>是<code>rows&gt;start*2 &amp;&amp; cols&gt;start*2</code>；</li>
<li>打印一圈的左上角坐标为(start,start)，右下角的坐标为(cols-start-1,rows-start-1)</li>
<li>根据一圈左上角和右下角坐标判断“从左到右”，“从上到下”，“从右到左”，“从下到上”需要打印的点。</li>
</ol>
<h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h3><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
</blockquote>
<p>思路：通过数组来实现栈的功能</p>
<pre><code class="javascript"> result.map(val=&gt;((min&gt;val)?min=val:null));
</code></pre>
<h3 id="21-栈的压入、弹出-C"><a href="#21-栈的压入、弹出-C" class="headerlink" title="21.栈的压入、弹出(C)"></a>21.栈的压入、弹出(C)</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列<code>1,2,3,4,5</code>是某栈的压入顺序，序列<code>4,5,3,2,1</code>是该压栈序列对应的一个弹出序列，但<code>4,3,5,1,2</code>就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>思路：设置辅助栈，压入元素，<strong>判断栈顶元素是否等于出栈第一个，相同则出栈</strong>，不同则继续入栈</p>
<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>思路：采用<strong>队列</strong>方法，先将<strong>根节点放入队列</strong>中，然后打印，接着<strong>将左右节点加入队列</strong>中。</p>
<pre><code class="javascript">while (queue.length) {
  var temp = queue.shift();
  result.push(temp.val);
  if (temp.left) {
    queue.push(temp.left);
  }
  if (temp.right) {
    queue.push(temp.right);
  }
}
</code></pre>
<h3 id="23-二叉搜索树的后序遍历-A"><a href="#23-二叉搜索树的后序遍历-A" class="headerlink" title="23.二叉搜索树的后序遍历(A)"></a>23.二叉搜索树的后序遍历(A)</h3><blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>思路：后序遍历最后一个元素为根节点，所以先遍历，将数组分为小于根节点部分和大于根节点部分，然后比较这两个部分是否符合与根节点的大小关系。</p>
<pre><code class="javascript">function VerifySquenceOfBST(sequence)
{
    // write code here
    if(sequence.length&lt;=0) return;
    return test(sequence,0,sequence.length-1)
}
function test(sequence,start,end){
    if(start&gt;=end) return true;
    var i=end-1;
    while(i&gt;=start &amp;&amp; sequence[i]&gt;sequence[end]){
        i--;
    }
    for(var j=i;j&gt;=start;j--){
        if(sequence[j]&gt;sequence[end]){
            return false;
        }
    }
    return test(sequence,start,i)&amp;&amp;test(sequence,i+1,end-1)
}
</code></pre>
<h3 id="24-二叉树中和为某一值的路径-A"><a href="#24-二叉树中和为某一值的路径-A" class="headerlink" title="24.二叉树中和为某一值的路径(A)"></a>24.二叉树中和为某一值的路径(A)</h3><blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<p>思路：判断当前结点是否是叶子结点，以及curtSum是否等于expectNumber。如果是，把当前路径保存在res结果中；</p>
<pre><code class="javascript">function FindPath(root, expectNumber)
{
    var result=[];
    if(root==null) return result;
    dfs(root,0,[]);
    function dfs(root,current,path){
        current+=root.val;
        path.push(root.val)
        if(current==expectNumber &amp;&amp; root.left==null &amp;&amp; root.right ==null){
            result.push(path.slice(0))
        }
        if(root.left!=null){
            dfs(root.left,current,path)
        }
        if(root.right!=null){
            dfs(root.right,current,path)
        }
        path.pop()
    }
    return result;
}
</code></pre>
<h3 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h3><blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p>
</blockquote>
<p>思路：将复杂链表分为<strong>头结点和剩余结点</strong>两部分，剩余部分采用递归方法。</p>
<pre><code class="javascript">var node = new RandomListNode(pHead.label);
node.random = pHead.random;
node.next = Clone(pHead.next);
</code></pre>
<h3 id="26-二叉搜索树与双向链表-A"><a href="#26-二叉搜索树与双向链表-A" class="headerlink" title="26.二叉搜索树与双向链表(A)"></a>26.二叉搜索树与双向链表(A)</h3><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>将左子树构成双向链表，返回的是左子树的尾结点，将其连接到root的左边； </li>
<li>将右子树构成双向链表，将其追加到root结点之后，并返回尾结点；</li>
<li>向左遍历返回的链表至头结点处，即为所求双向链表的首结点。</li>
</ul>
<pre><code class="javascript">function Convert(pRootOfTree)
{
    // write code here
    if(pRootOfTree==null){
        return null;
    }
    var lastNode=null;
    lastNode=convertNode(pRootOfTree,lastNode);
    var head=lastNode;
    while(head &amp;&amp; head.left){//循环到头部
        head=head.left;
    }
    return head;
}
function convertNode(root,lastNode){
    if(root==null) return;
    if(root.left){//左子树
        lastNode=convertNode(root.left,lastNode)
    }
    root.left=lastNode;
    if(lastNode){
        lastNode.right=root;
    }
    lastNode=root;
    if(root.right){//右子树
        lastNode=convertNode(root.right,lastNode)
    }
    return lastNode;
}
</code></pre>
<h3 id="27-字符串排列（B）"><a href="#27-字符串排列（B）" class="headerlink" title="27.字符串排列（B）"></a>27.字符串排列（B）</h3><blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<p>思路：<strong>使用递归方法，n个元素的全排列 = （n-1） 个元素全排列 + 一个元素作为前缀。</strong>判断是否重复</p>
<pre><code class="javascript">function sortString(arr,sortTemp,result){...}
</code></pre>
<h3 id="28-数组中出现次数超过一半"><a href="#28-数组中出现次数超过一半" class="headerlink" title="28.数组中出现次数超过一半"></a>28.数组中出现次数超过一半</h3><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>思路：可以使用map数据结构</p>
<pre><code class="javascript">numbers.map(x=&gt;(countObj[x]?countObj[x]++:countObj[x]=1));
for(var i in countObj)
</code></pre>
<h3 id="29-最小的k个数"><a href="#29-最小的k个数" class="headerlink" title="29.最小的k个数"></a>29.最小的k个数</h3><blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<p>思路：先排序，然后slice()即可。</p>
<pre><code class="javascript">input.sort((a,b)=&gt;(a-b));
return input.slice(0,k);
</code></pre>
<h3 id="30-连续子数组的最大和-C"><a href="#30-连续子数组的最大和-C" class="headerlink" title="30.连续子数组的最大和(C)"></a>30.连续子数组的最大和(C)</h3><blockquote>
<p>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<p>思路：<strong>如果和为负数，则重新开始，如果和为正数，则继续加</strong>，然后比较大小，选出最大和即可。</p>
<pre><code class="javascript">var tempSum=0,sum=-Number.MAX_VALUE;
array.map(function(a){
    tempSum=(tempSum&lt;0)?a:tempSum+a;
    sum=(sum&lt;tempSum)?tempSum:sum;
})
</code></pre>
<h3 id="31-整数中1出现的次数-C"><a href="#31-整数中1出现的次数-C" class="headerlink" title="31.整数中1出现的次数(C)"></a>31.整数中1出现的次数(C)</h3><blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。求出任意非负整数区间中1出现的次数</p>
</blockquote>
<p>思路1：</p>
<ol>
<li>如果第i位上的数字为0，则第i位可能出现1的次数由其高位决定，若没有高位，则视为0，此时第i位可能出现1的次数为：<code>其高位数*10^(i-1)</code>，例如若c为0，则次数为ab*10^2;</li>
<li>如果第i位上的数字为1，则第i位上可能出现1的次数受其高位和低位影响，若没有，则视为0，此时第i位可能出现1的次数：<code>其高位数*10^(i-1)+（低位数+1）</code>，例如若c为1，则次数为ab*10^2+（de+1）;</li>
<li>如果第i位上的数字大于1，则第i位上可能出现1的次数受其高位影响，若没有，则视为0，此时第i位可能出现1的次数：<code>（其高位数+1）*10^(i-1)</code>，例如若c大于1，则次数为（ab+1）*10^2;</li>
</ol>
<p>思路2：暴力解决，一个数一个数判断</p>
<h3 id="32-把数组排成最小的数-B"><a href="#32-把数组排成最小的数-B" class="headerlink" title="32.把数组排成最小的数(B)"></a>32.把数组排成最小的数(B)</h3><blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<p>思路：排序规则如下：</p>
<ul>
<li>若ab &gt; ba 则 a &gt; b，</li>
<li>若ab &lt; ba 则 a &lt; b，</li>
<li>若ab = ba 则 a = b；</li>
</ul>
<pre><code class="javascript">numbers.sort(function(a,b){
        var s1 = a +&#39;&#39;+b;
        var s2 = b+&#39;&#39;+a;
        return parseInt(s1)-parseInt(s2);
    })
numbers.map(function(num){
        result = result.concat(num);
})
</code></pre>
<h3 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h3><blockquote>
<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<p>思路：下一个丑数是由数组中<strong>某个丑数A <em> 2，B </em> 3，C * 5中的最小值</strong>得来的。<strong>按序全部遍历</strong></p>
<pre><code class="javascript">uglys[i]=Math.min(uglys[factor2]*2,uglys[factor3]*3,uglys[factor5]*5)
if(uglys[i]==uglys[factor2]*2) factor2++;
...
</code></pre>
<h3 id="34-第一次只出现一次的字符"><a href="#34-第一次只出现一次的字符" class="headerlink" title="34.第一次只出现一次的字符"></a>34.第一次只出现一次的字符</h3><blockquote>
<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
</blockquote>
<p>思路：使用map结构，将每次出现字符和出现次数放入map中</p>
<pre><code class="javascript">strArr.map( s =&gt; (!count[s]?count[s]=1:count[s]++));
for(var i in count)
</code></pre>
<h3 id="35-数组中的逆序对-A"><a href="#35-数组中的逆序对-A" class="headerlink" title="35.数组中的逆序对(A)"></a>35.数组中的逆序对(A)</h3><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 ; 注意：时间有限制</p>
</blockquote>
<p>思路：利用<strong>归并排序</strong>思想，先求出每个组中逆序对数，然后合并、排序并统计，</p>
<h3 id="36-两个链表的第一个公共结点-A"><a href="#36-两个链表的第一个公共结点-A" class="headerlink" title="36.两个链表的第一个公共结点(A)"></a>36.两个链表的第一个公共结点(A)</h3><blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>思路：两个指针，遍历后比较结点的值</p>
<ul>
<li>长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL</li>
<li>长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。</li>
</ul>
<pre><code class="javascript">while(p1!=p2){
  p1=(p1==null?pHead2:p1.next)
  p2=(p2==null?pHead1:p2.next)
}
</code></pre>
<h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>思路:</p>
<ol>
<li>暴力解决方法，遍历</li>
<li>二分查找方法：先看中间元素与k相比，小于则在左半部分，大于则在右半部分，</li>
</ol>
<h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h3><blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>思路：递归求左子树和右子树深度，然后比较，最终返回最大值加1</p>
<h3 id="39-平衡二叉树-B"><a href="#39-平衡二叉树-B" class="headerlink" title="39.平衡二叉树(B)"></a>39.平衡二叉树(B)</h3><blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>思路：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。遍历左子树和右子树的深度，然后比较二者差值</p>
<h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>思路：将数组同去重后的数组进行比较，求出数组中元素出现的次数</p>
<h3 id="41-和为S的连续正数序列-C"><a href="#41-和为S的连续正数序列-C" class="headerlink" title="41.和为S的连续正数序列(C)"></a>41.和为S的连续正数序列(C)</h3><blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? </p>
</blockquote>
<p>思路：设定两个指针，<strong>如果和大于sum，左指针向后移位，如果小于，右指针向后移位</strong>。 如果两个指针碰在一起，则跳出， <strong>左指针一直小于sum的一半</strong></p>
<h3 id="42-和为sum的两个数字"><a href="#42-和为sum的两个数字" class="headerlink" title="42.和为sum的两个数字"></a>42.和为sum的两个数字</h3><blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
</blockquote>
<p>思路：两头乘积最小，所以两个指针，一个从头，一个从尾分别遍历，当第一次出现和为S时，乘积最小。和41题本质相同</p>
<h3 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h3><blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<p>思路：通过切分字符串，然后将后部分的字符串贴在前部分字符串前面</p>
<p><strong>注意：</strong></p>
<pre><code class="javascript">var left=str.slice(0,n);
var right=str.slice(n);
</code></pre>
<h3 id="44-翻转单词顺序序列"><a href="#44-翻转单词顺序序列" class="headerlink" title="44.翻转单词顺序序列"></a>44.翻转单词顺序序列</h3><blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<pre><code class="javascript">//注意：join参数为分隔符
var array = str.split(&#39; &#39;);
return array.reverse().join(&#39; &#39;);
</code></pre>
<h3 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h3><blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<p>思路：首先先排序，然后统计大小王个数，然后遍历，看缺多少个数才能连续，如果超过大小王个数则失败。注意可能牌重复</p>
<h3 id="46-圆圈中最后剩下的数-C"><a href="#46-圆圈中最后剩下的数-C" class="headerlink" title="46.圆圈中最后剩下的数(C)"></a>46.圆圈中最后剩下的数(C)</h3><blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<p>思路：约瑟夫问题</p>
<ol>
<li>建数组</li>
<li>模拟报数，将报数的人踢出数组，<strong>注意要少1个序号</strong>。</li>
<li>直到数组只剩1个</li>
</ol>
<blockquote>
<p>注意：for循环中i为1开始</p>
</blockquote>
<pre><code class="javascript">for(var i=0;i&lt;n;i++) arr.push(i);
var idx = 0;
while(arr.length &gt; 1){
  for(var i=1;i&lt;m;i++){
    idx=(idx+1)%arr.length;
  }
  arr.splice(idx,1);
}
return arr[0];
</code></pre>
<h3 id="47-1-2-3-……-n"><a href="#47-1-2-3-……-n" class="headerlink" title="47.1+2+3+……+n"></a>47.1+2+3+……+n</h3><blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p>思路：<strong>短路判断+递归运算</strong></p>
<h3 id="48-不用加减乘除做加法-A"><a href="#48-不用加减乘除做加法-A" class="headerlink" title="48. 不用加减乘除做加法(A)"></a>48. 不用加减乘除做加法(A)</h3><blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>首先看十进制是如何做的： 5+7=12，三步走</li>
<li>第一步：<strong>相加各位的值，不算进位</strong>，得到2。</li>
<li>第二步：<strong>计算进位值</strong>，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li>
<li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li>
</ul>
<pre><code class="javascript">while(num2!=0){
  var temp = num1^num2;
  num2 = (num1&amp;num2)&lt;&lt;1;
  num1 = temp;
}
return num1;
</code></pre>
<h3 id="49-把字符串转换成整数-B"><a href="#49-把字符串转换成整数-B" class="headerlink" title="49.把字符串转换成整数(B)"></a>49.把字符串转换成整数(B)</h3><blockquote>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。</p>
</blockquote>
<pre><code class="javascript">//res=res*10+str[i]-&#39;0&#39;;
res = res*10 + (arr[i] &amp; 0xf);
</code></pre>
<h3 id="50-数组中重复数字"><a href="#50-数组中重复数字" class="headerlink" title="50.数组中重复数字"></a>50.数组中重复数字</h3><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<pre><code class="javascript">//1.map
numbers.map(num=&gt;(obj[num]?duplication.push(num):obj[num]=1));
duplication.shift();
//2.排序
numbers.sort((a,b)=&gt;(a-b))
</code></pre>
<h3 id="51-构建乘积数组-B"><a href="#51-构建乘积数组-B" class="headerlink" title="51.构建乘积数组(B)"></a>51.构建乘积数组(B)</h3><blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素<code>B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]</code>。不能使用除法。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>构建<strong>前向乘积数组</strong><code>C[i]=A[0]A[1]…*A[i-1]</code>，<strong>即C[i]=C[i-1]*A[i-1]；</strong></li>
<li>构建<strong>后向乘积数组</strong><code>D[i]=A[n-1]A[n-2]…A[n-i+1]</code>，<strong>即D[i]=D[i+1]*A[i+1]；</strong></li>
<li>通过C[i],D[i]来求B[i]：<strong>B[i]=C[i]*D[i]</strong></li>
</ul>
<pre><code class="javascript">for(var i=1;i&lt;len;i++)
{
  arr[i]=arr[i-1]*array[i-1];
}
for(var i=len-2;i&gt;=0;i--)
{
  temp*=array[i+1];
  arr[i]*=temp;
}
</code></pre>
<h3 id="52-正则表达式匹配-A"><a href="#52-正则表达式匹配-A" class="headerlink" title="52.正则表达式匹配(A)"></a>52.正则表达式匹配(A)</h3><blockquote>
<p>请实现一个函数用来匹配包括<code>’.’和’*‘</code>的正则表达式。模式中的字符’.’表示任意一个字符，而’<em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab</em>ac<em>a”匹配，但是与”aa.a”和”ab</em>a”均不匹配</p>
</blockquote>
<p>思路：</p>
<ul>
<li><p>当模式中的第二个字符不是“*”时：</p>
<ol>
<li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li>
</ol>
</li>
<li><p>而当模式中的第二个字符是“*”时：</p>
<p>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</p>
<ol>
<li>模式后移2字符，相当于x*被忽略；</li>
<li>字符串后移1字符，模式后移2字符；</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li>
</ol>
</li>
</ul>
<h3 id="53-表示数值的字符串-B"><a href="#53-表示数值的字符串-B" class="headerlink" title="53.表示数值的字符串(B)"></a>53.表示数值的字符串(B)</h3><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
</blockquote>
<pre><code class="javascript">return s.match(/[\+\-]?[0-9]*(\.[0-9]*)?([Ee][\+-]?[0-9]+)?/g)[0] == s
</code></pre>
<h3 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h3><blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
</blockquote>
<p>思路：设置一个数组存放初次出现的元素。如果这个元素没有过，就放进数组；如果这个元素有过了，就把他从数组删除。输出数组的第一个元素。</p>
<h3 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h3><blockquote>
<p>一个链表中包含环，请找出该链表的环的入口结点。</p>
</blockquote>
<p>思路：<strong>通过map来存储每次访问的结点</strong>，如果有重复，则是链表入口结点。</p>
<h3 id="56-删除链表中重复的结点-B"><a href="#56-删除链表中重复的结点-B" class="headerlink" title="56.删除链表中重复的结点(B)"></a>56.删除链表中重复的结点(B)</h3><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<p>思路：<strong>需要三个指针</strong>，<strong>第一个指针first的next指向头结点，第二个指针pre指向first，确保每次指向的是重复结点的前一个结点，第三个指针head来遍历</strong>，遇到重复结点，则向后，直到找到当前结点不等于下一个结点时，将pre的next指向head。</p>
<h3 id="57-二叉树的下一个结点-B"><a href="#57-二叉树的下一个结点-B" class="headerlink" title="57.二叉树的下一个结点(B)"></a>57.二叉树的下一个结点(B)</h3><blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>二叉树为空，则返回空；</li>
<li><strong>节点右孩子存在</strong>，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</li>
<li>节点不是根节点。如果该<strong>节点是其父节点的左孩子</strong>，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</li>
</ol>
<pre><code class="javascript">function GetNext(pNode)
{
    // write code here
    if(pNode==null) return null;
    if(pNode.right!=null) {//节点右孩子存在情况
        pNode=pNode.right;
        while(pNode.left!=null){//沿着向左节点找到叶子节点
            pNode=pNode.left;
        }
        return pNode;
    }
    while(pNode.next!=null){
        var pRoot=pNode.next;
        if(pRoot.left==pNode){
            return pRoot
        }
        pNode=pNode.next;
    }
    return null

}
</code></pre>
<h3 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58.对称二叉树"></a>58.对称二叉树</h3><blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<p>思路：采用递归方法，先判断根节点的左子树和右子树是否为空，同时为空，则返回true，一个为空，则为false。同时不为空，则判断其值是否相等，然后递归判断左子树和右子树的</p>
<h3 id="59-按之字形顺序打印二叉树-B"><a href="#59-按之字形顺序打印二叉树-B" class="headerlink" title="59.按之字形顺序打印二叉树(B)"></a>59.按之字形顺序打印二叉树(B)</h3><blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>思路：按深度遍历二叉树，深度（从0开始）为奇数的反转加入数组。</p>
<pre><code class="javascript">function Print(pRoot)
{
    var queue = [];//存储节点队列
    var result = [];
    if(pRoot==null) return result;
    var nextLevel = 0;
    queue.push(pRoot);
    var toBePrinted = 1;//每一行节点个数
    var level = 0;//深度
    var arr = [];
    while(queue.length){
        var temp = queue.shift();
        toBePrinted--;
        arr.push(temp.val);
        if(temp.left){
            queue.push(temp.left);
            nextLevel++;
        }
        if(temp.right){
            queue.push(temp.right);
            nextLevel++;
        }
        if(toBePrinted==0){
            toBePrinted=nextLevel;
            nextLevel=0;
            level++;
            if(level%2==0){
                arr.reverse();
            }
            result.push(arr);
            arr = [];
        }
    }
    return result;
}
</code></pre>
<h3 id="60-把二叉树打印成多行-B"><a href="#60-把二叉树打印成多行-B" class="headerlink" title="60.把二叉树打印成多行(B)"></a>60.把二叉树打印成多行(B)</h3><blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<p>思路：采用队列数据结构，同时需要两个变量分别存储这一层和下一层结点个数。当前层结点个数为零时，则输出结点</p>
<pre><code class="javascript">function Print(pRoot)
{
    // write code here
    var queue = [];//存储节点队列
    var result = [];
    if(pRoot==null) return result;
    var nextLevel = 0;
    queue.push(pRoot);
    var toBePrinted = 1;//每一行节点个数
    var arr = [];
    while(queue.length){
        var temp = queue.shift();
        toBePrinted--;
        arr.push(temp.val);
        if(temp.left){
            queue.push(temp.left);
            nextLevel++;
        }
        if(temp.right){
            queue.push(temp.right);
            nextLevel++;
        }
        if(toBePrinted==0){
            toBePrinted=nextLevel;
            nextLevel=0;
            result.push(arr);
            arr = [];
        }
    }
    return result;
}
</code></pre>
<h3 id="61-序列化二叉树-B"><a href="#61-序列化二叉树-B" class="headerlink" title="61.序列化二叉树(B)"></a>61.序列化二叉树(B)</h3><blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
</blockquote>
<p>思路：</p>
<ul>
<li>序列化，将节点值存入数组中，空节点则使用特殊标记存入数组中。</li>
<li>反序列化，从数组中获取元素，为number类型则生成节点，为特殊标记，则为空节点</li>
</ul>
<h3 id="62-二叉搜索树的第k个结点-C"><a href="#62-二叉搜索树的第k个结点-C" class="headerlink" title="62.二叉搜索树的第k个结点(C)"></a>62.二叉搜索树的第k个结点(C)</h3><blockquote>
<p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
</blockquote>
<p>思路：二叉搜索树，若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；<br>所以采用<strong>中序遍历</strong>的方法，遍历后的结果就是从小到大顺序的结果</p>
<h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</blockquote>
<p>思路：排序</p>
<h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}</p>
</blockquote>
<p>思路</p>
<ol>
<li><p>算出<strong>滑动窗口个数=数组元素个数-滑动窗口大小+1</strong>，然后<strong>遍历循环，将队列头元素取出，存入新元素</strong>。</p>
</li>
<li><p>我的思路:</p>
<pre><code class="javascript">arr.push(Math.max.apply(Math,num.slice(i,i+size)));
</code></pre>
</li>
</ol>
<h3 id="65-矩阵中的路径-A"><a href="#65-矩阵中的路径-A" class="headerlink" title="65.矩阵中的路径(A)"></a>65.矩阵中的路径(A)</h3><blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>思路：<strong>回溯算法</strong></p>
<p>这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。</p>
<p>由于回朔法的<strong>递归特性</strong>，路径可以被<strong>开成一个栈</strong>。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。</p>
<p>由于路径不能重复进入矩阵的格子，<strong>还需要定义和字符矩阵大小一样的布尔值矩阵</strong>，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。</p>
<p>一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p>
<pre><code class="javascript">function hasPath(matrix, rows, cols, path)
{
  function hasPathCore(matrix, rows, cols, row, col, path, pathIndex, visited)      {
    hasPath=hasPathCore(matrix, rows, cols, row - 1, col, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row + 1, col, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row, col - 1, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row, col + 1, path, pathIndex + 1, visited);
  }
}
</code></pre>
<h3 id="66-机器人的运动范围-A"><a href="#66-机器人的运动范围-A" class="headerlink" title="66.机器人的运动范围(A)"></a>66.机器人的运动范围(A)</h3><blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>思路：<strong>回溯算法</strong></p>
<pre><code class="javascript">function movingCount(threshold, rows, cols)
{
  function movingCountSum(threshold,m,n,rows,cols,visited)
  {
    if(m&gt;=0&amp;&amp;m&lt;rows&amp;&amp;n&gt;=0&amp;&amp;n&lt;cols&amp;&amp;!visited[m][n]&amp;&amp;getSum(m,n)&lt;=threshold)
    {
        visited[m][n]=true;
        count = 1+movingCountSum(threshold,m,n-1,rows,cols,visited)+
                movingCountSum(threshold,m,n+1,rows,cols,visited)+
                movingCountSum(threshold,m-1,n,rows,cols,visited)+
                movingCountSum(threshold,m+1,n,rows,cols,visited);
    }
  }
}
</code></pre>
<h2 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h2><h3 id="2-替换空格-B-1"><a href="#2-替换空格-B-1" class="headerlink" title="2.替换空格(B)"></a>2.替换空格(B)</h3><blockquote>
<p>\s+代表多个空格，？则表示取尽可能少的空格</p>
</blockquote>
<h3 id="4-重建二叉树-B-1"><a href="#4-重建二叉树-B-1" class="headerlink" title="4.重建二叉树(B)"></a>4.重建二叉树(B)</h3><h3 id="11-二进制中1的个数-B"><a href="#11-二进制中1的个数-B" class="headerlink" title="11.二进制中1的个数(B)"></a>11.二进制中1的个数(B)</h3><h3 id="12-数值的整数次方-B"><a href="#12-数值的整数次方-B" class="headerlink" title="12.数值的整数次方(B)"></a>12.数值的整数次方(B)</h3><h3 id="16-合并两个排序的链表-A"><a href="#16-合并两个排序的链表-A" class="headerlink" title="16.合并两个排序的链表(A)"></a>16.合并两个排序的链表(A)</h3><pre><code class="javascript">function Merge(pHead1, pHead2)
{
    if(pHead1==null) return pHead2;
    if(pHead2==null) return pHead1;

    if(pHead1.val &lt;= pHead2.val)
    {
        pHead1.next = Merge(pHead1.next,pHead2);
        return pHead1;
    }
    else
    {
        pHead2.next = Merge(pHead1,pHead2.next);
        return pHead2;
    }
}
</code></pre>
<h3 id="17-树的子结构-B"><a href="#17-树的子结构-B" class="headerlink" title="17.树的子结构(B)"></a>17.树的子结构(B)</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>思路：比较B是不是A的子树，B是不是A的右子树的子树，B是不是A的左子树的子树。如果根元素相同，则开始判断左子树和右子树</p>
<blockquote>
<p>注意：</p>
<p>isSubtree中pRoot2要在pRoot1上面判断</p>
</blockquote>
<pre><code class="javascript">function isSubtree(pRoot1,pRoot2){
    if (pRoot2 == null) return true;//pRoot2为null，表示子树已经遍历完
    if (pRoot1 == null) return false;
    if(pRoot1.val==pRoot2.val){
        return isSubtree(pRoot1.left,pRoot2.left) &amp;&amp; isSubtree(pRoot1.right,pRoot2.right);
    }else{
        return false;
    }
}

function HasSubtree(pRoot1, pRoot2)
{
    if(pRoot1==null||pRoot2==null) return false;   
    return isSubtree(pRoot1,pRoot2)||HasSubtree(pRoot1.left,pRoot2)||HasSubtree(pRoot1.right,pRoot2);
}
</code></pre>
<h3 id="18-二叉树镜像-B"><a href="#18-二叉树镜像-B" class="headerlink" title="18.二叉树镜像(B)"></a>18.二叉树镜像(B)</h3><pre><code class="javascript">function Mirror(root)
{
    if(root == null) return;
    var left = Mirror(root.left);
    var right = Mirror(root.right);
    root.left = right;
    root.right = left;
    return root;
}
</code></pre>
<h3 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵(?)"></a>19.顺时针打印矩阵(?)</h3><h3 id="21-栈的压入、弹出-B"><a href="#21-栈的压入、弹出-B" class="headerlink" title="21.栈的压入、弹出(B)"></a>21.栈的压入、弹出(B)</h3><p>思路：设置辅助栈，压入元素，<strong>判断栈顶元素是否等于出栈第一个，相同则出栈</strong>，不同则继续入栈</p>
<h3 id="22-从上往下打印二叉树-B"><a href="#22-从上往下打印二叉树-B" class="headerlink" title="22.从上往下打印二叉树(B)"></a>22.从上往下打印二叉树(B)</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>思路：采用<strong>队列</strong>方法，先将<strong>根节点放入队列</strong>中，然后打印，接着<strong>将左右节点加入队列</strong>中。</p>
<pre><code class="javascript">while (queue.length) {
  var temp = queue.shift();
  result.push(temp.val);
  if (temp.left) {
    queue.push(temp.left);
  }
  if (temp.right) {
    queue.push(temp.right);
  }
}
</code></pre>
<h3 id="23-二叉搜索树的后序遍历-A-1"><a href="#23-二叉搜索树的后序遍历-A-1" class="headerlink" title="23.二叉搜索树的后序遍历(A)"></a>23.二叉搜索树的后序遍历(A)</h3><h3 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h3><h3 id="25-复杂链表的复制-B"><a href="#25-复杂链表的复制-B" class="headerlink" title="25.复杂链表的复制(B)"></a>25.复杂链表的复制(B)</h3><h3 id="26-二叉搜索树与双向链表-A-1"><a href="#26-二叉搜索树与双向链表-A-1" class="headerlink" title="26.二叉搜索树与双向链表(A)"></a>26.二叉搜索树与双向链表(A)</h3><h3 id="27-字符串排列-A"><a href="#27-字符串排列-A" class="headerlink" title="27.字符串排列(A)"></a>27.字符串排列(A)</h3><h3 id="32-把数组排成最小的数-C"><a href="#32-把数组排成最小的数-C" class="headerlink" title="32.把数组排成最小的数(C)"></a>32.把数组排成最小的数(C)</h3><h3 id="35-数组中的逆序对-A-1"><a href="#35-数组中的逆序对-A-1" class="headerlink" title="35.数组中的逆序对(A)"></a>35.数组中的逆序对(A)</h3><h3 id="56-删除链表中重复的结点-B-1"><a href="#56-删除链表中重复的结点-B-1" class="headerlink" title="56.删除链表中重复的结点(B)"></a>56.删除链表中重复的结点(B)</h3>]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础算法]]></title>
      <url>/2017/01/02/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>面试的基础算法整理总结</p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><pre><code class="javascript">function quickSort(arr){
  if(arr.length&lt;=1){return arr;}
  var pivotIndex=Math.floor(arr.length/2);
  //找基准，并把基准从原数组删除
  var pivot=arr.splice(pivotIndex,1)[0];
  //定义左右数组
  var left=[];
  var right=[];

  //比基准小的放在left，比基准大的放在right
  for(var i=0;i&lt;arr.length;i++){
    if(arr[i]&lt;=pivot){
      left.push(arr[i]);
    }
    else{
      right.push(arr[i]);
    }
  }
  //递归
  return quickSort(left).concat([pivot],quickSort(right));
}
</code></pre>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="节点个数"><a href="#节点个数" class="headerlink" title="节点个数"></a>节点个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，节点个数为0</li>
<li>如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</li>
</ol>
<pre><code class="c++">int GetNodeNum(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    return GetNodeNum(pRoot-&gt;m_pLeft) + GetNodeNum(pRoot-&gt;m_pRight) + 1;  
}
</code></pre>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，二叉树的深度为0</li>
<li>如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1</li>
</ol>
<pre><code class="c++">int GetDepth(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    int depthLeft = GetDepth(pRoot-&gt;m_pLeft);  
    int depthRight = GetDepth(pRoot-&gt;m_pRight);  
    return depthLeft &gt; depthRight ? (depthLeft + 1) : (depthRight + 1);   
}
</code></pre>
<h3 id="前序遍历，中序遍历，后序遍历"><a href="#前序遍历，中序遍历，后序遍历" class="headerlink" title="前序遍历，中序遍历，后序遍历"></a>前序遍历，中序遍历，后序遍历</h3><p>前序遍历递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>
</ol>
<pre><code class="javascript">void PreOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    Visit(pRoot); // 访问根节点  
    PreOrderTraverse(pRoot-&gt;m_pLeft); // 前序遍历左子树  
    PreOrderTraverse(pRoot-&gt;m_pRight); // 前序遍历右子树  
}
</code></pre>
<p>中序遍历递归解法</p>
<ol>
<li>如果二叉树为空，空操作。</li>
<li>如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树</li>
</ol>
<pre><code class="javascript">void InOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    InOrderTraverse(pRoot-&gt;m_pLeft); // 中序遍历左子树  
    Visit(pRoot); // 访问根节点  
    InOrderTraverse(pRoot-&gt;m_pRight); // 中序遍历右子树  
}
</code></pre>
<p>后序遍历递归解法</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点</li>
</ol>
<pre><code class="javascript">void PostOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    PostOrderTraverse(pRoot-&gt;m_pLeft); // 后序遍历左子树  
    PostOrderTraverse(pRoot-&gt;m_pRight); // 后序遍历右子树  
    Visit(pRoot); // 访问根节点  
}
</code></pre>
<h3 id="分层遍历二叉树（按层次从上往下，从左往右）"><a href="#分层遍历二叉树（按层次从上往下，从左往右）" class="headerlink" title="分层遍历二叉树（按层次从上往下，从左往右）"></a>分层遍历二叉树（按层次从上往下，从左往右）</h3><p>相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p>
<pre><code class="c++">void LevelTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    queue&lt;BinaryTreeNode *&gt; q;  
    q.push(pRoot);  
    while(!q.empty())  
    {  
        BinaryTreeNode * pNode = q.front();  
        q.pop();  
        Visit(pNode); // 访问节点  
        if(pNode-&gt;m_pLeft != NULL)  
            q.push(pNode-&gt;m_pLeft);  
        if(pNode-&gt;m_pRight != NULL)  
            q.push(pNode-&gt;m_pRight);  
    }  
    return;  
}
</code></pre>
<h3 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空或者k&lt;1返回0</li>
</ol>
<ol>
<li>如果二叉树不为空并且k==1，返回1</li>
<li>如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和</li>
</ol>
<pre><code class="c++">int GetNodeNumKthLevel(BinaryTreeNode * pRoot, int k)  
{  
    if(pRoot == NULL || k &lt; 1)  
        return 0;  
    if(k == 1)  
        return 1;  
    int numLeft = GetNodeNumKthLevel(pRoot-&gt;m_pLeft, k-1); // 左子树中k-1层的节点个数  
    int numRight = GetNodeNumKthLevel(pRoot-&gt;m_pRight, k-1); // 右子树中k-1层的节点个数  
    return (numLeft + numRight);  
}
</code></pre>
<h3 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回0</li>
</ol>
<ol>
<li>如果二叉树不为空且左右子树为空，返回1</li>
<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数</li>
</ol>
<pre><code class="c++">int GetLeafNodeNum(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return 0;  
    if(pRoot-&gt;m_pLeft == NULL &amp;&amp; pRoot-&gt;m_pRight == NULL)  
        return 1;  
    int numLeft = GetLeafNodeNum(pRoot-&gt;m_pLeft); // 左子树中叶节点的个数  
    int numRight = GetLeafNodeNum(pRoot-&gt;m_pRight); // 右子树中叶节点的个数  
    return (numLeft + numRight);  
}
</code></pre>
<h3 id="求二叉树的镜像"><a href="#求二叉树的镜像" class="headerlink" title="求二叉树的镜像"></a>求二叉树的镜像</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回空</li>
<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树</li>
</ol>
<pre><code class="c++">BinaryTreeNode * Mirror(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 返回NULL  
        return NULL;  
    BinaryTreeNode * pLeft = Mirror(pRoot-&gt;m_pLeft); // 求左子树镜像  
    BinaryTreeNode * pRight = Mirror(pRoot-&gt;m_pRight); // 求右子树镜像  
        // 交换左子树和右子树  
    pRoot-&gt;m_pLeft = pRight;  
    pRoot-&gt;m_pRight = pLeft;  
    return pRoot;  
}
</code></pre>
<h3 id="判断二叉树是不是平衡二叉树"><a href="#判断二叉树是不是平衡二叉树" class="headerlink" title="判断二叉树是不是平衡二叉树"></a>判断二叉树是不是平衡二叉树</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回真</li>
<li>如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假</li>
</ol>
<pre><code class="c++">bool IsAVL(BinaryTreeNode * pRoot, int &amp; height)  
{  
    if(pRoot == NULL) // 空树，返回真  
    {  
        height = 0;  
        return true;  
    }  
    int heightLeft;  
    bool resultLeft = IsAVL(pRoot-&gt;m_pLeft, heightLeft);  
    int heightRight;  
    bool resultRight = IsAVL(pRoot-&gt;m_pRight, heightRight);  
    if(resultLeft &amp;&amp; resultRight &amp;&amp; abs(heightLeft - heightRight) &lt;= 1) // 左子树和右子树都是AVL，并且高度相差不大于1，返回真  
    {  
        height = max(heightLeft, heightRight) + 1;  
        return true;  
    }  
    else  
    {  
        height = max(heightLeft, heightRight) + 1;  
        return false;  
    }  
}
</code></pre>
<h3 id="由前序遍历序列和中序遍历序列重建二叉树"><a href="#由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="由前序遍历序列和中序遍历序列重建二叉树"></a>由前序遍历序列和中序遍历序列重建二叉树</h3><p>递归解法：</p>
<ol>
<li>如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。</li>
<li>创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。</li>
</ol>
<pre><code class="javascript">function reConstructBinaryTree(pre, vin)
{
    // write code here
    if(pre.length==0 || vin.length==0) return null;
    var index=vin.indexOf(pre[0]);
    var left=vin.slice(0,index);//中序左子树
    var right=vin.slice(index+1);//中序右子树
    return {
        val:pre[0],
        //递归左右子树的前序，中序 
        left:reConstructBinaryTree(pre.slice(1,index+1),left),
        right:reConstructBinaryTree(pre.slice(index+1),right)
     }; 
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5总结]]></title>
      <url>/2017/01/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML5/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>总结H5。后续补上demo。</p>
<a id="more"></a>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><ul>
<li>HTML5概念</li>
<li>多媒体</li>
<li>拖放</li>
<li>Canvas &amp; SVG</li>
<li>地理定位</li>
<li>Web存储</li>
<li>应用缓存</li>
<li>Web Workers</li>
<li>服务器发送事件</li>
<li>表单</li>
<li>Hisyory API</li>
</ul>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="HTML5概念"><a href="#HTML5概念" class="headerlink" title="HTML5概念"></a>HTML5概念</h2><h3 id="什么是HTML5"><a href="#什么是HTML5" class="headerlink" title="什么是HTML5"></a>什么是HTML5</h3><p>最新的HTML标准，主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件</p>
<h3 id="SGML、XML、HTML关系"><a href="#SGML、XML、HTML关系" class="headerlink" title="SGML、XML、HTML关系"></a>SGML、XML、HTML关系</h3><p>SGML（标准通用标记语言）是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML（超文本标记语言）是被用SGML描述的标记语言。</p>
<p>因此利用SGML创建了HTML参照和必须共同遵守的DTD（文档类型定义），你会经常在HTML页面的头部发现“DOCTYPE”属性，用来定义用于解析目标DTD</p>
<p>XML（可扩展标记语言）使用了SGML，例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。</p>
<p>XHTML创建于XML，他被使用在HTML4.0中。</p>
<p>总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML</p>
<h3 id="为什么HTML5不需要DTD"><a href="#为什么HTML5不需要DTD" class="headerlink" title="为什么HTML5不需要DTD"></a>为什么HTML5不需要DTD</h3><p>HTML5没有使用SGML或者XHTML</p>
<h3 id="HTML5的页面结构变化"><a href="#HTML5的页面结构变化" class="headerlink" title="HTML5的页面结构变化"></a>HTML5的页面结构变化</h3><p>一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。HTML4要使用DIV标签。HTML5中为这些区域创建元素名称：<code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>等</p>
<h3 id="HTML5-文档类型和字符集"><a href="#HTML5-文档类型和字符集" class="headerlink" title="HTML5 文档类型和字符集"></a>HTML5 文档类型和字符集</h3><pre><code class="html">&lt;!doctype html&gt;
&lt;meta charset=”UTF-8″&gt;
</code></pre>
<h3 id="废弃的标签"><a href="#废弃的标签" class="headerlink" title="废弃的标签"></a>废弃的标签</h3><ul>
<li>frame</li>
<li>frameset</li>
<li>noframe</li>
<li>applet</li>
<li>big</li>
<li>center</li>
<li>basefront</li>
</ul>
<h3 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h3><ul>
<li>Media API</li>
<li>Text Track API</li>
<li>Application Cache API</li>
<li>User Interaction</li>
<li>Data Transfer API</li>
<li>Command API</li>
<li>Constraint Validation API</li>
<li>History API</li>
</ul>
<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="嵌入音频"><a href="#嵌入音频" class="headerlink" title="嵌入音频"></a>嵌入音频</h3><pre><code class="html">&lt;audio controls&gt;
    &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt;
    Your browser does’nt support audio embedding feature.
&lt;/audio&gt;
</code></pre>
<h3 id="嵌入视频"><a href="#嵌入视频" class="headerlink" title="嵌入视频"></a>嵌入视频</h3><pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
  &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
   Your browser does’nt support video embedding feature.
&lt;/video&gt;
</code></pre>
<h3 id="其他媒体标签"><a href="#其他媒体标签" class="headerlink" title="其他媒体标签"></a>其他媒体标签</h3><p><code>&lt;embed&gt;</code> 标签定义嵌入的内容，比如插件</p>
<pre><code class="html">&lt;embed type=”video/quicktime” src=”Fishing.mov”&gt;
</code></pre>
<p><code>&lt;source&gt;</code> 对于定义多个数据源很有用</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
&lt;/video&gt;
</code></pre>
<p><code>&lt;track&gt;</code> 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
     &lt;track kind=”subtitles” label=”English” src=”jamshed_en.vtt” srclang=”en” default&gt;&lt;/track&gt;
      &lt;track kind=”subtitles” label=”Arabic” src=”jamshed_ar.vtt” srclang=”ar”&gt;&lt;/track&gt;
&lt;/video&gt;
</code></pre>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function allowDrop(ev)
{
  ev.preventDefault();
}

function drag(ev)
{
  ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
}

function drop(ev)
{
  ev.preventDefault();
  var data=ev.dataTransfer.getData(&quot;Text&quot;);
  ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p><strong>设置元素为可拖放 - draggable</strong></p>
<p>draggable 属性设置为 true </p>
<p><strong>拖动什么 - ondragstart 和 setData()</strong></p>
<p>ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。</p>
<p>dataTransfer.setData() 方法设置被拖数据的数据类型和值</p>
<p><strong>放到何处 - ondragover</strong></p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<pre><code class="javascript">event.preventDefault()
</code></pre>
<p><strong>进行放置 - ondrop</strong></p>
<p>ondrop 属性调用了一个函数，drop(<em>event</em>)</p>
<h2 id="Canvas-amp-SVG"><a href="#Canvas-amp-SVG" class="headerlink" title="Canvas &amp; SVG"></a>Canvas &amp; SVG</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><h4 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h4><h5 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h5><pre><code class="javascript">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;
  您的浏览器不支持canvas！
&lt;/canvas&gt;

var canvas = document.getElementById(&#39;myCanvas&#39;);
if (canvas.getContext) {
  var ctx = canvas.getContext(&#39;2d&#39;);
}

//（1）绘制路径
ctx.beginPath(); // 开始路径绘制
ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)
ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线
ctx.lineWidth = 1.0; // 设置线宽
ctx.strokeStyle = &#39;#CC0000&#39;; // 设置线的颜色
ctx.stroke(); // 进行线的着色，这时整条线才变得可见
//最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。

//（2）绘制矩形
//实心矩形
ctx.fillStyle = &#39;yellow&#39;;
ctx.fillRect(50, 50, 200, 100); 
//空心矩形
ctx.strokeRect(10,10,200,100);
//清除某个矩形区域的内容
ctx.clearRect(100,50,50,50);  

//（3）绘制文本
// 设置字体
ctx.font = &quot;Bold 20px Arial&quot;; 
// 设置对齐方式
ctx.textAlign = &quot;left&quot;;
// 设置填充颜色
ctx.fillStyle = &quot;#008600&quot;; 
// 设置字体内容，以及在画布上的位置,绘制文本,不支持文本断行
ctx.fillText(&quot;Hello!&quot;, 10, 50); 
// 绘制空心字
ctx.strokeText(&quot;Hello!&quot;, 10, 100); 

//（4）绘制圆形和扇形
//绘制扇形,startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
//绘制实心的圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.fillStyle = &quot;#000&quot;; 
ctx.fill();
//绘制空心圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.lineWidth = 1.0; 
ctx.strokeStyle = &quot;#000&quot;; 
ctx.stroke();

//（5）设置渐变色
var myGradient = ctx.createLinearGradient(0, 0, 0, 160); 
myGradient.addColorStop(0, &quot;#BABABA&quot;); 
myGradient.addColorStop(1, &quot;#636363&quot;);
//使用方法如下：
ctx.fillStyle = myGradient;
ctx.fillRect(10,10,200,100);

//（6）设置阴影
ctx.shadowOffsetX = 10; // 设置水平位移
ctx.shadowOffsetY = 10; // 设置垂直位移
ctx.shadowBlur = 5; // 设置模糊度
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色
ctx.fillStyle = &quot;#CC0000&quot;; 
ctx.fillRect(10,10,200,100)
</code></pre>
<h5 id="图像处理方法"><a href="#图像处理方法" class="headerlink" title="图像处理方法"></a>图像处理方法</h5><pre><code class="javascript">//drawImage方法:将图像文件插入画布,drawImage方法只能在图像完全载入后才能调用
var image = new Image();
image.onload = function() {
  var canvas = document.createElement(&#39;canvas&#39;);
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext(&#39;2d&#39;).drawImage(image, 0, 0);
  // 插入页面底部
  document.body.appendChild(image);
  return canvas;
}
image.src = &#39;image.png&#39;;

//getImageData方法，putImageData方法:读取Canvas的内容，返回一个对象，包含了每个像素的信息。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新绘制在Canvas上。
var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
context.putImageData(imageData, 0, 0);

//toDataURL方法:将Canvas数据重新转化成一般的图像文件形式。
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL(&#39;image/png&#39;);
  return image;
}

//save方法，restore方法:save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。
ctx.save();
ctx.fillStyle = &#39;#CC0000&#39;;
ctx.fillRect(10,10,150,100);
ctx.restore();
ctx.fillStyle = &#39;#000000&#39;;
ctx.fillRect(180,10,150,100);
</code></pre>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><a href="http://blog.csdn.net/gertyy/article/details/53637951" target="_blank" rel="external">Canvas API 详解</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Canvas和SVG"><a href="#Canvas和SVG" class="headerlink" title="Canvas和SVG"></a>Canvas和SVG</h4><h5 id="什么是SVG？"><a href="#什么是SVG？" class="headerlink" title="什么是SVG？"></a>什么是SVG？</h5><p>SVG（Scalable Vector Graphics可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制，这使得他轻便，显示更加迅速</p>
<pre><code class="html">&lt;svg id=&quot;svgelem&quot; height=&quot;[object SVGAnimatedLength]&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
&lt;line style=&quot;stroke: rgb(255, 0, 0); stroke-width: 2px;&quot; y2=&quot;[object SVGAnimatedLength]&quot; x2=&quot;[object SVGAnimatedLength]&quot; y1=&quot;[object SVGAnimatedLength]&quot; x1=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/line&gt;
</code></pre>
<h5 id="Canvas和SVG图形的区别是什么？"><a href="#Canvas和SVG图形的区别是什么？" class="headerlink" title="Canvas和SVG图形的区别是什么？"></a>Canvas和SVG图形的区别是什么？</h5><table>
<thead>
<tr>
<th>SVG</th>
<th>Canvas</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个就好像绘制和记忆，换句话说任何使用SVG绘制的形状都能被记忆和操作，浏览器可以再次显示</td>
<td>Canvas就像绘制和忘记，一旦绘制完成你不能访问像素和操作它</td>
</tr>
<tr>
<td>SVG对于创建图形例如CAD软件是良好的，一旦东西绘制，用户就想去操作它</td>
<td>Canvas在绘制和忘却的场景例如动画和游戏是良好的</td>
</tr>
<tr>
<td>因为为了之后的操作，需要记录坐标，所以比较缓慢</td>
<td>因为没有记住以后事情的意向，所以更快</td>
</tr>
<tr>
<td>我们可以用绘制对象的相关事件处理</td>
<td>我们不能使用绘制对象的相关事件处理，因为我们没有他们的参考</td>
</tr>
<tr>
<td>分辨率无关</td>
<td>分辨率相关</td>
</tr>
</tbody>
</table>
<h4 id="Canvas使用"><a href="#Canvas使用" class="headerlink" title="Canvas使用"></a>Canvas使用</h4><h5 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h5><ul>
<li>定义Canvas区域</li>
<li>获取访问canvas上下文区域</li>
<li>绘制图形</li>
</ul>
<pre><code class="html">&lt;body  onload=&quot;DrawMe();&quot;&gt;
&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;script&gt;
function DrawMe()
{
  var c=document.getElementById(&quot;mycanvas&quot;);
  var ctx=c.getContext(&quot;2d&quot;);
  ctx.moveTo(10,10);
  ctx.lineTo(200,100);
  ctx.stroke();
}
</code></pre>
<h5 id="Canvas和SVG画矩形"><a href="#Canvas和SVG画矩形" class="headerlink" title="Canvas和SVG画矩形"></a>Canvas和SVG画矩形</h5><p>SVG绘制矩形</p>
<pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;rect style=&quot;fill: rgb(0, 0, 255); stroke-width: 1px; stroke: rgb(0, 0, 0);&quot; height=&quot;[object SVGAnimatedLength]&quot; width=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/rect&gt;
</code></pre>
<p>Canvas绘制矩形</p>
<pre><code class="javascript">var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.rect(20,20,150,100);
ctx.stroke();
</code></pre>
<h2 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a><a href="http://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="external">地理定位</a></h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p>getCurrentPosition() 方法</p>
<pre><code class="javascript">navigator.geolocation.getCurrentPosition(showPosition);
</code></pre>
<p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数</p>
<h2 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h2><h3 id="localStorage的特点"><a href="#localStorage的特点" class="headerlink" title="localStorage的特点"></a>localStorage的特点</h3><ol>
<li>localStorage拓展了cookie的4K限制。</li>
</ol>
<ol>
<li><p>数据直接存储到本地，5M大小，相比于cookie可以节约带宽。</p>
<p>注意：遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>
</li>
<li><p>localStorage只支持string类型的存储。</p>
</li>
</ol>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code class="javascript">//添加
localStorage[&quot;a&quot;]=1;
localStorage.b=1;
localStorage.setItem(“c”,”India”);

//读取
var a = localStorage[&quot;a&quot;];
var b = localStorage.b;
var country = localStorage.getItem(“Key001”);

//改
localStorage[&quot;a&quot;]=2;

//删
localStorage.clear();    //全删
localStorage.removeItem(&quot;a&quot;);    //部分删

//获取键值
for(i=0;i&lt;localStorage.length;i++){
  var key=localStorage.key(i);
}
</code></pre>
<p>可以存JSON,注意<strong>stringify</strong> 和 <strong>parse</strong></p>
<pre><code class="javascript">var data={
  name:&#39;xiecanyong&#39;,
  sex:&#39;man&#39;,
  hobby:&#39;program&#39;
};

var d=JSON.stringify(data);

storage.setItem(&quot;data&quot;,d);

//将JSON字符串转换成为JSON对象输出
var json=storage.getItem(&quot;data&quot;);
var jsonObj=JSON.parse(json);
</code></pre>
<h3 id="本地存储和cookies区别"><a href="#本地存储和cookies区别" class="headerlink" title="本地存储和cookies区别"></a>本地存储和cookies区别</h3><table>
<thead>
<tr>
<th></th>
<th>Cookies</th>
<th>Local storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端/服务端</td>
<td>客户端和服务端都能访问数据。Cookie的数据通过每一个请求发送到服务端</td>
<td>只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器</td>
</tr>
<tr>
<td>大小</td>
<td>每个cookie有4K</td>
<td>每个域5MB</td>
</tr>
<tr>
<td>过期</td>
<td>Cookies有有效期，所以在过期之后cookie和cookie数据会被删除</td>
<td>没有过期数据，无论最后用户从浏览器删除或者使用Javascript程序删除，我们都需要删除</td>
</tr>
</tbody>
</table>
<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a><a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">知识点</a></h3><h4 id="应用缓存是什么"><a href="#应用缓存是什么" class="headerlink" title="应用缓存是什么"></a>应用缓存是什么</h4><p>应用缓存可以帮助你指定哪些文件需要缓存，哪些不需要。</p>
<h4 id="应用程序缓存优势"><a href="#应用程序缓存优势" class="headerlink" title="应用程序缓存优势"></a>应用程序缓存优势</h4><ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>首先我们需要指定”manifest”文件，Mainfest文件的内容类型应是“text/cache-manifest”.</p>
<pre><code class="http">CACHE MANIFEST
# version 1.0
CACHE :
Login.aspx
</code></pre>
<pre><code class="php">Response.ContentType = &quot;text/cache-manifest&quot;;
Response.Write(&quot;CACHE MANIFEST \n&quot;);
Response.Write(&quot;# 2012-02-21 v1.0.0 \n&quot;);
Response.Write(&quot;CACHE : \n&quot;);
Response.Write(&quot;Login.aspx \n&quot;);
Response.Flush();
Response.End();
</code></pre>
<p>创建一个缓存manifest文件以后，接下来的事情实在HTML页面中提供mainfest连接</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="应用缓存中的回退是什么"><a href="#应用缓存中的回退是什么" class="headerlink" title="应用缓存中的回退是什么"></a>应用缓存中的回退是什么</h4><p>应用缓存中的回退帮助你指定在服务器不可访问的时候，将会显示某文件。例如在下面的manifest文件中，我们说如果谁敲击了”/home”同时服务器不可到达的时候，”homeoffline.html”文件应送达</p>
<pre><code class="http">FALLBACK:
/home/ /homeoffline.html
</code></pre>
<h4 id="应用缓存中的网络是什么"><a href="#应用缓存中的网络是什么" class="headerlink" title="应用缓存中的网络是什么"></a>应用缓存中的网络是什么</h4><p>网络命令描述不需要缓存的文件，例如以下代码中，我们说”home.aspx”永远都不应该被缓存或者离线访问。</p>
<pre><code class="http">NETWORK:
home.aspx
</code></pre>
<h4 id="应用程序缓存和浏览器缓存有什么区别"><a href="#应用程序缓存和浏览器缓存有什么区别" class="headerlink" title="应用程序缓存和浏览器缓存有什么区别"></a>应用程序缓存和浏览器缓存有什么区别</h4><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><h4 id="什么是Web-Workers，有什么用"><a href="#什么是Web-Workers，有什么用" class="headerlink" title="什么是Web Workers，有什么用"></a>什么是Web Workers，有什么用</h4><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。帮助我们用异步执行Javascript文件</p>
<h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>除了 Internet Explorer</p>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><h5 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h5><pre><code class="javascript">if(typeof(Worker)!==&quot;undefined&quot;)
{
  // Yes! Web worker support!
  // Some code.....
}
else
{
  // Sorry! No Web Worker support..
}
</code></pre>
<h5 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h5><p><strong>主线程</strong>通过Javascript文件名创建<strong>worker</strong>对象</p>
<pre><code class="javascript">var worker = new Worker(&quot;MyHeavyProcess.js&quot;);
</code></pre>
<p><strong>子线程</strong>需要使用“<strong>PostMessage</strong>”发送信息给worker对象</p>
<pre><code class="javascript">worker.postMessage();
</code></pre>
<p><strong>主线程</strong>当worker线程发送数据的时候，我们在调用结束的时候，通过”<strong>onMessage</strong>”事件获取</p>
<pre><code class="javascript">worker.onmessage = function (e) 
{
document.getElementById(&quot;txt1&quot;).value = e.data;
};
</code></pre>
<p>出错处理。<strong>onerror</strong>监听，错误消息可以通过<strong>e.message</strong>来获取。</p>
<h5 id="如何中止"><a href="#如何中止" class="headerlink" title="如何中止"></a>如何中止</h5><p><strong>主线程</strong>。注意：一旦terminate后，无法重新启用，只能另外创建。</p>
<pre><code class="javascript">w.terminate();
</code></pre>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h4 id="Web-Worker线程的限制是什么"><a href="#Web-Worker线程的限制是什么" class="headerlink" title="Web Worker线程的限制是什么"></a>Web Worker线程的限制是什么</h4><p>Web worker线程不能修改HTML元素，全局变量和Window.Location一类的窗口属性。可以自由使用Javascript数据类型，XMLHttpRequest调用等。</p>
<p>简而言之，就是<strong>允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</strong>。</p>
<blockquote>
<p>原因：worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做<strong>WorkerGlobalScope</strong>的东西，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。</p>
</blockquote>
<h2 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h2><h3 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h3><h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><h5 id="EventSource，onmessage"><a href="#EventSource，onmessage" class="headerlink" title="EventSource，onmessage"></a>EventSource，onmessage</h5><pre><code class="javascript">var source=new EventSource(&quot;demo_sse.php&quot;);

source.onmessage=function(event){
  document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
};
</code></pre>
<h5 id="服务器端代码实例"><a href="#服务器端代码实例" class="headerlink" title="服务器端代码实例"></a>服务器端代码实例</h5><p><strong>把 “Content-Type” 报头设置为 “text/event-stream”。</strong></p>
<h5 id="ASP-代码-VB-demo-sse-asp"><a href="#ASP-代码-VB-demo-sse-asp" class="headerlink" title="ASP 代码 (VB) (demo_sse.asp):"></a>ASP 代码 (VB) (demo_sse.asp):</h5><pre><code class="asp">&lt;%
Response.ContentType=&quot;text/event-stream&quot;
Response.Expires=-1
Response.Write(&quot;data: &quot; &amp; now())
Response.Flush()
%&gt;
</code></pre>
<h5 id="EventSource-对象"><a href="#EventSource-对象" class="headerlink" title="EventSource 对象"></a>EventSource 对象</h5><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onopen</td>
<td>当通往服务器的连接被打开</td>
</tr>
<tr>
<td>onmessage</td>
<td>当接收到消息</td>
</tr>
<tr>
<td>onerror</td>
<td>当错误发生</td>
</tr>
</tbody>
</table>
<h4 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>除了IE。</p>
<h2 id="WebSQL"><a href="#WebSQL" class="headerlink" title="WebSQL"></a>WebSQL</h2><h3 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h3><h4 id="什么是WebSQL"><a href="#什么是WebSQL" class="headerlink" title="什么是WebSQL"></a>什么是WebSQL</h4><p>WebSQL是一个在浏览器客户端的结构关系数据库，这是浏览器内的本地RDBMS(关系型数据库系统)，你可以使用SQL查询</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>第一步我们需要做的是使用如下所示的“OpenDatabase”方法打开数据库</p>
<pre><code class="javascript">var db=openDatabase(&#39;dbCustomer&#39;,&#39;1.0&#39;,&#39;Customer app’, 2 * 1024 * 1024);
</code></pre>
<p>为了执行SQL，我们需要使用“transaction”方法，并调用”executeSql”方法来使用SQL</p>
<pre><code class="javascript">db.transaction(function (tx) 
{
  tx.executeSql(&#39;CREATE TABLE IF NOT EXISTS tblCust(id unique, customername)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES(1, &quot;shiv&quot;)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES (2, &quot;raju&quot;)&#39;);
  tx.executeSql(&#39;SELECT * FROM tblcust&#39;, [], function (tx, results) {
   for (i = 0; i &lt; len; i++)
    {
     msg = &quot;&lt;p&gt;&lt;b&gt;&quot; + results.rows.item(i).log + &quot;&lt;/b&gt;&lt;/p&gt;&quot;;
     document.querySelector(&#39;#customer).innerHTML +=  msg;
    }
 }, null);
});
</code></pre>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><h4 id="WebSql是HTML5的一个规范吗"><a href="#WebSql是HTML5的一个规范吗" class="headerlink" title="WebSql是HTML5的一个规范吗"></a>WebSql是HTML5的一个规范吗</h4><p>不是，许多人把它标记为HTML5，但是他不是HTML5的规范的一部分，这个规范是基于SQLite的</p>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><h3 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h3><h4 id="浏览器支持-2"><a href="#浏览器支持-2" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><pre><code class="javascript">return !!(window.history &amp;&amp; history.pushState);
</code></pre>
<h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><h5 id="两个新方法"><a href="#两个新方法" class="headerlink" title="两个新方法"></a>两个新方法</h5><p>history.pushState(); 和 history.replaceState();</p>
<p>两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。</p>
<p>pushState()和replaceState()参数一样，参数说明如下：</p>
<ol>
<li>state：存储JSON字符串，可以用在popstate事件中。</li>
<li>title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替</li>
<li>url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。</li>
</ol>
<h5 id="history对象常见用法"><a href="#history对象常见用法" class="headerlink" title="history对象常见用法"></a>history对象常见用法</h5><ul>
<li>history.back();//返回上一页，相当于浏览器上后退功能。</li>
<li>history.forward();//去到下一页，相当于浏览器的前进功能。</li>
<li>histoty.go(int);//去到指定的浏览历史记录页面。int是正的时候，就是向前int个历史记录，如果没有那么多，就没有行为。int是负数的时候那么就会向后，为0页面即没有任何变化。</li>
</ul>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><h3 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h3><h4 id="keygen-元素"><a href="#keygen-元素" class="headerlink" title="keygen 元素"></a>keygen 元素</h4><p>keygen 元素的作用是提供一种验证用户的可靠方法。</p>
<h4 id="新的表单属性"><a href="#新的表单属性" class="headerlink" title="新的表单属性"></a>新的表单属性</h4><h5 id="新的-form-属性"><a href="#新的-form-属性" class="headerlink" title="新的 form 属性"></a>新的 form 属性</h5><ul>
<li>autocomplete</li>
<li>novalidate</li>
</ul>
<h5 id="新的-input-属性"><a href="#新的-input-属性" class="headerlink" title="新的 input 属性"></a>新的 input 属性</h5><ul>
<li>autocomplete</li>
<li>autofocus</li>
<li>form</li>
<li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li>
<li>height 和 width</li>
<li>list</li>
<li>min, max 和 step</li>
<li>multiple</li>
<li>pattern (regexp)</li>
<li>placeholder</li>
<li>required</li>
</ul>
<h4 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h4><p>HTML5中的Datalist元素有助于提供文本框自动完成特性</p>
<p>datalist 元素规定输入域的选项列表。列表是通过 datalist 内的 option 元素创建的。</p>
<p>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id：</p>
<pre><code class="html">&lt;input list=&quot;Country&quot;&gt;
&lt;datalist id=&quot;Country&quot;&gt;
  &lt;option value=&quot;India&quot;&gt;
  &lt;option value=&quot;Italy&quot;&gt;
  &lt;option value=&quot;Iran&quot;&gt;
  &lt;option value=&quot;Israel&quot;&gt;
  &lt;option value=&quot;Indonesia&quot;&gt;
&lt;/datalist&gt;
</code></pre>
<blockquote>
<p>提示：option 元素永远都要设置 value 属性。</p>
</blockquote>
<h4 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h4><ol>
<li>Color</li>
<li>Date</li>
<li>Datetime-local</li>
<li>Email</li>
<li>Time</li>
<li>Url</li>
<li>Range</li>
<li>Telephone</li>
<li>Number</li>
<li>Search</li>
</ol>
<pre><code class="html">如果你想显示颜色选择对话框
&lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;

如果你想显示日历对话框
&lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt;

如果你想显示含有本地时间的日历
&lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;

如果你想创建一个含有email校验的HTML文本框，我们可以设置类型为“email”
&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;

对于URL验证设置类型为”url”
&lt;input type=&quot;url&quot; name=&quot;sitename&quot;&gt;

如果你想限定数字范围，你可以设置类型为“number”
&lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;

如果你想显示范围控制，你可以使用类型”range”
&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;6&quot;&gt;

想让文本框作为搜索引擎
&lt;input type=&quot;search&quot; name=&quot;googleengine&quot;&gt;

想只能输入时间
&lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;

如果你想使用文本框接受电话号码
&lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt;
</code></pre>
<h4 id="输出元素"><a href="#输出元素" class="headerlink" title="输出元素"></a>输出元素</h4><p>当你需要计算两个输入的和值到一个标签中的时候你需要输出元素。</p>
<p>例如你有两个文本框，你想将来自这两个输入框中的数字求和并放到标签中。</p>
<pre><code class="html">&lt;form onsubmit=&quot;return false&quot;  oninput=&quot;o.value = parseInt(a.value) + parseInt(b.value)&quot;&gt;
  &lt;input name=&quot;a&quot; type=&quot;number&quot;&gt; +
  &lt;input name=&quot;b&quot; type=&quot;number&quot;&gt; =
  &lt;output name=&quot;o&quot; /&gt;
&lt;/form&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速搭建Hexo]]></title>
      <url>/2016/10/01/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2/%E6%90%AD%E5%BB%BAhexo/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>这篇文章主要是提醒自己半年更一次博客忘了要怎么做。当然如果想<strong>迅速</strong>建站，可是可以参考的。</p>
<a id="more"></a>
<h1 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h1><p>首先需要搭建hexo，包括：</p>
<ul>
<li>安装node.js</li>
<li>安装Hexo</li>
<li>后期部署</li>
<li>hexo配置</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code class="shell">npm install -g hexo-cli --no-optional
npm install hexo-deployer-git --save
cd ~/Document/hexo
hexo init
npm install
</code></pre>
<h2 id="后期部署"><a href="#后期部署" class="headerlink" title="后期部署"></a>后期部署</h2><pre><code>hexo new &quot;blogName&quot;        //添加文章
hexo new page &quot;pageName&quot; #新建页面
hexo clean
hexo algolia    //algolia搜索
hexo 

hexo generate    //生成静态页面
hexo sever        //本地启动
hexo deploy        //同步到github
</code></pre><h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>主要是配置下github账户信息：</p>
<pre><code>deploy: 
     type: git 
     repo: https://github.com/用户名/用户名.github.io.git 
     branch: master
</code></pre><p>其他配置信息可以参考各个主题文档</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>用过material、yilla、next等，也用过自定义的主题，其实内容都是大同小异，主要就是_config.yml修改，插入图片，配置rss、评论、搜索、统计等信息。详细见各个主题Doc。</p>
<p>我最近使用的是material( <a href="https://mt.viosey.com/docs/#/" target="_blank" rel="external">Material Theme Doc</a> )，也是我推荐的。它的主题是简洁，看着很干净。</p>
<p>具体流程：</p>
<ul>
<li>安装主题</li>
<li>启用主题</li>
<li>主题配置</li>
</ul>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>在站点 _config.yml 中设置theme</p>
<h2 id="主题配置-1"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="头像等信息"><a href="#头像等信息" class="headerlink" title="头像等信息"></a>头像等信息</h3><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>这块也是因主题而异。material主题只需要在post的md中首行添加</p>
<pre><code>categories:
  - 博客栈
</code></pre><h3 id="设置favicon"><a href="#设置favicon" class="headerlink" title="设置favicon"></a>设置favicon</h3><p>选择一个favicon制作网站完成制作，例如<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>是一个免费的在线制作ico图标网站。</p>
<h1 id="插件第三方"><a href="#插件第三方" class="headerlink" title="插件第三方"></a>插件第三方</h1><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><ul>
<li><a href="http://www.tuicool.com/articles/m6bIJfq" target="_blank" rel="external">为Hexo博客添加版权说明和打赏功能</a> </li>
</ul>
<h2 id="添加canvas-nest特效"><a href="#添加canvas-nest特效" class="headerlink" title="添加canvas_nest特效"></a>添加canvas_nest特效</h2><ul>
<li><a href="http://tc9011.com/2017/02/02/hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/" target="_blank" rel="external">hexo文章添加版权声明及一些特效</a> </li>
</ul>
<h2 id="algolia搜索"><a href="#algolia搜索" class="headerlink" title="algolia搜索"></a>algolia搜索</h2><ul>
<li><a href="http://www.jianshu.com/p/fa2354d61e37" target="_blank" rel="external">hexo+next添加algolia搜索</a></li>
<li>修改文章需要执行：<pre><code>hexo algolia
</code></pre></li>
</ul>
<h2 id="添加文章阅读量"><a href="#添加文章阅读量" class="headerlink" title="添加文章阅读量"></a>添加文章阅读量</h2><ul>
<li><a href="http://www.joryhe.com/2016-05-29-how_to_create_leancloud_read_Counter.html" target="_blank" rel="external">leanCloud,实现文章阅读量统计</a> </li>
</ul>
<h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><ul>
<li><a href="https://segmentfault.com/q/1010000008403584" target="_blank" rel="external">hexo主题下的开启打赏功能具体是怎么实现的呀？</a> </li>
</ul>
<h2 id="音乐外链"><a href="#音乐外链" class="headerlink" title="音乐外链"></a>音乐外链</h2><ul>
<li><a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">Hexo中播放网易云音乐的实践</a> </li>
</ul>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><ul>
<li><a href="http://blog.csdn.net/yingpaixiaochuan/article/details/68954103" target="_blank" rel="external">Hexo博客（Next主题）放弃多说，接入网易云跟贴</a></li>
</ul>
<h2 id="首页文章以摘要形式显示"><a href="#首页文章以摘要形式显示" class="headerlink" title="首页文章以摘要形式显示"></a>首页文章以摘要形式显示</h2><ul>
<li>打开<strong>主题配置文件</strong>，找到如下位置，其中<code>length</code>代表显示摘要的截取字符长度。修改<pre><code>auto_excerpt:
  enable: true
length: 150
</code></pre></li>
</ul>
<h2 id="设置首页文章显示篇数"><a href="#设置首页文章显示篇数" class="headerlink" title="设置首页文章显示篇数"></a>设置首页文章显示篇数</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre><code>  npm install --save hexo-generator-index
  npm install --save hexo-generator-archive
  npm install --save hexo-generator-tag
</code></pre><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><pre><code>index_generator:
  per_page: 5

archive_generator:
  per_page: 20
  yearly: true
  monthly: true

tag_generator:
  per_page: 10
</code></pre><h2 id="设置404公益页面"><a href="#设置404公益页面" class="headerlink" title="设置404公益页面"></a>设置404公益页面</h2><p>在<strong>站点目录</strong>的source文件夹下，新建<code>404.html</code>文件，将下面的代码复制进去保存即可。</p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;404 - arao&#39;blog&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;404错误，页面不存在！&quot;&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="github-clone速度慢"><a href="#github-clone速度慢" class="headerlink" title="github clone速度慢"></a>github clone速度慢</h2><pre><code class="shell">git config --global http.postBuffer 524288000
</code></pre>
<h2 id="Hexo-Next的文章目录形式异常"><a href="#Hexo-Next的文章目录形式异常" class="headerlink" title="Hexo Next的文章目录形式异常"></a>Hexo Next的文章目录形式异常</h2><h3 id="反引号问题"><a href="#反引号问题" class="headerlink" title="反引号问题"></a>反引号问题</h3><p>用typora生成文章并传给next，中间需要注意的是代码注释段(反引号)，typora和next解析逻辑不一样，注意去掉反引号前面的空格,可以使toc匹配<br>如果去除反引号和上面的空行，可以使代码段格式和上面内容对齐</p>
<h3 id="Head错位"><a href="#Head错位" class="headerlink" title="Head错位"></a>Head错位</h3><p>比如上一层是H2，内部是H4，就会出现错位。</p>
<h2 id="Hexo-Next的文章不显示内容"><a href="#Hexo-Next的文章不显示内容" class="headerlink" title="Hexo Next的文章不显示内容"></a>Hexo Next的文章不显示内容</h2><p>引用中设置字体，会导致整个文档无法解析。</p>
<h2 id="Hexo-g-无法生成html"><a href="#Hexo-g-无法生成html" class="headerlink" title="Hexo g 无法生成html"></a>Hexo g 无法生成html</h2><p>排查发现对以下解析问题：</p>
<pre><code>`{{{ xxx }}}`
`{{* foo }}`
`{{ }}`
</code></pre><hr>
<p>基本这就是搭建一个github blog需要包括的内容了。当然，最快的方式也许是找一个官方demo直接clone修改配置。</p>
]]></content>
      
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
