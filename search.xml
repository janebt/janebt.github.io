<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Diary_2017.12.21]]></title>
      <url>/2017/12/21/%E6%97%A5%E8%AE%B0/Diary_2017.12.21/</url>
      <content type="html"><![CDATA[<p>12.21，周四，晴</p>
<a id="more"></a>
<p>面试到了尾声，反思自己的不足，大部分是在项目上吃了亏。其实项目不仅仅是web方向，对于一整套的服务器框架也是参与实现并很清楚，然而可能更多的关注点不在上面，也没怎么提及，现在想想其实这块不就是封装层吗。</p>
<p>趁着清晨，简单的回顾了一下项目的前后端分离实践，希望能对以后的工作有帮助。</p>
<p>走出公交车，回顾一下最近面试的感觉，蓦然一种天很蓝我很累世间两种人，一种是我一种是其他人的感受。仿佛我的双肩扛着一根金箍棒，逆着人流往上走。此刻我就是孙悟空，是永远无法成为齐天大圣的孙悟空。</p>
<p><img src="http://t1.aixinxi.net/o_1c1s9m27890a1vs1skpsp2uoda.jpeg-w.jpg" alt=""></p>
<p>你看，那个人好像一条狗哎</p>
<p><img src="http://t1.aixinxi.net/o_1c1s9na3mqn43i5a3lvp1hc2a.jpeg-w.jpg" alt=""></p>
<p>十年前看周星驰大话西游，可以笑的没心没肺，而现在看着看着不知不觉就流泪了，想要救紫霞，就必须要打败牛魔王，想要打败牛魔王，就必须要变成孙悟空，想要变成孙悟空，就必须要忘掉七情六欲，看似简单，难的就是那一转身，正所谓不戴金箍，如何救你，戴了金箍，如何爱你，正如现实生活中，假如一个人不工作，如何供你，其实每一个人以前都是那个无忧无虑的至尊宝，只是随着年龄的增长，不得不戴上紧箍咒，拿起金箍棒，成为孙悟空，从而要去承担起所有的责任，再也回不到从前的至尊宝，《大话西游》的结尾有句话，“你看那个人，好奇怪哟，像一条狗”。像条狗的人 是放弃了人间的男女情欢、无欲无念、兢兢业业走在西天取经路上的至尊宝。他如你我这般，收起了脾气火气不再任性淘气，只为梦想奔波</p>
]]></content>
      
        <categories>
            
            <category> 流水账 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> diary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IPC项目框架研究]]></title>
      <url>/2017/12/21/%E9%A1%B9%E7%9B%AE/IPC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>简单总结一下项目框架的一些实践</p>
<a id="more"></a>
<h2 id="从MVC到前后端分离"><a href="#从MVC到前后端分离" class="headerlink" title="从MVC到前后端分离"></a>从MVC到前后端分离</h2><h3 id="MVC模式的优点与不足"><a href="#MVC模式的优点与不足" class="headerlink" title="MVC模式的优点与不足"></a>MVC模式的优点与不足</h3><p>传统MVC至少有以下三点不足：</p>
<ol>
<li>每次请求必须经过“控制器-&gt;模型-&gt;视图”这个流程，用户才能看到最终的展现的界面，这个过程似乎有些复杂。</li>
<li>实际上视图是依赖于模型的，换句话说，如果没有模型，视图也无法呈现出最终的效果。</li>
<li>渲染视图的过程是在服务端来完成的，最终呈现给浏览器的是带有模型的视图页面，性能无法得到很好的优化。</li>
</ol>
<p>REST前端关注界面展现，后端关注业务逻辑，</p>
<p>虽然REST看起来还是很简单的，实际上我们往往需要提供一个REST框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。</p>
<h3 id="REST的实现"><a href="#REST的实现" class="headerlink" title="REST的实现"></a>REST的实现</h3><p>REST的实现，主要是一个框架搭建的过程</p>
<h4 id="统一请求结构"><a href="#统一请求结构" class="headerlink" title="统一请求结构"></a>统一请求结构</h4><p>对于ajax请求，采用自定义的GET、POST、DELETE、MODIFY、ADD字段进行处理。这边特别要注意MODIFY和ADD字段，这两个字段使用非常频繁，也对其的响应做了完整的封装，顾名思义，如果配置需要增加一个字段或修改一个字段，使用MODIFY和ADD能得到显著的语义化的效果，并且在Control的Lua脚本也会自动对其做一套代码请求格式和内容的审核。比如如果是不可写的值，那么有rw属性标示，对其进行MODIFY操作会直接返回指定错误码。</p>
<h4 id="统一响应结构"><a href="#统一响应结构" class="headerlink" title="统一响应结构"></a>统一响应结构</h4><p>首先，返回的JSON响应结构是统一的，前端可以直接对其做一套模版的解析，直接拿到其中的callback数据。其中，错误吗直接在第一层json中展示，data的json层级按照协议标准（参考通用标准制定）可以得到一个经验化的解析方式。</p>
<h4 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h4><p>在lua中做了序列化和反序列化的操作，收到json会直接判断是否是一个格式正确的json，是否包含上述的五种头，如果包含，进行解包，lua自带序列化和反序列化的函数</p>
<h4 id="统一处理模式"><a href="#统一处理模式" class="headerlink" title="统一处理模式"></a>统一处理模式</h4><p>lua中不是对每个原包做解析处理，这样效率太低，也不利于工业生产。我们的做法是如果是请求静态资源，在服务器端就进行处理，不需要传入lua，如果是动态json请求，那么上述也有说过，根据业务逻辑分为GET、POST、DELETE、MODIFY、ADD，这五种情况可以解决绝大部分的需求，并且符合REST的思想。在lua层收到了这个包，lua直接会走一遍流程，这个流程是一个dispatch的过程，详细来说是进行拆包，根据请求的动作进行分发，每种动作都会有安全策略，同时也会对请求的模块进行自定义安全策略检查，然后分发到处理函数。</p>
<p>处理函数相当于接收A对象，然后返回B对象，其中请求字段的模块和函数都已经具名，所以这块也是被统一处理了，结果就非常简单，只要完成这个函数逻辑就可以了，完成后返回的对象会自动组包返回成json格式</p>
<h4 id="支持参数验证"><a href="#支持参数验证" class="headerlink" title="支持参数验证"></a>支持参数验证</h4><p>这一点在统一处理模式中有提及，有两层处理，一是统一处理，根据请求类型、根据请求报文的type字段可以做统一处理，比如如果是number，会有一个min和max的设定，二是对具体的一些项做特殊处理，</p>
<h4 id="处理异常行为"><a href="#处理异常行为" class="headerlink" title="处理异常行为"></a>处理异常行为</h4><p>如果参数不合法或是返回的格式不符合预期，那么会中断并返回err_code来对应具体的问题，前后端实现一套err_code，并在前端进行了一个翻译的过程。</p>
<h4 id="提供安全机制"><a href="#提供安全机制" class="headerlink" title="提供安全机制"></a>提供安全机制</h4><p>这块内容相对多一点，比如说敏感字段过滤、token防范csrf等。</p>
<p>对于token校验流程：</p>
<ol>
<li>当用户登录成功后，在服务端生成一个token，并将其放入内存中，同时将该token返回到客户端。</li>
<li>在客户端中将返回的token写入cookie中，并且每次请求时都将token随请求头一起发送到服务端。</li>
<li>提供一个AOP切面，用于拦截所有的Controller方法，在切面中判断token的有效性。</li>
<li>当登出时，只需清理掉cookie中的token即可，服务端token可设置过期时间，使其自行移除。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 项目集 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Diary_2017.12.20]]></title>
      <url>/2017/12/20/%E6%97%A5%E8%AE%B0/Diary_2017.12.20/</url>
      <content type="html"><![CDATA[<p>12.20，周三，晴</p>
<a id="more"></a>
<p>短暂的求职之旅，也即将到达尾声。这期间收获的不仅仅是offer，更多的是一种心态的转变与成长。</p>
<p>在大学的日子也学，也不是很努力。在工作的两年努力，也没什么方向。而这一周多的时间，让我收获的是方向的认知和自我驱动力。知道自己要做什么，知道自己怎么做最好，努力去做的更好，也许一些东西都不明确，但我愿意去尝试去学，去珍惜时间。</p>
<p>调整作息，自我驱动，把学习看成一种享受，总结和研究作为一种乐趣，反而视频游戏索然无味，这在以前是完全做不到的，只能说早点撕破伪装，直面淋漓的现实，早点自愈并自我驱动，早点踏上一条承担责任的道路，勇敢的走下去，痛并快乐着。</p>
<p>尝试了几家面试，对自己的不足有了比较清晰的认识。收offer不一定是自己的实力多高，也可能是一半运气的帮助。但我相信如果实力可以凌驾于运气，那么这一定不是什么困难事。接下来就是要把握工作的机会，感恩公司，为了公司和自己的发展，努力的工作与提高，早日达到实力可以凌驾于运气的那一天。</p>
<p>再写点什么吧，说说自己怎么去学技术的一点理解</p>
<p>[看文档] 最快的学习方法。我的想法是不要细读空想看demo，快速通读一遍，有一个直观的理解，然后对比项目的框架平台，看看具体的使用细节，考虑是否可以优化，没用到的文档内容是否有价值，是否可以应用到项目中，能否解决现有的一些问题。 </p>
<p>[读源码] 深入研究的唯一途径。读源码有几大好处，一是可以对底层的实现有个更深刻的理解，知道这东西是这么做的，为什么要这么做，二是对功能有个清晰的认识，知道这个实现应用在这个地方合适，在那个地方不合适，有什么优点或缺陷，三是一种思想的传承与归纳，也许实现细节不同，但是好的思想可以总结和归纳，有利于对这门技术有更深刻的认识。</p>
<p>[做东西] 折腾这件事，其实是必不可少的。学习的一个很大的弊端是，看的文档多，但是做的东西少，知道API，但没有用过，以为自己会了，其实然并卵。折腾其实是一个踩坑的过程，也就一定要做笔记，分析思考总结，记录哪些坑，怎么走最优。这是一个经验化的东西，不怕踩的坑多，就怕一马平川，做完反而没太多收获。</p>
<p>其他一些学习的策略，比如深度和广度，我的理解是：</p>
<p>如果未找到兴趣方向，可以适当开发广度，多一点认识，多挖掘一点兴趣</p>
<p>如果找到了兴趣方向，那么就要适时摒弃广度，把兴趣点挖深，吃透这个点，思想、实现、优化，然后跟踪后续的一个发展，这其实是非常有价值的。挖深的一个好处是，类似的方向的思想是相同的，比如几种设计模式，面向对象的思想，经典的算法，不同语言都有涉及，大牛完全可以举一反三，事半功倍的去学习，而不是广度学习的囫囵吞枣。</p>
<p>反正，加油。</p>
]]></content>
      
        <categories>
            
            <category> 流水账 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> diary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Diary_2017.12.15]]></title>
      <url>/2017/12/16/%E6%97%A5%E8%AE%B0/Diary_2017.12.15/</url>
      <content type="html"><![CDATA[<p>从今天开始，开始记日记。目的是：</p>
<ul>
<li>记录学习方向，总结成长历程，调整战术</li>
<li>一段时间，三天or一周，回顾和总结，调整战略</li>
</ul>
<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> 流水账 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> diary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jquery]]></title>
      <url>/2017/12/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%BB%84%E4%BB%B6/jquery/</url>
      <content type="html"><![CDATA[<p>jquery知识点整理。</p>
<p>jquery ajax没整理。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id=""><a href="#" class="headerlink" title="$()"></a>$()</h2><p>$()函数是JQuery函数的别名</p>
<p>$()函数用于将任何对象包裹成jQuery对象</p>
<h2 id="jQuery入口函数与Js入口函数的区别"><a href="#jQuery入口函数与Js入口函数的区别" class="headerlink" title="jQuery入口函数与Js入口函数的区别"></a>jQuery入口函数与Js入口函数的区别</h2><p>js入口函数指的是：window.onload = function(){};</p>
<p>jQuery入口函数是：$(document).ready()</p>
<table>
<thead>
<tr>
<th>window.onload</th>
<th></th>
<th>$(document).ready()</th>
</tr>
</thead>
<tbody>
<tr>
<td>必须等待网页中所有的内容加载完毕后（包括图片）才能执行</td>
<td>执行时机</td>
<td>网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完</td>
</tr>
<tr>
<td>不能同时编写多个 ，出现多次会存在事件覆盖的问题。</td>
<td>编写个数</td>
<td>能同时编写多个</td>
</tr>
<tr>
<td>无</td>
<td>简化写法</td>
<td>$(document).ready(function(){});可以简写成$(function(){});</td>
</tr>
<tr>
<td>很差</td>
<td>兼容性</td>
<td>好</td>
</tr>
</tbody>
</table>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul>
<li>ID选择器：#</li>
<li>类选择器： .</li>
<li>标签选择器： element</li>
</ul>
<h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><ul>
<li>后代选择器：空格</li>
<li>子代选择器：&gt;</li>
</ul>
<h3 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h3><p>索引号为index：<strong>:eq(index)</strong></p>
<p>索引号为奇数：<strong>:odd</strong></p>
<p>索引号为偶数：<strong>:even</strong></p>
<h2 id="jQuery操作"><a href="#jQuery操作" class="headerlink" title="jQuery操作"></a>jQuery操作</h2><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><p>查找指定元素的所有后代元素（子子孙孙）：find(selector)</p>
<p>查找指定元素的直接子元素（亲儿子元素）：children()</p>
<p>查找所有兄弟元素（不包括自己）：siblings()</p>
<p>查找父元素（亲的）：parent()</p>
<p>查找指定元素的第index个元素，index是索引号，从0开始：eq(index)</p>
<h3 id="选择网页元素"><a href="#选择网页元素" class="headerlink" title="选择网页元素"></a>选择网页元素</h3><pre><code class="javascript">$(&#39;a:first&#39;)//选择网页中第一个a元素  
$(&#39;tr:odd&#39;)//选择表格的奇数行  
$(&#39;#myForm :input&#39;)//选择表单中的input元素  
$(&#39;div:visible&#39;) //选择可见的div元素  
$(&#39;div:gt(2)&#39;)//选择所有的div元素，除了前三个  
$(&#39;div:animated&#39;)//选择当前处于动画状态的div元素
</code></pre>
<h3 id="改变结果集"><a href="#改变结果集" class="headerlink" title="改变结果集"></a>改变结果集</h3><pre><code class="javascript">$(&#39;div&#39;).has(&#39;p&#39;); //选择包含p元素的div元素  
$(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素  
$(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素  
$(&#39;div&#39;).first(); //选择第1个div元素  
$(&#39;div&#39;).eq(5); //选择第6个div元素  
$(&#39;div&#39;).next(&#39;p&#39;); //选择div元素后面的第一个p元素  
$(&#39;div&#39;).parent(); //选择div元素的父元素  
$(&#39;div&#39;).closest(&#39;form&#39;); //选择离div最近的那个form父元素  
$(&#39;div&#39;).children(); //选择div的所有子元素  
$(&#39;div&#39;).siblings(); //选择div的同级元素
</code></pre>
<h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p>.end()：回到最近的一个”破坏性”操作之前。如果之前没有破坏性操作，则返回一个空集。所谓的”破坏性”就是指任何改变所匹配的jQuery元素的操作。</p>
<h3 id="元素的操作：取值和赋值"><a href="#元素的操作：取值和赋值" class="headerlink" title="元素的操作：取值和赋值"></a>元素的操作：取值和赋值</h3><p>常见的取值和赋值函数如下：</p>
<ol>
<li>html() 返回或设置被选元素的内容 (inner HTML)    </li>
<li>text() 取出或设置text内容      </li>
<li><strong>attr()</strong> 取出或设置某个属性的值    </li>
<li>width() 取出或设置某个元素的宽度    </li>
<li>height() 取出或设置某个元素的高度  </li>
<li>val() 取出或设置html内容 取出某个表单元素的值  </li>
<li>css() 设置css样式</li>
</ol>
<p>需要注意的是，如果结果集包含多个元素，那么赋值的时候，将对其中所有的元素赋值；取值的时候，则是只取出第一个元素的值（.text()例外，它取出所有元素的text内容）。</p>
<h3 id="元素的操作：移动"><a href="#元素的操作：移动" class="headerlink" title="元素的操作：移动"></a>元素的操作：移动</h3><ol>
<li>.insertAfter()和.after()：在现存元素的外部，从后面插入元素  </li>
<li>.insertBefore()和.before()：在现存元素的外部，从前面插入元素  </li>
<li>.appendTo()和.append()：在现存元素的内部，从后面插入元素  </li>
<li>.prependTo()和.prepend()  ：在现存元素的内部，从前面插入元素</li>
</ol>
<h3 id="元素的操作：复制、删除和创建"><a href="#元素的操作：复制、删除和创建" class="headerlink" title="元素的操作：复制、删除和创建"></a>元素的操作：复制、删除和创建</h3><p>复制元素使用.clone()</p>
<p>删除元素使用.remove()和.detach()。两者的区别在于，<strong>前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用。</strong></p>
<p>清空元素内容（但是不删除该元素）使用.empty()。</p>
<h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><p> $.trim() 去除字符串两端的空格。<br> $.each() 遍历一个数组或对象。<br> $.inArray() 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。<br> $.grep() 返回数组中符合某种标准的元素。<br> $.extend() 将多个对象，合并到第一个对象。<br> $.makeArray() 将对象转化为数组。<br> $.type() 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。<br> $.isArray() 判断某个参数是否为数组。<br> $.isEmptyObject() 判断某个对象是否为空（不含有任何属性）。<br> $.isFunction() 判断某个参数是否为函数。<br> $.isPlainObject() 判断某个参数是否为用”{}”或”new Object”建立的对象。<br> $.support() 判断浏览器是否支持某个特性。 </p>
<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><p> .blur() 表单元素失去焦点。<br> .change() 表单元素的值发生变化<br> .click() 鼠标单击<br> .dblclick() 鼠标双击<br> .focus() 表单元素获得焦点<br> .focusin() 子元素获得焦点<br> .focusout() 子元素失去焦点<br> .hover() 同时为mouseenter和mouseleave事件指定处理函数<br> .keydown() 按下键盘（长时间按键，只返回一个事件）<br> .keypress() 按下键盘（长时间按键，将返回多个事件）<br> .keyup() 松开键盘<br> .load() 元素加载完毕<br> .mousedown() 按下鼠标<br> .mouseenter() 鼠标进入（进入子元素不触发）<br> .mouseleave() 鼠标离开（离开子元素不触发）<br> .mousemove() 鼠标在元素内部移动<br> .mouseout() 鼠标离开（离开子元素也触发）<br> .mouseover() 鼠标进入（进入子元素也触发）<br> .mouseup() 松开鼠标<br> .ready() DOM加载完成<br> .resize() 浏览器窗口的大小发生改变<br> .scroll() 滚动条的位置发生变化<br> .select() 用户选中文本框中的内容<br> .submit() 用户递交表单<br> .toggle() 根据鼠标点击的次数，依次运行多个函数<br> .unload()  用户离开页面  </p>
<p><strong>特别的</strong></p>
<ul>
<li>.bind()：以上这些事件在jQuery内部，都是.bind()的便捷方式。使用.bind()可以更灵活地控制事件</li>
<li>.one()：只想让事件运行一次</li>
<li>.unbind()：解除事件绑定</li>
</ul>
<p>所有的事件处理函数，都可以接受一个事件对象(event object)作为参数，这个事件对象有一些很有用的属性和方法：</p>
<p>event.pageX 事件发生时，鼠标距离网页左上角的水平距离 　　<br>event.pageY 事件发生时，鼠标距离网页左上角的垂直距离<br>event.type 事件的类型（比如click） 　　<br>event.which 按下了哪一个键 　　<br>event.data在事件对象上绑定数据，然后传入事件处理函数 　　<br>event.target 事件针对的网页元素<br>event.preventDefault() 阻止事件的默认行为（比如点击链接，会自动打开新页面）<br>event.stopPropagation() 停止事件向上层元素冒泡</p>
<p>有两种方法，可以自动触发一个事件。一种是直接使用事件函数，另一种是使用.trigger()或.triggerHandler()。</p>
<pre><code class="javascript">$(&#39;a&#39;).click();
$(&#39;a&#39;).trigger(&#39;click&#39;);
</code></pre>
<h3 id="特殊效果"><a href="#特殊效果" class="headerlink" title="特殊效果"></a>特殊效果</h3><p>.fadeIn() 淡入<br>.fadeOut() 淡出<br>.fadeTo() 调整透明度<br>.hide() 隐藏元素<br>.show() 显示元素<br>.slideDown() 向下展开<br>.slideUp() 向上卷起<br>.slideToggle() 依次展开或卷起某个元素<br>.toggle() 依次展示或隐藏某个元素</p>
<p>除了.show()和.hide()，所有其他特效的默认执行时间都是400ms(毫秒)，但是你可以改变这个设置。</p>
<p>更复杂的特效，可以用.animate()自定义。</p>
<p>.stop()和.delay()用来停止或延缓特效的执行。</p>
<p>$.fx.off如果设置为true，则关闭所有网页特效。</p>
<p>几个常见的筛选选择器：</p>
<p>filter()：筛选出与指定表达式匹配的元素集合。这个方法用于缩小匹配的范围。用逗号分隔多个表达式</p>
<pre><code class="javascript">//保留子元素中不含有ol的元素。
//&lt;p&gt;&lt;ol&gt;&lt;li&gt;Hello&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;&lt;p&gt;How are you?&lt;/p&gt;
$(&quot;p&quot;).filter(function(index) {
 return $(&quot;ol&quot;, this).length == 0;
});
//&lt;p&gt;How are you?&lt;/p&gt;
</code></pre>
<p>silce()：选取一个匹配的子集</p>
<pre><code class="javascript">//选择第一个p元素
//&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;cruel&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;
$(&quot;p&quot;).slice(0, 1).wrapInner(&quot;&lt;b&gt;&lt;/b&gt;&quot;);
//&lt;p&gt;&lt;b&gt;Hello&lt;/b&gt;&lt;/p&gt;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-jQuery对象和DOM对象的相互转换"><a href="#Case1-jQuery对象和DOM对象的相互转换" class="headerlink" title="Case1.jQuery对象和DOM对象的相互转换"></a>Case1.jQuery对象和DOM对象的相互转换</h2><pre><code class="javascript">var btn = document.getElementById(“btnShow”);
var $btn = $(“#btnShow”); // $btn就是一个jQuery对象

//DOM对象转换成jQuery对象
var $btn1 = $(btn);

//jQuery对象转换成DOM对象
var btn1 = $btn[0]; 
var btn2 = $btn.get(0);
</code></pre>
<h2 id="Case2-如何找到所有-HTML-select-标签的选中项？"><a href="#Case2-如何找到所有-HTML-select-标签的选中项？" class="headerlink" title="Case2.如何找到所有 HTML select 标签的选中项？"></a>Case2.如何找到所有 HTML select 标签的选中项？</h2><pre><code class="javascript">$(&#39;[name=NameOfSelectedTag] :selected&#39;)
</code></pre>
<h2 id="Case3-jQuery-里的-each-是什么函数？你是如何使用它的？"><a href="#Case3-jQuery-里的-each-是什么函数？你是如何使用它的？" class="headerlink" title="Case3. jQuery 里的 each() 是什么函数？你是如何使用它的？"></a>Case3. jQuery 里的 each() 是什么函数？你是如何使用它的？</h2><p>each() 函数就像是 Java 里的一个 Iterator，它允许你遍历一个元素集合。你可以传一个函数给 each() 方法，被调用的 jQuery 对象会在其每个元素上执行传入的函数。</p>
<pre><code class="javascript">$(&#39;[name=NameOfSelectedTag] :selected&#39;).each(function(selected) {
    alert($(selected).text());
});
</code></pre>
<h2 id="Case4-this-和-this-关键字在-jQuery-中有何不同？"><a href="#Case4-this-和-this-关键字在-jQuery-中有何不同？" class="headerlink" title="Case4.$(this) 和 this 关键字在 jQuery 中有何不同？"></a>Case4.$(this) 和 this 关键字在 jQuery 中有何不同？</h2><p>$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法</p>
<p>而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。</p>
<h2 id="Case5-你如何使用jQuery来提取一个HTML-标记的属性-例如-链接的href"><a href="#Case5-你如何使用jQuery来提取一个HTML-标记的属性-例如-链接的href" class="headerlink" title="Case5.你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href?"></a>Case5.你如何使用jQuery来提取一个HTML 标记的属性 例如. 链接的href?</h2><pre><code class="javascript">$(&#39;a&#39;).each(function(){
   alert($(this).attr(&#39;href&#39;));
});
</code></pre>
<h2 id="Case6-jQuery中-detach-和-remove-方法的区别是什么"><a href="#Case6-jQuery中-detach-和-remove-方法的区别是什么" class="headerlink" title="Case6.jQuery中 detach() 和 remove() 方法的区别是什么?"></a>Case6.jQuery中 detach() 和 remove() 方法的区别是什么?</h2><p>尽管 detach() 和 remove() 方法都被用来移除一个DOM元素, 两者之间的主要不同在于 detach() 会保持对过去被解除元素的跟踪, 因此它可以被取消解除, 而 remove() 方法则会保持过去被移除对象的引用. </p>
<h2 id="Case7-你如何利用jQuery来向一个元素中添加和移除CSS类"><a href="#Case7-你如何利用jQuery来向一个元素中添加和移除CSS类" class="headerlink" title="Case7.你如何利用jQuery来向一个元素中添加和移除CSS类?"></a>Case7.你如何利用jQuery来向一个元素中添加和移除CSS类?</h2><p>利用 addClass() 和 removeClass() 这两个 jQuery 方法。</p>
<h2 id="Case8-使用-CDN-加载-jQuery-库的主要优势是什么"><a href="#Case8-使用-CDN-加载-jQuery-库的主要优势是什么" class="headerlink" title="Case8.使用 CDN 加载 jQuery 库的主要优势是什么 ?"></a>Case8.使用 CDN 加载 jQuery 库的主要优势是什么 ?</h2><ul>
<li>节省服务器带宽</li>
<li>更快的下载速度</li>
<li>只需要下载一次。如果浏览器已经从同一个CDN下载类相同的 jQuery 版本, 那么它就不会再去下载它一次.</li>
</ul>
<h2 id="Case9-jQuery-get-和-jQuery-ajax-方法之间的区别是什么"><a href="#Case9-jQuery-get-和-jQuery-ajax-方法之间的区别是什么" class="headerlink" title="Case9.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?"></a>Case9.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?</h2><p>ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。get() 方法是一个只获取一些数据的专门化方法。</p>
<h3 id="Case10-要是在一个-jQuery-事件处理程序里返回了-false-会怎样？"><a href="#Case10-要是在一个-jQuery-事件处理程序里返回了-false-会怎样？" class="headerlink" title="Case10. 要是在一个 jQuery 事件处理程序里返回了 false 会怎样？"></a>Case10. 要是在一个 jQuery 事件处理程序里返回了 false 会怎样？</h3><p>通常用于阻止事件向上冒泡。</p>
<h3 id="Case11-哪种方式更高效：document-getElementbyId-“myId”-还是-“-myId”-？"><a href="#Case11-哪种方式更高效：document-getElementbyId-“myId”-还是-“-myId”-？" class="headerlink" title="Case11. 哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？"></a>Case11. 哪种方式更高效：document.getElementbyId(“myId”) 还是 $(“#myId”)？</h3><p>第一种，因为它直接调用了 JavaScript 引擎。</p>
<h2 id="Case12-当CDN上的jQuery文件不可用时，该怎么办？"><a href="#Case12-当CDN上的jQuery文件不可用时，该怎么办？" class="headerlink" title="Case12.当CDN上的jQuery文件不可用时，该怎么办？"></a>Case12.当CDN上的jQuery文件不可用时，该怎么办？</h2><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; language=&quot;Javascript&quot; src=&quot;http://ajax.aspnetcdn.com/ajax/jquery/jquery-1.4.1.min.js &quot;&gt;&lt;/script&gt;

&lt;script type=&#39;text/javascript&#39;&gt;//&lt;![CDATA[
if (typeof jQuery == &#39;undefined&#39;) {
document.write(unescape(&quot;%3Cscript src=&#39;/Script/jquery-1.4.1.min.js&#39; type=&#39;text/javascript&#39; %3E%3C/script%3E&quot;));
}//]]&gt;
&lt;/script&gt;
</code></pre>
<h2 id="Case13-jQuery中的Delegate-函数有什么作用？"><a href="#Case13-jQuery中的Delegate-函数有什么作用？" class="headerlink" title="Case13.jQuery中的Delegate()函数有什么作用？"></a>Case13.jQuery中的Delegate()函数有什么作用？</h2><p>delegate()会在以下两个情况下使用到：</p>
<ol>
<li>如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：</li>
</ol>
<pre><code class="javascript">$(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function(){
    $(this).hide();
});
</code></pre>
<p>2、当元素在当前页面中不可用时，可以使用delegate()</p>
<h2 id="Case14-jQuery编码和解码URL？"><a href="#Case14-jQuery编码和解码URL？" class="headerlink" title="Case14.jQuery编码和解码URL？"></a>Case14.jQuery编码和解码URL？</h2><p>encodeURIComponent(url) and decodeURIComponent(url)</p>
<h3 id="Case15-如何用jQuery禁用浏览器的前进后退按钮？"><a href="#Case15-如何用jQuery禁用浏览器的前进后退按钮？" class="headerlink" title="Case15. 如何用jQuery禁用浏览器的前进后退按钮？"></a>Case15. 如何用jQuery禁用浏览器的前进后退按钮？</h3><pre><code class="javascript">&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;
$(document).ready(function() {
     window.history.forward(1);    // 原理就是产生一个“前进”的动作，以抵消后退功能
     //OR
     window.history.forward(-1);
});
&lt;/script&gt;
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jb51.net/article/85471.htm" target="_blank" rel="external">jQuery基础知识点总结(必看)</a></li>
<li><a href="http://www.jb51.net/article/54745.htm" target="_blank" rel="external">jquery学习总结（超级详细）</a></li>
<li><a href="http://www.cnblogs.com/mehjb/p/6095230.html" target="_blank" rel="external">最常见的 20 个 jQuery 面试问题及答案</a></li>
<li><a href="http://www.cnblogs.com/vanone/p/5257157.html" target="_blank" rel="external">jQuery经典面试题及答案精选</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6-cheatsheet]]></title>
      <url>/2017/12/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%BB%84%E4%BB%B6/ES6%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<p>ES6参考手册。</p>
<a id="more"></a>
<h1 id="es6-cheatsheet"><a href="#es6-cheatsheet" class="headerlink" title="es6-cheatsheet"></a>es6-cheatsheet</h1><p>这是一个 ES2015(ES6) 的Cheatsheet，其中包括提示、小技巧、最佳实践和一些代码片段，帮助你完成日复一日的开发工作。</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><p>[TOC]</p>
<h2 id="var-versus-let-const"><a href="#var-versus-let-const" class="headerlink" title="var versus let / const"></a>var versus let / const</h2><blockquote>
<p>除了 <code>var</code> 以外，我们现在多了两个新的标识符来声明变量的存储，它们就是 <code>let</code> 和 <code>const</code>。<br>不同于 <code>var</code> ，<code>let</code> 和 <code>const</code> 语句不会造成声明提升。<br>关于声明提升，可以看另一篇转发文章<a href="janet.github.io/">javascript变量声明提升(hoisting)</a></p>
</blockquote>
<p>一个 <code>var</code> 的例子:</p>
<pre><code class="javascript">var snack = &#39;Meow Mix&#39;;

function getFood(food) {
    if (food) {
        var snack = &#39;Friskies&#39;;
        return snack;
    }
    return snack;
}

getFood(false); // undefined
</code></pre>
<p>让我们再观察下面语句中，使用 <code>let</code> 替换了 <code>var</code> 后的表现：</p>
<pre><code class="javascript">let snack = &#39;Meow Mix&#39;;

function getFood(food) {
    if (food) {
        let snack = &#39;Friskies&#39;;
        return snack;
    }
    return snack;
}

getFood(false); // &#39;Meow Mix&#39;
</code></pre>
<blockquote>
<p><strong>注意</strong>：<code>let</code> 和 <code>const</code> 是块级作用域语句。所以在语句块以外引用这些变量时，会造成引用错误 <code>ReferenceError</code>。</p>
<p><strong>最佳实践</strong>: 在重构老代码时，<code>var</code> 声明需要格外的注意。在创建一个新项目时，使用 <code>let</code> 声明一个变量，使用 <code>const</code> 来声明一个不可改变的常量。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Replacing-IIFEs-with-Blocks"><a href="#Replacing-IIFEs-with-Blocks" class="headerlink" title="Replacing IIFEs with Blocks"></a>Replacing IIFEs with Blocks</h2><p>我们以往创建一个 <strong>立即执行函数</strong> 时，一般是在函数最外层包裹一层括号。<br>ES6支持块级作用域（更贴近其他语言），我们现在可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现，</p>
<pre><code class="javascript">(function () {
    var food = &#39;Meow Mix&#39;;
}());

console.log(food); // Reference Error
</code></pre>
<p>使用支持块级作用域的ES6的版本：</p>
<pre><code class="javascript">{
    let food = &#39;Meow Mix&#39;;
};

console.log(food); // Reference Error
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h2><blockquote>
<p>this需要总结，请参考xxx</p>
</blockquote>
<p>一些时候，我们在函数嵌套中需要访问上下文中的 <code>this</code>。比如下面的例子：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character; // Cannot read property &#39;name&#39; of undefined
    });
};
</code></pre>
<blockquote>
<p>关于map方法，可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Array.prototype.map()</a></p>
</blockquote>
<p>一种通用的方式是把上下文中的 <code>this</code> 保存在一个变量里：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    var that = this; // Store the context of this
    return arr.map(function (character) {
        return that.name + character;
    });
};
</code></pre>
<p>我们也可以把 <code>this</code> 通过属性传进去：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }, this);
};
</code></pre>
<p>还可以直接使用 <code>bind</code>：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(function (character) {
        return this.name + character;
    }.bind(this));
};
</code></pre>
<p>使用 <strong>箭头函数</strong>，<code>this</code> 的值不用我们再做如上几段代码的特殊处理，直接使用即可。<br>上面的代码可以重写为下面这样：</p>
<pre><code class="javascript">function Person(name) {
    this.name = name;
}

Person.prototype.prefixName = function (arr) {
    return arr.map(character =&gt; this.name + character);
};
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：使用箭头函数，再也不用考虑 <code>this</code> 的问题了。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>在ES6中，标准库也被同样增强了，像字符串对象就新增了 <code>.includes()</code> 和 <code>.repeat()</code> 方法。</p>
<h3 id="includes"><a href="#includes" class="headerlink" title=".includes( )"></a>.includes( )</h3><pre><code class="javascript">var string = &#39;food&#39;;
var substring = &#39;foo&#39;;

console.log(string.indexOf(substring) &gt; -1);
</code></pre>
<p>现在，我们可以使用 <code>.includes()</code> 方法，替代以往判断内容 <code>&gt; -1</code> 的方式。<br><code>.includes()</code> 方法会极简地返回一个布尔值结果。</p>
<pre><code class="javascript">const string = &#39;food&#39;;
const substring = &#39;foo&#39;;

console.log(string.includes(substring)); // true
</code></pre>
<h3 id="repeat"><a href="#repeat" class="headerlink" title=".repeat( )"></a>.repeat( )</h3><pre><code class="javascript">function repeat(string, count) {
    var strings = [];
    while(strings.length &lt; count) {
        strings.push(string);
    }
    return strings.join(&#39;&#39;);
}
</code></pre>
<p>在ES6中，我们可以使用一个极简的方法来实现重复字符：</p>
<pre><code class="javascript">// String.repeat(numberOfRepetitions)
&#39;meow&#39;.repeat(3); // &#39;meowmeowmeow&#39;
</code></pre>
<h3 id="Template-Literals"><a href="#Template-Literals" class="headerlink" title="Template Literals"></a>Template Literals</h3><p>使用 <strong>字符串模板字面量</strong>，我可以在字符串中直接使用特殊字符，而不用转义。</p>
<pre><code class="javascript">var text = &quot;This string contains \&quot;double quotes\&quot; which are escaped.&quot;;
</code></pre>
<pre><code class="javascript">let text = `This string contains &quot;double quotes&quot; which don&#39;t need to be escaped anymore.`;
</code></pre>
<p><strong>字符串模板字面量</strong> 还支持直接插入变量，可以实现字符串与变量的直接连接输出。</p>
<pre><code class="javascript">var name = &#39;Tiger&#39;;
var age = 13;

console.log(&#39;My cat is named &#39; + name + &#39; and is &#39; + age + &#39; years old.&#39;);
</code></pre>
<p>更简单的版本：</p>
<pre><code class="javascript">const name = &#39;Tiger&#39;;
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
</code></pre>
<p>ES5中，我们要这样生成多行文本：</p>
<pre><code class="javascript">var text = (
    &#39;cat\n&#39; +
    &#39;dog\n&#39; +
    &#39;nickelodeon&#39;
);
</code></pre>
<p>或者：</p>
<pre><code class="javascript">var text = [
    &#39;cat&#39;,
    &#39;dog&#39;,
    &#39;nickelodeon&#39;
].join(&#39;\n&#39;);
</code></pre>
<p><strong>字符串模板字面量</strong> 让我们不必特别关注多行字符串中的换行转义符号，直接换行即可：</p>
<pre><code class="javascript">let text = ( `cat
dog
nickelodeon`
);
</code></pre>
<p><strong>字符串模板字面量</strong> 内部可以使用表达式，像这样：</p>
<pre><code class="javascript">let today = new Date();
let text = `The time and date is ${today.toLocaleString()}`;
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p>解构让我们可以使用非常便捷的语法，<strong>直接将数组或者对象中的值直接分别导出到多个变量中</strong>，</p>
<h3 id="Destructuring-Arrays"><a href="#Destructuring-Arrays" class="headerlink" title="Destructuring Arrays"></a>Destructuring Arrays</h3><p><strong>解构数组</strong></p>
<pre><code class="javascript">let [a, b, c, d] = [1, 2, 3, 4];

console.log(a); // 1
console.log(b); // 2
</code></pre>
<h3 id="Destructuring-Objects"><a href="#Destructuring-Objects" class="headerlink" title="Destructuring Objects"></a>Destructuring Objects</h3><p><strong>解构对象</strong></p>
<pre><code class="javascript">let luke = { occupation: &#39;jedi&#39;, father: &#39;anakin&#39; };
let {occupation, father} = luke;

console.log(occupation); // &#39;jedi&#39;
console.log(father); // &#39;anakin&#39;
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>ES6之前，浏览器端的模块化代码，我们使用像<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>这样的库，<br>在 <strong>Node.js</strong> 中，我们则使用 <a href="https://nodejs.org/api/modules.html#modules_module_require_id" target="_blank" rel="external">require</a>。<br>在ES6中，我们现在可以直接使用AMD 和 CommonJS这些模块了。</p>
<h3 id="Exporting-in-CommonJS"><a href="#Exporting-in-CommonJS" class="headerlink" title="Exporting in CommonJS"></a>Exporting in CommonJS</h3><pre><code class="javascript">module.exports = 1;
module.exports = { foo: &#39;bar&#39; };
module.exports = [&#39;foo&#39;, &#39;bar&#39;];
module.exports = function bar () {};
</code></pre>
<h3 id="Exporting-in-ES6"><a href="#Exporting-in-ES6" class="headerlink" title="Exporting in ES6"></a>Exporting in ES6</h3><p>在ES6中，提供了多种设置模块出口的方式，比如我们要导出一个变量，那么使用 <strong>变量名</strong> ：</p>
<pre><code class="javascript">export let name = &#39;David&#39;;
export let age  = 25;
</code></pre>
<p>还可以为对象 <strong>导出一个列表</strong>：</p>
<pre><code class="javascript">function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

export { sumTwo, sumThree };
</code></pre>
<p>我们也可以使用简单的一个 <code>export</code> 关键字来导出一个结果值：</p>
<pre><code class="javascript">export function sumTwo(a, b) {
    return a + b;
}

export function sumThree(a, b, c) {
    return a + b + c;
}
</code></pre>
<p>最后，我们可以 <strong>导出一个默认出口</strong>：</p>
<pre><code class="javascript">function sumTwo(a, b) {
    return a + b;
}

function sumThree(a, b, c) {
    return a + b + c;
}

let api = {
    sumTwo,
    sumThree
};

export default api;

/*
 * 与以下的语句是对等的:
 * export { api as default };
 */
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：总是在模块的 <strong>最后</strong> 使用 <code>export default</code> 方法。<br>它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。<br>更多的是，在大量CommonJS模块中，通用的习惯是设置一个出口值或者出口对象。<br>坚持这个规则，可以让我们的代码更易读，且更方便的联合使用CommonJS和ES6模块。</p>
</blockquote>
<h3 id="Importing-in-ES6"><a href="#Importing-in-ES6" class="headerlink" title="Importing in ES6"></a>Importing in ES6</h3><p>ES6提供了好几种模块的导入方式。我们可以单独引入一个文件：</p>
<pre><code class="javascript">import &#39;underscore&#39;;
</code></pre>
<blockquote>
<p>这里需要注意的是， <strong>整个文件的引入方式会执行该文件内的最上层代码</strong>。</p>
</blockquote>
<p>就像Python一样，我们还可以命名引用：</p>
<pre><code class="javascript">import { sumTwo, sumThree } from &#39;math/addition&#39;;
</code></pre>
<p>我们甚至可以使用 <code>as</code> 给这些模块重命名：</p>
<pre><code class="javascript">import {
    sumTwo as addTwoNumbers,
    sumThree as sumThreeNumbers
} from &#39;math/addition&#39;;
</code></pre>
<p>另外，我们能 <strong>引入所有的东西（原文：import all the things）</strong> （也称为命名空间引入）</p>
<pre><code class="javascript">import * as util from &#39;math/addition&#39;;
</code></pre>
<p>最后，我们能可以从一个模块的众多值中引入一个列表：</p>
<pre><code class="javascript">import * as additionUtil from &#39;math/addtion&#39;;
const { sumTwo, sumThree } = additionUtil;
</code></pre>
<p>像这样引用默认对象：</p>
<pre><code class="javascript">import api from &#39;math/addition&#39;;
// Same as: import { default as api } from &#39;math/addition&#39;;
</code></pre>
<p>我们建议一个模块导出的值应该越简洁越好，不过有时候有必要的话命名引用和默认引用可以混着用。如果一个模块是这样导出的：</p>
<pre><code class="javascript">// foos.js
export { foo as default, foo1, foo2 };
</code></pre>
<p>那我们可以如此导入这个模块的值：</p>
<pre><code class="javaqscript">import foo, { foo1, foo2 } from &#39;foos&#39;;
</code></pre>
<p>我们还可以导入commonjs模块，例如React：</p>
<pre><code class="javascript">import React from &#39;react&#39;;
const { Component, PropTypes } = React;
</code></pre>
<p>更简化版本：</p>
<pre><code class="javascript">import React, { Component, PropTypes } from &#39;react&#39;;
</code></pre>
<blockquote>
<p><strong>注意</strong>：被导出的值是被 <strong>绑定的（原文：bingdings）</strong>，而不是引用。<br>所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h2><p>在ES5中，许多种方法来处理函数的 <strong>参数默认值（default values）</strong>，<strong>参数数量（indefinite arguments）</strong>，<strong>参数命名（named parameters）</strong>。<br>ES6中，我们可以使用非常简洁的语法来处理上面提到的集中情况。</p>
<h3 id="Default-Parameters"><a href="#Default-Parameters" class="headerlink" title="Default Parameters"></a>Default Parameters</h3><pre><code class="javascript">function addTwoNumbers(x, y) {
    x = x || 0;
    y = y || 0;
    return x + y;
}
</code></pre>
<p>ES6中，我们可以简单为函数参数启用默认值：</p>
<pre><code class="javascript">function addTwoNumbers(x=0, y=0) {
    return x + y;
}
</code></pre>
<h3 id="Rest-Parameters"><a href="#Rest-Parameters" class="headerlink" title="Rest Parameters"></a>Rest Parameters</h3><p>ES5中，遇到参数数量不确定时，我们只能如此处理：</p>
<pre><code class="javascript">function logArguments() {
    for (var i=0; i &lt; arguments.length; i++) {
        console.log(arguments[i]);
    }
}
</code></pre>
<p>使用 <strong>rest</strong> 操作符，我们可以给函数传入一个不确定数量的参数列表：</p>
<pre><code class="javascript">function logArguments(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
</code></pre>
<h3 id="Named-Parameters"><a href="#Named-Parameters" class="headerlink" title="Named Parameters"></a>Named Parameters</h3><p>命名函数<br>ES5中，当我们要处理多个 <strong>命名参数</strong> 时，通常会传入一个 <strong>选项对象</strong> 的方式，这种方式被jQuery采用。</p>
<pre><code class="javascript">function initializeCanvas(options) {
    var height = options.height || 600;
    var width  = options.width  || 400;
    var lineStroke = options.lineStroke || &#39;black&#39;;
}
</code></pre>
<p>我们可以利用上面提到的新特性 <strong>解构</strong> ，来完成与上面同样功能的函数：</p>
<pre><code class="javascript">function initializeCanvas(
    { height=600, width=400, lineStroke=&#39;black&#39;}) {
        // ...
    }
    // Use variables height, width, lineStroke here
</code></pre>
<p>如果我们需要把这个参数变为可选的，那么只要把该参数解构为一个空对象就好了：</p>
<pre><code class="javascript">function initializeCanvas(
    { height=600, width=400, lineStroke=&#39;black&#39;} = {}) {
        // ...
    }
</code></pre>
<h3 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h3><p>我们可以利用展开操作符（Spread Operator）来把一组数组的值，当作参数传入：</p>
<pre><code class="javascript">Math.max(...[-1, 100, 9001, -32]); // 9001
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><p>在ES6以前，我们实现一个类的功能的话，需要首先创建一个构造函数，然后扩展这个函数的原型方法，就像这样：</p>
<pre><code class="javascript">function Person(name, age, gender) {
    this.name   = name;
    this.age    = age;
    this.gender = gender;
}

Person.prototype.incrementAge = function () {
    return this.age += 1;
};
</code></pre>
<p>继承父类的子类需要这样：</p>
<pre><code class="javascript">function Personal(name, age, gender, occupation, hobby) {
    Person.call(this, name, age, gender);
    this.occupation = occupation;
    this.hobby = hobby;
}

Personal.prototype = Object.create(Person.prototype);
Personal.prototype.constructor = Personal;
Personal.prototype.incrementAge = function () {
    return Person.prototype.incrementAge.call(this) += 20;
};
</code></pre>
<p>ES6提供了一些语法糖来实现上面的功能，我们可以直接创建一个类：</p>
<pre><code class="javascript">class Person {
    constructor(name, age, gender) {
        this.name   = name;
        this.age    = age;
        this.gender = gender;
    }

    incrementAge() {
      this.age += 1;
    }
}
</code></pre>
<p>继承父类的子类只要简单的使用 <code>extends</code> 关键字就可以了：</p>
<pre><code class="javascript">class Personal extends Person {
    constructor(name, age, gender, occupation, hobby) {
        super(name, age, gender);
        this.occupation = occupation;
        this.hobby = hobby;
    }

    incrementAge() {
        super.incrementAge();
        this.age += 20;
        console.log(this.age);
    }
}
</code></pre>
<blockquote>
<p><strong>最佳实践</strong>：ES6新的类语法把我们从晦涩难懂的实现和原型操作中解救出来，这是个非常适合初学者的功能，而且能让我们写出更干净整洁的代码。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols在ES6版本之前就已经存在了，但现在我们拥有一个公共的接口来直接使用它们。<br>Symbols是不可更改的（immutable）并且唯一的（unique），它可用作任何hash数据类型中的键。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol( )"></a>Symbol( )</h3><p>调用 <code>Symbol()</code> 或者 <code>Symbol(描述文本)</code> 会创建一个唯一的、在全局中不可以访问的Symbol对象。<br>一个 <code>Symbol()</code> 的应用场景是：在自己的项目中使用第三方代码库，且你需要给他们的对象或者命名空间打补丁代码，又不想改动或升级第三方原有代码的时候。<br>例如，如果你想给 <code>React.Component</code> 这个类添加一个 <code>refreshComponent</code> 方法，但又确定不了这个方法会不会在下个版本中加入，你可以这么做：</p>
<pre><code class="javascript">const refreshComponent = Symbol();

React.Component.prototype[refreshComponent] = () =&gt; {
    // do something
}
</code></pre>
<h3 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h3><p>使用 <code>Symbol.for(key)</code> 也是会创建一个不可改变的Symbol对象，但区别于上面的创建方法，这个对象是在全局中可以被访问到的。<br>两次相同的 <code>Symbol.for(key)</code> 调用会返回相同的Symbol实例。</p>
<p><strong>提示</strong>：这并不同于 <code>Symbol(description)</code>。</p>
<pre><code class="javascript">Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;) // false
Symbol.for(&#39;foo&#39;) === Symbol(&#39;foo&#39;) // false
Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;) // true
</code></pre>
<p>Symbols常用的一个使用场景，尤其是使用 <code>Symbol.for(key)</code> 方法，是用于实现代码间的互操作。<br>在你的代码中，通过在包含一些已知接口的第三方库的对象参数中查找Symbol成员，你可以实现这种互操作。<br>例如：</p>
<pre><code class="javascript">function reader(obj) {
    const specialRead = Symbol.for(&#39;specialRead&#39;);
    if (obj[specialRead]) {
        const reader = obj[specialRead]();
        // do something with reader
    } else {
        throw new TypeError(&#39;object cannot be read&#39;);
    }
}
</code></pre>
<p>之后在另一个库中：</p>
<pre><code class="javascript">const specialRead = Symbol.for(&#39;specialRead&#39;);

class SomeReadableType {
    [specialRead]() {
        const reader = createSomeReaderFrom(this);
        return reader;
    }
}
</code></pre>
<blockquote>
<p><strong>注意</strong>：关于Symbol互操作的使用，一个值得一提的例子是<code>Symbol.iterable</code> 。<code>Symbol.iterable</code>存在ES6的所有可枚举对象中：数组（Arrays）、字符串（strings）、生成器（Generators）等等。当它作为一个方法被调用时，它将会返回一个带有枚举接口的对象。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><strong>Maps</strong> 是一个JavaScript中很重要（迫切需要）的数据结构。<br>在ES6之前，我们创建一个 <strong>hash</strong> 通常是使用一个对象：</p>
<pre><code class="javascript">var map = new Object();
map[key1] = &#39;value1&#39;;
map[key2] = &#39;value2&#39;;
</code></pre>
<p>但是，这样的代码无法避免函数被特别的属性名覆盖的意外情况：</p>
<pre><code class="javascript">&gt; getOwnProperty({ hasOwnProperty: &#39;Hah, overwritten&#39;}, &#39;Pwned&#39;);
&gt; TypeError: Property &#39;hasOwnProperty&#39; is not a function
</code></pre>
<p><strong>Maps</strong> 让我们使用 <code>set</code>，<code>get</code> 和 <code>search</code> 操作数据。</p>
<pre><code class="javascript">let map = new Map();
&gt; map.set(&#39;name&#39;, &#39;david&#39;);
&gt; map.get(&#39;name&#39;); // david
&gt; map.has(&#39;name&#39;); // true
</code></pre>
<p>Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。</p>
<pre><code class="javascript">let map = new Map([
    [&#39;name&#39;, &#39;david&#39;],
    [true, &#39;false&#39;],
    [1, &#39;one&#39;],
    [{}, &#39;object&#39;],
    [function () {}, &#39;function&#39;]
]);

for (let key of map.keys()) {
    console.log(typeof key);
    // &gt; string, boolean, number, object, function
}
</code></pre>
<blockquote>
<p><strong>提示</strong>：当使用 <code>map.get()</code> 判断值是否相等时，非基础类型比如一个函数或者对象，将不会正常工作。<br>有鉴于此，还是建议使用字符串，布尔和数字类型的数据类型。</p>
</blockquote>
<p>我们还可以使用 <code>.entries()</code> 方法来遍历整个map对象：</p>
<pre><code class="javascript">for (let [key, value] of map.entries()) {
    console.log(key, value);
}
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="WeakMaps"><a href="#WeakMaps" class="headerlink" title="WeakMaps"></a>WeakMaps</h2><p>在ES5之前的版本，我们为了存储私有数据，有好几种方法。像使用这种下划线命名约定：</p>
<pre><code class="javascript">class Person {
    constructor(age) {
        this._age = age;
    }

    _incrementAge() {
        this._age += 1;
    }
}
</code></pre>
<p>在一个开源项目中，命名规则很难维持得一直很好，这样经常会造成一些困扰。<br>此时，我们可以选择使用WeakMaps来替代Maps来存储我们的数据：</p>
<pre><code class="javascript">let _age = new WeakMap();
class Person {
    constructor(age) {
        _age.set(this, age);
    }

    incrementAge() {
        let age = _age.get(this) + 1;
        _age.set(this, age);
        if (age &gt; 50) {
            console.log(&#39;Midlife crisis&#39;);
        }
    }
}
</code></pre>
<p>使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名，就像下面的例子中的 <code>Reflect.ownKeys()</code>：</p>
<pre><code class="javascript">&gt; const person = new Person(50);
&gt; person.incrementAge(); // &#39;Midlife crisis&#39;
&gt; Reflect.ownKeys(person); // []
</code></pre>
<p>一个使用WeakMaps存储数据更实际的例子，是存储与DOM元素相关联的数据，而这不会对DOM元素本身产生污染：</p>
<pre><code class="javascript">let map = new WeakMap();
let el  = document.getElementById(&#39;someElement&#39;);

// Store a weak reference to the element with a key
map.set(el, &#39;reference&#39;);

// Access the value of the element
let value = map.get(el); // &#39;reference&#39;

// Remove the reference
el.parentNode.removeChild(el);
el = null;

value = map.get(el); // undefined
</code></pre>
<p>上面的例子中，一旦对象被垃圾回收器给销毁了，WeakMaps会自动的把这个对象所对应的键值对数据同时销毁。</p>
<blockquote>
<p><strong>提示</strong>：结合这个例子，再考虑下jQuery是如何实现缓存带有引用的DOM元素这个功能的。使用WeakMaps的话，当被缓存的DOM元素被移除的时，jQuery可以自动释放相应元素的内存。<br>通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常有效的。</p>
</blockquote>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h2><p>Promises让我们把多缩进难看的代码（回调地狱）：</p>
<pre><code class="javascript">func1(function (value1) {
    func2(value1, function (value2) {
        func3(value2, function (value3) {
            func4(value3, function (value4) {
                func5(value4, function (value5) {
                    // Do something with value 5
                });
            });
        });
    });
});
</code></pre>
<p>写成这样：</p>
<pre><code class="javascript">func1(value1)
    .then(func2)
    .then(func3)
    .then(func4)
    .then(func5, value5 =&gt; {
        // Do something with value 5
    });
</code></pre>
<p>在ES6之前，我们使用<a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a> 或者<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a>。现在我们有了原生版本的 Promises：</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt;
    reject(new Error(&#39;Failed to fulfill Promise&#39;)))
        .catch(reason =&gt; console.log(reason));
</code></pre>
<p>这里有两个处理函数，<strong>resolve</strong>（当Promise执行成功完毕时调用的回调函数） 和 <strong>reject</strong> （当Promise执行不接受时调用的回调函数）</p>
<blockquote>
<p><strong>Promises的好处</strong>：大量嵌套错误处理回调函数会使代码变得难以阅读理解。<br>使用Promises，我们可以通过清晰的路径将错误事件让上传递，并且适当地处理它们。<br>此外，Promise处理后的值，无论是解决（resolved）还是拒绝（rejected）的结果值，都是不可改变的。</p>
</blockquote>
<p>下面是一些使用Promises的实际例子：</p>
<pre><code class="javascript">var request = require(&#39;request&#39;);

return new Promise((resolve, reject) =&gt; {
  request.get(url, (error, response, body) =&gt; {
    if (body) {
        resolve(JSON.parse(body));
      } else {
        resolve({});
      }
  });
});
</code></pre>
<p>我们还可以使用 <code>Promise.all()</code> 来 <strong>并行化</strong> 的处理一组异步的操作。</p>
<pre><code class="javascript">let urls = [
  &#39;/api/commits&#39;,
  &#39;/api/issues/opened&#39;,
  &#39;/api/issues/assigned&#39;,
  &#39;/api/issues/completed&#39;,
  &#39;/api/issues/comments&#39;,
  &#39;/api/pullrequests&#39;
];

let promises = urls.map((url) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    $.ajax({ url: url })
      .done((data) =&gt; {
        resolve(data);
      });
  });
});

Promise.all(promises)
  .then((results) =&gt; {
    // Do something with results of all our promises
 });
</code></pre>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><p>就像<a href="https://github.com/DrkSephy/es6-cheatsheet#promises" target="_blank" rel="external">Promises</a>如何让我们避免<a href="http://callbackhell.com/" target="_blank" rel="external">回调地狱</a>一样，Generators也可以使我们的代码扁平化，同时给予我们开发者像开发同步代码一样的感觉来写异步代码。Generators本质上是一种支持的函数，随后返回表达式的值。<br>Generators实际上是支持<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" target="_blank" rel="external">暂停运行</a>，随后根据上一步的返回值再继续运行的一种函数。</p>
<p>下面代码是一个使用generators函数的简单例子：</p>
<pre><code class="javascript">function* sillyGenerator() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
}

var generator = sillyGenerator();
&gt; console.log(generator.next()); // { value: 1, done: false }
&gt; console.log(generator.next()); // { value: 2, done: false }
&gt; console.log(generator.next()); // { value: 3, done: false }
&gt; console.log(generator.next()); // { value: 4, done: false }
</code></pre>
<p>就像上面的例子，当<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" target="_blank" rel="external">next</a>运行时，它会把我们的generator向前“推动”，同时执行新的表达式。<br>我们能利用Generators来像书写同步代码一样书写异步代码。</p>
<pre><code class="javascript">// Hiding asynchronousity with Generators

function request(url) {
    getJSON(url, function(response) {
        generator.next(response);
    });
}
</code></pre>
<p>这里我们写个generator函数将要返回我们的数据：</p>
<pre><code class="javascript">function* getData() {
    var entry1 = yield request(&#39;http://some_api/item1&#39;);
    var data1  = JSON.parse(entry1);
    var entry2 = yield request(&#39;http://some_api/item2&#39;);
    var data2  = JSON.parse(entry2);
}
</code></pre>
<p>借助于 <code>yield</code>，我们可以保证 <code>entry1</code> 确实拿到数据并转换后再赋值给 <code>data1</code>。</p>
<p>当我们使用generators来像书写同步代码一样书写我们的异步代码逻辑时，没有一种清晰简单的方式来处理期间可能会产生的错误或者异常。在这种情况下，我们可以在我们的generator中引入Promises来处理，就像下面这样：</p>
<pre><code class="javascript">function request(url) {
    return new Promise((resolve, reject) =&gt; {
        getJSON(url, resolve);
    });
}
</code></pre>
<p>我们再写一个函数，其中使用 <code>next</code> 来步进我们的generator的同时，再利用我们上面的 <code>request</code> 方法来产生（yield）一个Promise。</p>
<pre><code class="javascript">function iterateGenerator(gen) {
    var generator = gen();
    var ret;
    (function iterate(val) {
        ret = generator.next();
        if(!ret.done) {
            ret.value.then(iterate);
        }
    })();
}
</code></pre>
<p>在Generator中引入了Promises后，我们就可以通过Promise的 <code>.catch</code> 和 <code>reject</code> 来捕捉和处理错误了。<br>使用了我们新版的Generator后，新版的调用就像老版本一样简单可读（译者注：有微调）：</p>
<pre><code class="javascript">iterateGenerator(function* getData() {
    var entry1 = yield request(&#39;http://some_api/item1&#39;);
    var data1  = JSON.parse(entry1);
    var entry2 = yield request(&#39;http://some_api/item2&#39;);
    var data2  = JSON.parse(entry2);
});
</code></pre>
<p>在使用Generator后，我们可以重用我们的老版本代码实现，以此展示了Generator的力量。<br>当使用Generators和Promises后，我们可以像书写同步代码一样书写异步代码的同时优雅地解决了错误处理问题。<br>此后，我们实际上可以开始利用更简单的一种方式了，它就是<a href="https://github.com/DrkSephy/es6-cheatsheet#async-await" target="_blank" rel="external">async-await</a>。</p>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h2><p><code>async await</code> 随着ES2016版本就要发布了，它给我们提供了一种更轻松的、更简单的可以替代的实现上面 Generators 配合 Promises 组合代码的一种编码方式，让我们来看看例子：</p>
<pre><code class="javascript">var request = require(&#39;request&#39;);

function getJSON(url) {
  return new Promise(function(resolve, reject) {
    request(url, function(error, response, body) {
      resolve(body);
    });
  });
}

async function main() {
  var data = await getJSON();
  console.log(data); // NOT undefined!
}

main();
</code></pre>
<p>它们看上去和Generators很像。我（作者）强烈推荐使用 <code>async await</code> 来替代Generators + Promises的写法。<br><a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" target="_blank" rel="external">这里</a>是个很好的学习资源，让我们学习和使用这项ES7中的新功能。</p>
<p><sup><a href="#table-of-contents">(回到目录)</a></sup></p>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>本文介绍闭包</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p><strong>解释1</strong></p>
<p><strong>闭包</strong>是有权限访问其他函数作用域内的变量的一个函数。——《JavaScript高级程序设计》</p>
<p>这句话几个深入的问题：</p>
<ul>
<li>为什么其他非闭包的函数没有权限访问另一个函数的内部作用域</li>
<li>为什么闭包有这个权限</li>
<li>什么是函数作用域</li>
</ul>
<p>全面的回答：</p>
<p>由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域的原因，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>
<p><strong>解释2</strong></p>
<ul>
<li><p>闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。</p>
</li>
<li><p>闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配</p>
</li>
<li>当在一个函数内定义另外一个函数就会产生闭包</li>
</ul>
<p><strong>解释3</strong></p>
<p>官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p>
<p><strong>解释4</strong></p>
<p><strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong></p>
<h2 id="闭包解决了什么"><a href="#闭包解决了什么" class="headerlink" title="闭包解决了什么"></a>闭包解决了什么</h2><p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。——阮一峰的博客《学习Javascript闭包》</p>
<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。开发者不用去写钩子函数来操作上级函数作用域内部的变量了。</p>
<p>总结：</p>
<ul>
<li>使用闭包可以访问函数中的变量。</li>
<li>可以使变量长期保存在内存中，生命周期比较长。</li>
</ul>
<h2 id="闭包有哪些应用场景"><a href="#闭包有哪些应用场景" class="headerlink" title="闭包有哪些应用场景"></a>闭包有哪些应用场景</h2><h3 id="Ans1"><a href="#Ans1" class="headerlink" title="Ans1"></a>Ans1</h3><p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>
<h3 id="Ans2"><a href="#Ans2" class="headerlink" title="Ans2"></a>Ans2</h3><p>比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。</p>
<h4 id="1-匿名自执行函数"><a href="#1-匿名自执行函数" class="headerlink" title="1.匿名自执行函数"></a>1.匿名自执行函数</h4><pre><code class="javascript">(function( window, undefined ) {
    // code
})(window);
</code></pre>
<p><strong>为何要传入window？</strong></p>
<p>这样传入window可将其从全局变量变为局部变量，在函数作用域内可以直接访问到window，就不用将作用域链退回到顶层作用域了。</p>
<p>在压缩代码时，可以对window进行优化。</p>
<p><strong>增加参数undefined？</strong></p>
<p>由于undefined在一些情况下有可能会被重写，为确保在自执行匿名函数里的undefined是”真的undefined”，就需要增加参数undefined。</p>
<h4 id="2-结果缓存"><a href="#2-结果缓存" class="headerlink" title="2.结果缓存"></a>2.结果缓存</h4><p>需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。</p>
<pre><code class="javascript">var CachedSearchBox = (function(){    
    var cache = {},    
       count = [];    
    return {    
       attachSearchBox : function(dsid){    
           if(dsid in cache){//如果结果在缓存中    
              return cache[dsid];//直接返回缓存中的对象    
           }    
           var fsb = new uikit.webctrl.SearchBox(dsid);//新建    
           cache[dsid] = fsb;//更新缓存    
           if(count.length &gt; 100){//保正缓存的大小&lt;=100    
              delete cache[count.shift()];    
           }    
           return fsb;          
       },    

       clearSearchBox : function(dsid){    
           if(dsid in cache){    
              cache[dsid].clearSelection();      
           }    
       }    
    };    
})();    

CachedSearchBox.attachSearchBox(&quot;input&quot;);
</code></pre>
<h4 id="3-封装"><a href="#3-封装" class="headerlink" title="3.封装"></a>3.封装</h4><pre><code class="javascript">var person = function(){    
    //变量作用域为函数内部，外部无法访问    
    var name = &quot;default&quot;;       

    return {    
       getName : function(){    
           return name;    
       },    
       setName : function(newName){    
           name = newName;    
       }    
    }    
}();    

print(person.name);//直接访问，结果为undefined    
print(person.getName());    
person.setName(&quot;abruzzi&quot;);    
print(person.getName());    

得到结果如下：  

undefined  
default  
abruzzi
</code></pre>
<h4 id="4-实现类和继承"><a href="#4-实现类和继承" class="headerlink" title="4.实现类和继承"></a>4.实现类和继承</h4><pre><code class="javascript">function Person(){    
    var name = &quot;default&quot;;       

    return {    
       getName : function(){    
           return name;    
       },    
       setName : function(newName){    
           name = newName;    
       }    
    }    
};   

var p = new Person();
p.setName(&quot;Tom&quot;);
alert(p.getName());

var Jack = function(){};
//继承自Person
Jack.prototype = new Person();
//添加私有方法
Jack.prototype.Say = function(){
    alert(&quot;Hello,my name is Jack&quot;);
};
var j = new Jack();
j.setName(&quot;Jack&quot;);
j.Say();
alert(j.getName());
</code></pre>
<h3 id="Ans3"><a href="#Ans3" class="headerlink" title="Ans3"></a>Ans3</h3><p><strong>Singleton 单件：</strong></p>
<pre><code class="javascript">var singleton = function () {
    var privateVariable;
    function privateFunction(x) {
        ...privateVariable...
    }

    return {
        firstMethod: function (a, b) {
            ...privateVariable...
        },
        secondMethod: function (c) {
            ...privateFunction()...
        }
    };
}();
</code></pre>
<p>这个单件通过闭包来实现。通过闭包完成了私有的成员和方法的封装。匿名主函数返回一个对象。对象包含了两个方法，方法1可以方法私有变量，方法2访问内部私有函数。需要注意的地方是匿名主函数结束的地方的’()’，如果没有这个’()’就不能产生单件。因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用。这个就是利用闭包产生单件的方法。</p>
<h2 id="闭包有哪些问题"><a href="#闭包有哪些问题" class="headerlink" title="闭包有哪些问题"></a>闭包有哪些问题</h2><p><strong>原理比较深奥：</strong>要想完全掌握闭包，一定要清楚函数作用域、内存回收机制、作用域继承等，然而闭包是随处可见的，很可能开发者在不经意间就写出了一个闭包，理解不够深入的话很可能造成运行结果与预期不符。</p>
<p><strong>代码难以维护：</strong>闭包内部是可以缓存上级作用域，而如果闭包又是异步执行的话，一定要清楚上级作用域都发生了什么，而这样就需要对代码的运行逻辑和JS运行机制相当了解才能弄明白究竟发生了什么。</p>
<p><strong>内存泄露</strong>：闭包使用完了后，要立即释放资源，将引用变量指向null。</p>
<p>注：闭包并不会引起内存泄漏，只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，从而导致内存无法进行回收，这是IE的问题。</p>
<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="闭包理解"><a href="#闭包理解" class="headerlink" title="闭包理解"></a>闭包理解</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
</code></pre>
<p>闭包是functional language里面的核心概念。</p>
<p>当出现高阶嵌套函数的时候，编译器会做<code>closure convention闭包变换</code>，核心就是变量不在分配在stack上，而是分配在heap上。</p>
<p>高阶嵌套函数：</p>
<ul>
<li>函数里面有定义的函数，这是嵌套</li>
<li>高阶的原因是，函数可以所谓参数传递和返回，像我们熟悉的C语言。</li>
</ul>
<p>最后一点，n在堆上如何被销毁，这个工作是垃圾收集器负责。当n不在被任何闭包的env引用的时候，会被回收。</p>
<h3 id="ECMAScript闭包模型"><a href="#ECMAScript闭包模型" class="headerlink" title="ECMAScript闭包模型"></a>ECMAScript闭包模型</h3><p>在ECMAscript的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分</p>
<ul>
<li>文法环境（The LexicalEnvironment）</li>
<li>变量环境（The VariableEnvironment）</li>
<li>this绑定</li>
</ul>
<p>文法环境中用于解析函数执行过程使用到的变量标识符。我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。</p>
<p><img src="https://coolshell.cn//wp-content/uploads/2012/03/closure.png" alt=""></p>
<p>变量环境(The VariableEnvironment)和文法环境的作用基本相似，具体的区别请参看ECMAScript的规范文档。</p>
<h3 id="闭包的几种写法和用法"><a href="#闭包的几种写法和用法" class="headerlink" title="闭包的几种写法和用法"></a>闭包的几种写法和用法</h3><pre><code class="javascript">//第1种写法  
//只是给函数添加一些属性
function Circle(r) {  
      this.r = r;  
}  
Circle.PI = 3.14159;  
Circle.prototype.area = function() {  
  return Circle.PI * this.r * this.r;  
}  

var c = new Circle(1.0);     
alert(c.area()); 


//第2种写法
//声明一个变量，将一个函数当作值赋给变量。常用
var Circle = function() {  
   var obj = new Object();  
   obj.PI = 3.14159;  

   obj.area = function( r ) {  
       return this.PI * r * r;  
   }  
   return obj;  
}  

var c = new Circle();  
alert( c.area( 1.0 ) );  


//第3种写法  
//new 一个对象，然后给对象添加属性和方法。
var Circle = new Object();  
Circle.PI = 3.14159;  
Circle.Area = function( r ) {  
       return this.PI * r * r;  
}  

alert( Circle.Area( 1.0 ) );  


//第4种写法  
//这种方法使用较多，也最为方便。var obj = {}就是声明一个空的对象。
var Circle={  
   &quot;PI&quot;:3.14159,  
     &quot;area&quot;:function(r){  
      return this.PI * r * r;  
    }  
};  
alert( Circle.area(1.0) );  


//第5种写法  
var Circle = new Function(&quot;this.PI = 3.14159;this.area = function( r ) {return r*r*this.PI;}&quot;);  

alert( (new Circle()).area(1.0) );
</code></pre>
<p>关于Prototype：</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var dom = function(){

};

dom.Show = function(){
  alert(&quot;Show Message&quot;);
};

dom.prototype.Display = function(){
  alert(&quot;Property Message&quot;);
};

dom.Display(); //error
dom.Show();  
var d = new dom();s
d.Display();
d.Show(); //error
</code></pre>
<p><strong>1、不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！</strong><br><strong>2、使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var html = {
        Name:&#39;Object&#39;,
        Success:function(){
            this.Say = function(){
                    alert(&quot;Hello,world&quot;);
            };
            alert(&quot;Obj Success&quot;);
        }
    };
</code></pre>
<p>怎么访问Success方法中的Say方法:</p>
<pre><code class="javascript">var s = new html.Success();
s.Say();

//还可以写到外面
html.Success.prototype.Show = function(){
    alert(&quot;HaHa&quot;);
};
var s = new html.Success();
s.Show();
</code></pre>
<h3 id="闭包的样列"><a href="#闭包的样列" class="headerlink" title="闭包的样列"></a>闭包的样列</h3><h4 id="1-闭包中局部变量是引用而非拷贝"><a href="#1-闭包中局部变量是引用而非拷贝" class="headerlink" title="1. 闭包中局部变量是引用而非拷贝"></a>1. 闭包中局部变量是引用而非拷贝</h4><h4 id="2-多个函数绑定同一个闭包，因为他们定义在同一个函数内。"><a href="#2-多个函数绑定同一个闭包，因为他们定义在同一个函数内。" class="headerlink" title="2.多个函数绑定同一个闭包，因为他们定义在同一个函数内。"></a>2.多个函数绑定同一个闭包，因为他们定义在同一个函数内。</h4><pre><code class="javascript">function setupSomeGlobals() {
    // Local variable that ends up within closure
    var num = 666;
    // Store some references to functions as global variables
    gAlertNumber = function() { alert(num); }
    gIncreaseNumber = function() { num++; }
    gSetNumber = function(x) { num = x; }
}
setupSomeGlobals(); // 为三个全局变量赋值
gAlertNumber(); //666
gIncreaseNumber();
gAlertNumber(); // 667
gSetNumber(12);//
gAlertNumber();//12
</code></pre>
<h4 id="3-当在一个循环中赋值函数时，这些函数将绑定同样的闭包"><a href="#3-当在一个循环中赋值函数时，这些函数将绑定同样的闭包" class="headerlink" title="3.当在一个循环中赋值函数时，这些函数将绑定同样的闭包"></a>3.当在一个循环中赋值函数时，这些函数将绑定同样的闭包</h4><pre><code class="javascript">function buildList(list) {
    var result = [];
    for (var i = 0; i &lt; list.length; i++) {
        var item = &#39;item&#39; + list[i];
        result.push( function() {alert(item + &#39; &#39; + list[i])} );
    }
    return result;
}

function testList() {
    var fnlist = buildList([1,2,3]);
    // using j only to help prevent confusion - could use i
    for (var j = 0; j &lt; fnlist.length; j++) {
        fnlist[j]();
    }
}
</code></pre>
<p>testList的执行结果是弹出item3 undefined窗口三次，因为这三个函数绑定了同一个闭包，而且item的值为最后计算的结果，但是当i跳出循环时i值为4，所以list[4]的结果为undefined.</p>
<h4 id="4-外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后"><a href="#4-外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后" class="headerlink" title="4.外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后"></a>4.外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后</h4><pre><code class="javascript">function sayAlice() {
    var sayAlert = function() { alert(alice); }
    // Local variable that ends up within closure
    var alice = &#39;Hello Alice&#39;;
    return sayAlert;
}
var helloAlice=sayAlice();
helloAlice();
</code></pre>
<h4 id="5-每次函数调用的时候创建一个新的闭包"><a href="#5-每次函数调用的时候创建一个新的闭包" class="headerlink" title="5.每次函数调用的时候创建一个新的闭包"></a>5.每次函数调用的时候创建一个新的闭包</h4><pre><code class="javascript">function newClosure(someNum, someRef) {
    // Local variables that end up within closure
    var num = someNum;
    var anArray = [1,2,3];
    var ref = someRef;
    return function(x) {
        num += x;
        anArray.push(num);
        alert(&#39;num: &#39; + num +
        &#39;\nanArray &#39; + anArray.toString() +
        &#39;\nref.someVar &#39; + ref.someVar);
    }
}
closure1=newClosure(40,{someVar:&#39;closure 1&#39;});
closure2=newClosure(1000,{someVar:&#39;closure 2&#39;});

closure1(5); // num:45 anArray[1,2,3,45] ref:&#39;someVar closure1&#39;
closure2(-10);// num:990 anArray[1,2,3,990] ref:&#39;someVar closure2&#39;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="大部分人都会做错的经典JS闭包面试题"><a href="#大部分人都会做错的经典JS闭包面试题" class="headerlink" title="大部分人都会做错的经典JS闭包面试题"></a><a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a></h2><pre><code class="javascript">function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1
//问:三行a,b,c的输出分别是什么？
</code></pre>
<h3 id="JS中有几种函数"><a href="#JS中有几种函数" class="headerlink" title="JS中有几种函数"></a>JS中有几种函数</h3><p>在JS中函数可以分为两种，<strong>具名函数（命名函数）</strong>和<strong>匿名函数</strong>。区分这两种函数的方法非常简单，可以通过输出 fn.name 来判断，有name的就是具名函数，没有name的就是匿名函数</p>
<h3 id="创建函数的几种方式"><a href="#创建函数的几种方式" class="headerlink" title="创建函数的几种方式"></a>创建函数的几种方式</h3><h4 id="1-声明函数"><a href="#1-声明函数" class="headerlink" title="1.声明函数"></a>1.声明函数</h4><h4 id="2-创建匿名函数表达式"><a href="#2-创建匿名函数表达式" class="headerlink" title="2.创建匿名函数表达式"></a>2.创建匿名函数表达式</h4><pre><code class="javascript">var fn1=function (){}
</code></pre>
<h4 id="3-创建具名函数表达式"><a href="#3-创建具名函数表达式" class="headerlink" title="3.创建具名函数表达式"></a>3.创建具名函数表达式</h4><pre><code class="javascript">var fn1=function xxcanghai(){};
</code></pre>
<blockquote>
<p>注意：具名函数表达式的函数名只能在创建函数内部使用(xxcanghai)</p>
<p>注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</p>
</blockquote>
<h4 id="4-Function构造函数"><a href="#4-Function构造函数" class="headerlink" title="4.Function构造函数"></a>4.Function构造函数</h4><p>可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是<strong>匿名函数</strong>。</p>
<pre><code class="javascript">Function(&quot;alert(1)&quot;)
</code></pre>
<h4 id="5-自执行函数"><a href="#5-自执行函数" class="headerlink" title="5.自执行函数"></a>5.自执行函数</h4><pre><code class="javascript">(function(){alert(1);})();
(function fn1(){alert(1);})();
</code></pre>
<p>自执行函数属于上述的“函数表达式”，规则相同</p>
<h4 id="6-其他创建函数的方法"><a href="#6-其他创建函数的方法" class="headerlink" title="6.其他创建函数的方法"></a>6.其他创建函数的方法</h4><p>采用 eval ， setTimeout ， setInterval 等非常用方法</p>
<h3 id="三个fun函数的关系是什么？"><a href="#三个fun函数的关系是什么？" class="headerlink" title="三个fun函数的关系是什么？"></a>三个fun函数的关系是什么？</h3><p>第一个fun函数，属于标准具名函数声明，是<strong>新创建</strong>的函数，他的返回值是一个对象字面量表达式，属于一个新的object。</p>
<p>fun这个属性中存放的是一个<strong>新创建</strong>匿名函数表达式。</p>
<blockquote>
<p>注意：所有<strong>声明的匿名函数都是一个新函数。</strong></p>
</blockquote>
<h3 id="函数作用域链的问题"><a href="#函数作用域链的问题" class="headerlink" title="函数作用域链的问题"></a>函数作用域链的问题</h3><p>使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。</p>
<p>原因也非常简单，因为<strong>函数作用域链</strong>的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。</p>
<p>所以综上所述，可以得知，<strong>最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数</strong>。</p>
<h3 id="到底在调用哪个函数？"><a href="#到底在调用哪个函数？" class="headerlink" title="到底在调用哪个函数？"></a>到底在调用哪个函数？</h3><p><strong>1、第一行a</strong></p>
<p>第一个fun(0)是在调用<strong>第一层fun函数</strong>。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：第后面几个fun(1),fun(2),fun(3),函数都是在调用<strong>第二层fun函数</strong>。</p>
<p>在第一次调用fun(0)时，o为undefined；</p>
<p>第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，所以内部调用第一层的fun(2,0);所以o为0</p>
<p>第四次同理；</p>
<p><strong>2、第二行b</strong></p>
<p>先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，后面几个也是调用的第二层fun函数。</p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是<strong>第二次执行的返回对象</strong>。而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；</p>
<p>第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；</p>
<p><strong>3、第三行c</strong></p>
<p>在第一次调用第一层fun(0)时，o为undefined；</p>
<p>第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，并在内部调用第一层fun函数fun(1,0);所以o为0；</p>
<p>第三次调用 .fun(2)时m为2，此时fun闭包的是第二次调用的n=1，即m=2，n=1，并在内部调用第一层fun函数fun(2,1);所以o为1；</p>
<p>第四次.fun(3)时同理，但依然是调用的第二次的返回值，遂最终调用第一层fun函数fun(3,1)，所以o还为1</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/29157822" target="_blank" rel="external">当面试官问你闭包时，他究竟想听到些什么？</a></li>
<li><a href="https://segmentfault.com/q/1010000002880935" target="_blank" rel="external">javascript关于闭包的面试题</a></li>
<li><a href="http://blog.csdn.net/chelen_jak/article/details/50568911" target="_blank" rel="external">理解 Javascript 的闭包 （例子举得很好）</a></li>
<li><a href="http://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="external">全面理解Javascript闭包和闭包的几种写法及用途</a></li>
<li><a href="http://www.cnblogs.com/xxcanghai/p/4991870.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>本文介绍面向对象的</p>
<a id="more"></a>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实作用域很简单，搞清楚以下几点：</p>
<h2 id="1-函数作用域"><a href="#1-函数作用域" class="headerlink" title="1. 函数作用域"></a>1. 函数作用域</h2><p>js没有块级作用域（你可以自己闭包或其他方法实现），只有函数级作用域，<strong>函数外面的变量函数里面可以找到，函数里面的变量外面找不到</strong>。</p>
<h2 id="2-变量声明提升-Hoisting"><a href="#2-变量声明提升-Hoisting" class="headerlink" title="2. 变量声明提升(Hoisting)"></a>2. 变量声明提升(Hoisting)</h2><p>由于函数作用域的特性，局部变量在整个函数体始终是由定义的。<strong>变量声明”提前“到函数体顶部，同时变量初始化还在原来位置。</strong></p>
<p>这意味着 <strong><code>var</code> 表达式和 <code>function</code> 声明</strong>都将会被提升到当前作用域的顶部。</p>
<p>在 Nettuts+ 网站有一篇介绍 hoisting 的<a href="http://net.tutsplus.com/tutorials/javascript-ajax/quick-tip-javascript-hoisting-explained/" target="_blank" rel="external">文章</a></p>
<h2 id="3-变量就近查找"><a href="#3-变量就近查找" class="headerlink" title="3. 变量就近查找"></a>3. 变量就近查找</h2><p>每次引用一个变量，<strong>JavaScript 会向上遍历整个作用域直到找到这个变量为止。</strong><br>如果到达全局作用域但是这个变量仍未找到，则会抛出 <code>ReferenceError</code> 异常。这是一个预解析的过程。</p>
<h2 id="4-参数"><a href="#4-参数" class="headerlink" title="4. 参数"></a>4. 参数</h2><p><strong>当参数跟局部变量重名时，优先级是等同的。</strong></p>
<h2 id="5-变量作用域"><a href="#5-变量作用域" class="headerlink" title="5. 变量作用域"></a>5. 变量作用域</h2><p>当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说无法通过delete运算符删除</p>
<pre><code class="javascript">var name=1    -&gt;不可删除
sex=”girl“         -&gt;可删除
this.age=22    -&gt;可删除
</code></pre>
<h2 id="6-名称解析顺序"><a href="#6-名称解析顺序" class="headerlink" title="6. 名称解析顺序"></a>6. 名称解析顺序</h2><p>比如，当访问函数内的 <code>foo</code> 变量时，JavaScript 会按照下面顺序查找：</p>
<ol>
<li>当前作用域内是否有 <code>var foo</code> 的定义。</li>
<li>函数形式参数是否有使用 <code>foo</code> 名称的。</li>
<li>函数自身是否叫做 <code>foo</code>。</li>
<li>回溯到上一级作用域，然后从 <strong>#1</strong> 重新开始。</li>
</ol>
<blockquote>
<p><strong>注意:</strong> 自定义 <code>arguments</code> 参数将会阻止原生的 <code>arguments</code> 对象的创建。</p>
</blockquote>
<h2 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h2><p>只有一个全局作用域导致的常见错误是命名冲突。在 JavaScript中，这可以通过 <em>匿名包装器</em> 轻松解决。</p>
<pre><code class="javascript">(function() {
    // 函数创建一个命名空间

    window.foo = function() {
        // 对外公开的函数，创建了闭包
    };

})(); // 立即执行此匿名函数
</code></pre>
<p>匿名函数被认为是表达式；因此为了可调用性，它们首先会被执行。</p>
<pre><code class="javascript">( // 小括号内的函数首先被执行
function() {}
) // 并且返回函数对象
() // 调用上面的执行结果，也就是函数对象
</code></pre>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。</p>
<pre><code class="javascript">// 另外两种方式
+function(){}();
(function(){}());
</code></pre>
<p>推荐使用<em>匿名包装器</em>（<strong>译者注：</strong>也就是自执行的匿名函数）来创建命名空间。</p>
<h2 id="8-作用域链"><a href="#8-作用域链" class="headerlink" title="8. 作用域链"></a>8. 作用域链</h2><p>函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个<strong>内部属性是[[Scope]]</strong>，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p>
<p>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。</p>
<p>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</p>
<p>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。</p>
<h2 id="9-改变作用域链"><a href="#9-改变作用域链" class="headerlink" title="9. 改变作用域链"></a>9. 改变作用域链</h2><p>一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。</p>
<p>with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。with语句是对象的快捷应用方式，用来避免书写重复代码。实际上会产生性能问题。在程序中应避免使用with语句</p>
<p>当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理。</p>
<h2 id="10-作用域链和代码优化"><a href="#10-作用域链和代码优化" class="headerlink" title="10.作用域链和代码优化"></a>10.作用域链和代码优化</h2><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。<strong>一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</strong></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-函数作用域"><a href="#Case1-函数作用域" class="headerlink" title="Case1.函数作用域"></a>Case1.函数作用域</h2><pre><code class="javascript">var a=10; 
function aaa(){ 
 alert(a);
};            
function bbb(){
var a=20;
aaa();
}
bbb(); //结果为10，因为aaa()函数不能访问到bbb()里面的局部变量，所以访问到的是a=10,这个全局变量。
</code></pre>
<h2 id="Case2-函数声明提升"><a href="#Case2-函数声明提升" class="headerlink" title="Case2.函数声明提升"></a>Case2.函数声明提升</h2><pre><code class="javascript">var scope=&quot;global&quot;;  
function t(){  
    console.log(scope);      //undefined
    var scope=&quot;local&quot;  
    console.log(scope);      //local
}  
t();
</code></pre>
<h2 id="Case3-函数作用域"><a href="#Case3-函数作用域" class="headerlink" title="Case3.函数作用域"></a>Case3.函数作用域</h2><pre><code class="javascript">&lt;html&gt;  
&lt;head&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
function buttonInit(){  
    for(var i=1;i&lt;4;i++){  
        var b=document.getElementById(&quot;button&quot;+i);  
        b.addEventListener(&quot;click&quot;,function(){ alert(&quot;Button&quot;+i);},false);  
    }  
}  
window.onload=buttonInit;  
&lt;/script&gt;  
&lt;/head&gt;  
&lt;body&gt;  
&lt;button id=&quot;button1&quot;&gt;Button1&lt;/button&gt;  
&lt;button id=&quot;button2&quot;&gt;Button2&lt;/button&gt;  
&lt;button id=&quot;button3&quot;&gt;Button3&lt;/button&gt;  
&lt;/body&gt;  
&lt;/html&gt;
</code></pre>
<p>三个按钮都是弹出：”Button4”。当注册事件结束后，i的值为4，当点击按钮时，事件函数即function(){ alert(“Button”+i);}这个匿名函数中没有i,根据作用域链，所以到buttonInit函数中找，此时i的值为4，</p>
<h2 id="Case4-if-表达式"><a href="#Case4-if-表达式" class="headerlink" title="Case4.if 表达式"></a>Case4.<code>if</code> 表达式</h2><p>没有块级作用域不仅导致 <code>var</code> 表达式被从循环内移到外部，而且使一些 <code>if</code> 表达式更难看懂。</p>
<pre><code class="javascript">// 检查 SomeImportantThing 是否已经被初始化
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>
<h2 id="Case5-with语句"><a href="#Case5-with语句" class="headerlink" title="Case5.with语句"></a>Case5.with语句</h2><pre><code class="javascript">person={name:&quot;yhb&quot;,age:22,height:175,wife:{name:&quot;lwy&quot;,age:21}};  
with(person.wife){  
    console.log(name);  
}
</code></pre>
<h2 id="Case6-作用域链流程"><a href="#Case6-作用域链流程" class="headerlink" title="Case6.作用域链流程"></a>Case6.作用域链流程</h2><pre><code class="javascript">function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}
</code></pre>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414435366.jpg" alt=""></p>
<p>函数add的作用域将会在执行时用到。例如执行如下代码：<code>var</code> <code>total = add(5,10);</code></p>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414444843.jpg" alt=""></p>
<h2 id="Case7-作用域链和代码优化"><a href="#Case7-作用域链和代码优化" class="headerlink" title="Case7.作用域链和代码优化"></a>Case7.作用域链和代码优化</h2><pre><code class="javascript">function changeColor(){
    document.getElementById(&quot;btnChange&quot;).onclick=function(){
        document.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;
    };
}
</code></pre>
<p>这段代码可以重写如下：</p>
<pre><code class="javascript">function changeColor(){
    var doc=document;
    doc.getElementById(&quot;btnChange&quot;).onclick=function(){
        doc.getElementById(&quot;targetCanvas&quot;).style.backgroundColor=&quot;red&quot;;
    };
}
</code></pre>
<h2 id="Case8-改变作用域链"><a href="#Case8-改变作用域链" class="headerlink" title="Case8.改变作用域链"></a>Case8.改变作用域链</h2><p><strong>with</strong></p>
<pre><code class="javascript">function initUI(){
    with(document){
        var bd=body,
            links=getElementsByTagName(&quot;a&quot;),
            i=0,
            len=links.length;
        while(i &lt; len){
            update(links[i++]);
        }
        getElementById(&quot;btnInit&quot;).onclick=function(){
            doSomething();
        };
    }
}
</code></pre>
<p>当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。如下图所示：</p>
<p><img src="http://pic002.cnblogs.com/images/2011/36987/2011090414454524.jpg" alt=""></p>
<p><strong>catch</strong></p>
<pre><code class="javascript">try{
    doSomething();
}catch(ex){
    alert(ex.message); //作用域链在此处改变
}
</code></pre>
<p>一个很好的模式是将错误委托给一个函数处理，例如：</p>
<pre><code class="javascript">try{
    doSomething();
}catch(ex){
    handleError(ex); //委托给处理器方法
}
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/yueguanghaidao/article/details/9568071" target="_blank" rel="external">Js作用域与作用域链详解</a></li>
<li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="external">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></li>
<li><a href="https://segmentfault.com/a/1190000000736812" target="_blank" rel="external">js作用域与命名空间</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6]]></title>
      <url>/2017/11/04/%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6%E4%B8%8E%E7%BB%84%E4%BB%B6/es6/</url>
      <content type="html"><![CDATA[<p>ES6知识点整理。</p>
<p>ES6给我的感觉主要是一个简化的工具，一是将作用域、继承、原型这些JS比较难理解的概念做抽象，二是对对象、数组这些不太方便使用的方法增加方法，三是对函数模型做简化，默认值、Rest这些，四是对模块交互上做简化，比如Modules。有点C向C++过渡的意思。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h2><p><code>let</code> 和 <code>const</code> 语句不会造成声明提升。会报错ReferenceError</p>
<p><code>let</code> 和 <code>const</code> 是块级作用域语句。</p>
<p>使用 <code>let</code> 声明一个变量，使用 <code>const</code> 来声明一个不可改变的常量。</p>
<h2 id="块级立即执行函数"><a href="#块级立即执行函数" class="headerlink" title="块级立即执行函数"></a>块级立即执行函数</h2><p>ES6支持块级作用域，可以通过创建一个代码块（Block）来实现，不必通过创建一个函数来实现</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>一些时候，我们在函数嵌套中需要访问上下文中的 <code>this</code>。</p>
<ul>
<li>一种通用的方式是把上下文中的 <code>this</code> 保存在一个变量里</li>
<li>也可以把 <code>this</code> 通过属性传进去</li>
<li>还可以直接使用 <code>bind</code></li>
<li>使用 <strong>箭头函数</strong></li>
</ul>
<h3 id="箭头函数需要注意的地方"><a href="#箭头函数需要注意的地方" class="headerlink" title="箭头函数需要注意的地方"></a>箭头函数需要注意的地方</h3><p>当要求动态上下文的时候，就不能够使用箭头函数。也就是this的固定化</p>
<ol>
<li>在使用=&gt;定义函数的时候，<strong>this的指向是定义时所在的对象</strong>，而不是使用时所在的对象</li>
<li>不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误</li>
<li>不能够使用arguments对象</li>
<li>不能使用yield命令</li>
</ol>
<h2 id="字符串拓展"><a href="#字符串拓展" class="headerlink" title="字符串拓展"></a>字符串拓展</h2><h3 id="includes"><a href="#includes" class="headerlink" title=".includes( )"></a>.includes( )</h3><p>替代以往判断内容<code>.indexOf(xxx) &gt; -1</code> 的方式。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title=".repeat( )"></a>.repeat( )</h3><p>实现重复字符：</p>
<pre><code class="javascript">&#39;meow&#39;.repeat(3); // &#39;meowmeowmeow&#39;
</code></pre>
<h3 id="contains"><a href="#contains" class="headerlink" title=".contains()"></a>.contains()</h3><p>返回布尔值，表示是否找到了参数字符串</p>
<h3 id="startsWith"><a href="#startsWith" class="headerlink" title=".startsWith()"></a>.startsWith()</h3><p>返回布尔值，表示参数字符串是否在源字符串的头部</p>
<h3 id="endsWith"><a href="#endsWith" class="headerlink" title=".endsWith()"></a>.endsWith()</h3><p>返回布尔值，表示参数字符串是否在源字符串的尾部</p>
<h3 id="字符串模板字面量"><a href="#字符串模板字面量" class="headerlink" title="字符串模板字面量"></a>字符串模板字面量</h3><ul>
<li>在字符串中直接使用特殊字符，而不用转义。</li>
<li>支持直接插入变量</li>
<li>直接换行</li>
<li>内部可以使用表达式</li>
</ul>
<pre><code class="javascript">let text = ( `cat
    dog
    nickelodeon`
);
string${varible}string
</code></pre>
<h2 id="数组的拓展"><a href="#数组的拓展" class="headerlink" title="数组的拓展"></a>数组的拓展</h2><p><strong>Array.from()用于将两类对象转为真正的数组：</strong>类似数组的对象（array-like object）和可遍历（iterable）的对象，其中包括ES6新增的Set和Map结构。</p>
<p><strong>【重点】find()和findIndex()</strong>，意义较大，如下：</p>
<pre><code class="javascript">[1,5,10,15].find( function(value, index, arr){ return value &gt; 9; } ); // 返回10
[1,5,10,15].findIndex( function(value, index, arr){ return value &gt; 9; } ); // 返回2
</code></pre>
<p><strong>fill()使用给定值，填充一个数组：</strong></p>
<pre><code class="javascript">newArray(3).fill(7)
</code></pre>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p><strong>Maps</strong> 是一个JavaScript中很重要（迫切需要）的数据结构。</p>
<p>Maps让我们使用 <code>set</code>，<code>get</code> 和 <code>search</code> 操作数据。</p>
<p>Maps最强大的地方在于我们不必只能使用字符串来做key了，现在可以使用任何类型来当作key，而且key不会被强制类型转换为字符串。</p>
<pre><code class="javascript">let map = new Map();
&gt; map.set(&#39;name&#39;, &#39;david&#39;);
&gt; map.get(&#39;name&#39;); // david
&gt; map.has(&#39;name&#39;); // true
</code></pre>
<p><strong>遍历：</strong></p>
<pre><code class="javascript">for (let key of map.keys()) {
for (let [key, value] of map.entries()) {
</code></pre>
<p><strong>ES6提供三个新的方法：entries()，keys()和values()用于遍历数组</strong>。</p>
<p>可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="Object.setPrototypeOf()，Object.getPrototypeOf()"></a>Object.setPrototypeOf()，Object.getPrototypeOf()</h3><h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of循环可以代替数组实例的forEach方法</p>
<p><strong>和for…in的区别</strong></p>
<ul>
<li>for…of可以遍历键与值，for…in只能遍历键名</li>
<li>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名</li>
</ul>
<h2 id="WeakMaps"><a href="#WeakMaps" class="headerlink" title="WeakMaps"></a>WeakMaps</h2><p>使用WeakMaps来保存我们私有数据的理由之一是不会暴露出属性名</p>
<p>通常情况下，在涉及DOM元素存储和缓存的情况下，使用WeakMaps是非常有效的。</p>
<h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><pre><code class="javascript">let [a, b, c, d] = [1, 2, 3, 4];    //数组
let luke = { occupation: &#39;jedi&#39;, father: &#39;anakin&#39; };    //对象
let {occupation, father} = luke;
</code></pre>
<p>该特性更多的用处是在遍历Map结构的时候，可以如下：</p>
<pre><code class="javascript">for( let [ key,value] of map ) 
{ console.log ( key +&#39;:&#39;+ value);}
</code></pre>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><pre><code class="javascript">export default api;
</code></pre>
<p>总是在模块的 <strong>最后</strong> 使用 <code>export default</code> 方法。它让模块的出口更清晰明了，节省了阅读整个模块来寻找出口的时间。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><pre><code class="javascript">import * as content from &#39;./content&#39;
</code></pre>
<p><strong>注意</strong>：被导出的值是被 <strong>绑定的（原文：bingdings）</strong>，而不是引用。<br>所以，改变一个模块中的值的话，会影响其他引用本模块的代码，一定要避免此种改动发生。</p>
<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><pre><code class="javascript">function addTwoNumbers(x=0, y=0) {
    return x + y;
}
</code></pre>
<h2 id="Rest"><a href="#Rest" class="headerlink" title="Rest"></a>Rest</h2><p>使用 <strong>rest</strong> 操作符，我们可以给函数传入一个不确定数量的参数列表：</p>
<pre><code class="javascript">function logArguments(...args) {
    for (let arg of args) {
        console.log(arg);
    }
}
</code></pre>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>class语法相对原型、构造函数、继承更接近传统语法</p>
<pre><code class="javascript">class Animal {
    constructor () {
        this.type = &#39;animal&#39;
    }
    says(say) {
        console.log(this.type + &#39;says&#39; + say)
    }
}
 let animal = new Animal()
 animal.says(&#39;hello&#39;) // animal says hello

 class Cat extends Animal {
     constructor() {
         super()
         this.type = &#39;cat&#39;
     }
 }
 let cat = new Cat()
 cat.says(&#39;hello&#39;) // cat says hello
</code></pre>
<p>contructor内部定义的方法和属性是实例对象自己的，不能通过extends 进行继承。</p>
<p>在ES6中，子类的构造函数必须含有super函数，super表示的是调用父类的构造函数，虽然是父类的构造函数，但是this指向的却是cat</p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign方法用来将源对象（source）的所有可枚举属性，复制到目标对象（target）</p>
<pre><code class="javascript">var target = { a:1};
var source1 = { b:2};
var source2 = { c:3};
Object.assign(target, source1, source2);
target// {a:1, b:2, c:3}

var n = Object.assign(a,b,c)向n中添加a,b,c的属性
</code></pre>
<p><strong>应用</strong></p>
<ul>
<li>为对象添加属性</li>
<li>为对象添加方法</li>
</ul>
<ul>
<li>克隆对象</li>
<li>为属性指定默认值</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的ID。它通过Symbol函数生成。</p>
<p>Symbols常用的一个使用场景，尤其是使用 <code>Symbol.for(key)</code> 方法，是用于实现代码间的互操作。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成：</p>
<pre><code class="javascript">f1().then(f2);
f1().then(f2).then(f3);
f1().then(f2).fail(f3);
</code></pre>
<p>如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。</p>
<p>API:</p>
<pre><code class="javascript">new Promise((resolve, reject) =&gt;
    reject(new Error(&#39;Failed to fulfill Promise&#39;)))
        .catch(reason =&gt; console.log(reason));
</code></pre>
<p>这里有两个处理函数，<strong>resolve</strong>（当Promise执行成功完毕时调用的回调函数） 和 <strong>reject</strong> （当Promise执行不接受时调用的回调函数）</p>
<p><strong>Promises的好处</strong>：</p>
<ul>
<li>大量嵌套错误处理回调函数会使代码变得难以阅读理解。使用Promises，我们可以通过清晰的路径将错误事件让上传递，并且适当地处理它们。</li>
</ul>
<p>此外，Promise处理后的值，无论是解决（resolved）还是拒绝（rejected）的结果值，都是不可改变的。</p>
<h3 id="1-什么是promise对象，它能干什么？"><a href="#1-什么是promise对象，它能干什么？" class="headerlink" title="1. 什么是promise对象，它能干什么？"></a>1. 什么是promise对象，它能干什么？</h3><p><strong>Promise</strong> 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。</p>
<p><strong>Promise</strong> 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。 这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的 promise 对象来替代原返回值。</p>
<p><strong>Promise</strong> 对象有以下几种状态:</p>
<ul>
<li><em>pending</em>: 表示一个初始状态, 非 fulfilled 或 rejected。</li>
<li><em>fulfilled</em>: 成功的操作。</li>
<li><em>rejected</em>: 失败的操作。</li>
</ul>
<p>每一个异步任务都会返回一个Promise对象，该对象有一个then方法，允许指定回调函数。可以根据Promise对象的状态相应的去执行对应的回调函数。</p>
<h3 id="2-常用的API"><a href="#2-常用的API" class="headerlink" title="2. 常用的API"></a>2. 常用的API</h3><h4 id="1-Promise-prototype-then"><a href="#1-Promise-prototype-then" class="headerlink" title="1.Promise.prototype.then()"></a>1.Promise.prototype.then()</h4><p>它的作用是为promise实例添加状态改变时的回调函数。</p>
<p>then()方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的promise实例。</p>
<p>then方法的第二个参数一般不推荐写。有以下两个原因：</p>
<ul>
<li>由于是链式操作，这个then方法之后还可能会有其他操作，如果此时把错误捕捉的函数放在后面方法前边的话，并且之后再无错误捕获方法，then之后的错误就会捕捉不到。</li>
<li>在then方法里面，两个参数都是回调函数写了一大堆，这样结构看起来比较混乱。</li>
</ul>
<pre><code class="javascript">var p=new Promise(function(resolve, reject){
    resolve(&quot;ok&quot;);    
});
p.then(function(value){console.log(val)},
 function(err)(console.log(err))       
);
</code></pre>
<h4 id="2-Promise-prototype-catch"><a href="#2-Promise-prototype-catch" class="headerlink" title="2.Promise.prototype.catch()"></a>2.Promise.prototype.catch()</h4><p>这个方法是.then(null,rejection)的别名，这也能看出这个方法是专门只能用来捕获错误信息，用于指定发生错误时的回调函数。</p>
<p>要注意一下几点：</p>
<ul>
<li>当promise状态已经变成resolved的时候，再抛出错误时是无效的。</li>
<li>尽量将catch方法写在链式操作的最后。错误会一直冒泡到最后，catch放在最后会捕捉到所有错误。</li>
<li>当没有使用catch方法指定错误处理函数的回调函数时，promise对象里面抛出的错误不会传递到外层的代码。</li>
</ul>
<h4 id="3-Promise-resolve"><a href="#3-Promise-resolve" class="headerlink" title="3. Promise.resolve()"></a>3. Promise.resolve()</h4><p>这个方法的作用就是将现有的对象转化为Promise对象，进而可以执行这些方法。</p>
<pre><code class="javascript">Promise.resolve(&quot;foo&quot;);
</code></pre>
<h4 id="4-Promise-all"><a href="#4-Promise-all" class="headerlink" title="4. Promise.all()"></a>4. Promise.all()</h4><p>这个方法用于将多个promise实例，包装成一个新的promise实例。</p>
<pre><code class="javascript">var p=Promise.all([p1,p2,p3]);
</code></pre>
<p>要注意一下两点：</p>
<ul>
<li>只有当p1,p2,p3状态都变为fulfilled之后，p的状态才会变为fulfilled。</li>
<li>只要p1.p2,p3中有任意一个状态变为rejected，p的状态就会变为rejected。</li>
</ul>
<h3 id="3-实现异步编程的原理"><a href="#3-实现异步编程的原理" class="headerlink" title="3. 实现异步编程的原理"></a>3. 实现异步编程的原理</h3><p>Promise对象相当于是一个状态机，在其内部使用resolve方法，使其由初始状态变为成功时的fulfilled状态或者执行失败后的rejected状态。这时内部的工作就完成了，开始由外部监听其内部的状态的改变，调用then()方法（catch()方法相当于then内部的第二个参数方法）对应的状态调用对应的处理函数。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-promise执行顺序"><a href="#Case1-promise执行顺序" class="headerlink" title="Case1.promise执行顺序"></a>Case1.promise执行顺序</h2><pre><code class="javascript">setTimeout(function(){
    console.log(1);
}, 0)

new Promise(function executor(resolve){
    console.log(2);
    for(var i = 0; i &lt; 1000; i++){
        i = 9999 &amp;&amp; resolve();
    }
    console.log(3);
}).then(function(){
    console.log(4);
})

console.log(5);
// 2， 3， 5， 4， 1
</code></pre>
<ul>
<li>在定时器，事件，ajax等操作的时候，<strong>会使一个异步操作，会把该操作放到一个task queue里，需要等当前主线程的任务完成后，会读取任务队列(task queue)中的是事件。</strong></li>
<li>promise中的then操作是放在执行栈，也就是主线程的最后。 </li>
</ul>
<h2 id="Case2-promise的原理？jquery的ajax返回的是promise对象吗？"><a href="#Case2-promise的原理？jquery的ajax返回的是promise对象吗？" class="headerlink" title="Case2.promise的原理？jquery的ajax返回的是promise对象吗？"></a>Case2.promise的原理？jquery的ajax返回的是promise对象吗？</h2><p>jquery的ajax返回的是<strong>deferred对象</strong>，通过<strong>promise的resolve()方</strong>法将其转换为promise对象。</p>
<pre><code class="javascript">var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;));
</code></pre>
<h2 id="Case3-promise对象捕获错误"><a href="#Case3-promise对象捕获错误" class="headerlink" title="Case3.promise对象捕获错误"></a>Case3.promise对象捕获错误</h2><pre><code class="javascript">//使用throw添加错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    throw new Error(&#39;error0&#39;);
    //setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });

//设置定时器来抛出错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    //throw new Error(&#39;error0&#39;);
    setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });

//同时添加错误事件
var p = new Promise(function(resolve, reject) {
    resolve(&quot;ok&quot;);
    throw new Error(&#39;error0&#39;);
    setTimeout(function() { throw new Error(&#39;error1&#39;) }, 0);
});
p.then(function(value){
    console.log(value) 
　})
 .catch(function(err){
    console.log(err)
    });
process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(&#39;catch exception:&#39;,err.stack) });
</code></pre>
<p>第一个只会打印出 “ok”。状态被设定为fulfilled之后，再进行抛出错误处理，错误也不会被后续的catch方法捕获到。</p>
<p>第二个先打印出“ok”，之后抛出process里面定义的错误。虽然状态已经变为fulfilled，但是定时器抛出的错误属于异步抛出的错误，无法被try catch捕获到，因此和Promise对象无关，所以错误可以正常的抛出来</p>
<p>第三个只打印出“ok”。当执行throw之后，虽然错误未被外部函数捕获处理，但这也是个实实在在存在的错误啊，对于javascript来说，有错就不会继续往下面执行了。所以并不会执行到定时器抛出错误就停止了</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000011344301" target="_blank" rel="external">前端面试之ES6篇（高产似母猪）</a></li>
<li><a href="http://www.jianshu.com/p/c4ba3b25ca0d" target="_blank" rel="external">ECMAScript 6重点一览——基础篇</a></li>
<li><a href="http://blog.csdn.net/shuidinaozhongyan/article/details/77864182" target="_blank" rel="external">面试考察之Promise对象</a></li>
<li>​</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端大纲]]></title>
      <url>/2017/11/01/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<p>做总结有三个目的：</p>
<ul>
<li>想成为前端架构师，还有哪些坑要填</li>
<li>对所学的知识做一个总结</li>
<li>由浅入深，记录自己的学习，内在源动力</li>
</ul>
<blockquote>
<p>最好能做成一个可扩展的思维导图，并附上链接，做成一颗技能树</p>
</blockquote>
<a id="more"></a>
<h1 id="结构层-HTML"><a href="#结构层-HTML" class="headerlink" title="结构层(HTML)"></a>结构层(HTML)</h1><p><a href="https://janebt.github.io/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/">对WEB标准的理解</a></p>
<p><a href="https://janebt.github.io/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/">浏览器内核差异</a></p>
<p><a href="https://janebt.github.io/2017/01/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML5/">HTML5新特性及应用</a></p>
<h1 id="表示层-CSS"><a href="#表示层-CSS" class="headerlink" title="表示层(CSS)"></a>表示层(CSS)</h1><p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">布局</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">盒子模型</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">选择器优先级及使用</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">CSS3新特性及应用</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">兼容性</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">Hack</a></p>
<p><a href="https://janebt.github.io/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/">移动端适应</a></p>
<h1 id="行为层-JavaScript"><a href="#行为层-JavaScript" class="headerlink" title="行为层(JavaScript)"></a>行为层(JavaScript)</h1><p><a href="https://janebt.github.io/2017/04/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a></p>
<p><a href="https://janebt.github.io/2017/02/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/">表达式与运算符</a></p>
<p><a href="https://janebt.github.io/2017/02/27/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%80%97%E5%8F%B7%E3%80%81%E5%86%92%E5%8F%B7%E4%B8%8E%E6%8B%AC%E5%8F%B7/">逗号、冒号与括号</a></p>
<p><a href="https://janebt.github.io/2017/02/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></p>
<p><a href="https://janebt.github.io/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BD%9C%E7%94%A8%E5%9F%9F/">作用域</a></p>
<p><a href="https://janebt.github.io/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型链</a></p>
<p><a href="https://janebt.github.io/2017/03/25/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E7%BB%A7%E6%89%BF/">继承、封装、多态</a></p>
<p><a href="https://janebt.github.io/2017/03/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%B8%8A%E4%B8%8B%E6%96%87/">上下文</a></p>
<p><a href="https://janebt.github.io/2017/11/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%97%AD%E5%8C%85/">闭包</a></p>
<p>插件</p>
<p><a href="https://janebt.github.io/2017/06/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%B7%A8%E5%9F%9F/">跨域</a></p>
<p>模块化</p>
<p><a href="https://janebt.github.io/2017/05/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">事件机制</a></p>
<p>自定义事件</p>
<p><a href="https://janebt.github.io/2017/04/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/">内存泄漏</a></p>
<p>异步装载回调</p>
<p>模版引擎</p>
<p><a href="https://janebt.github.io/2017/08/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/Ajax/">Ajax</a></p>
<p>Jquery</p>
<p><a href="https://janebt.github.io/2017/04/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/json/">JSON</a></p>
<p>Nodejs</p>
<p><a href="">ES6</a></p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>优化</p>
<p>交互</p>
<p>响应式</p>
<p><a href="https://janebt.github.io/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/http/">HTTP</a></p>
<p><a href="https://janebt.github.io/2017/12/02/%E5%89%8D%E7%AB%AF/%E8%B6%8B%E5%8A%BF%E6%8A%80%E6%9C%AF/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></p>
<p>重构</p>
<p>SEO</p>
<p>UED</p>
<p>架构</p>
<p>后端</p>
<p>移动端</p>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack篇]]></title>
      <url>/2017/10/02/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA%E7%94%9F%E6%80%81/webpack%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>本文介绍webpack结构</p>
<a id="more"></a>
<h1 id="webpack篇"><a href="#webpack篇" class="headerlink" title="webpack篇"></a>webpack篇</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>不像大多数的模块打包机，webpack是收把项目当作一个整体，通过一个给定的的主文件，webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包成一个或多个浏览器可识别的js文件</p>
<h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><p>webpack是我们需要的模块打包机，webpack-dev-server用来创建本地服务器，监听你的代码修改，并自动刷新修改后的结果。这些是有关<strong>devServer的配置</strong></p>
<pre><code class="javascript">contentBase,  // 为文件提供本地服务器
port, // 监听端口，默认8080
inline, // 设置为true,源文件发生改变自动刷新页面
historyApiFallback  // 依赖HTML5 history API,如果设置为true,所有的页面跳转指向index.html

devServer:{
    contentBase: &#39;./src&#39; // 本地服务器所加载的页面所在的目录
    historyApiFallback: true, // 不跳转
    inline: true // 实时刷新
}
</code></pre>
<p>然后我们在根目录下创建一个’webpack.config.js’，在’package.json’添加两个命令用于本地开发和生产发布</p>
<pre><code class="javascript">&quot;scripts&quot;: {
      &quot;start&quot;: &quot;webpack-dev-server&quot;,
    &quot;build&quot;: &quot;webpack&quot;
}
</code></pre>
<h1 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>entry: 用来写入口文件，它将是整个依赖关系的根，当我们需要多个入口文件的时候，可以把entry写成一个对象</p>
<pre><code class="javascript">var baseConfig = {
        entry: {
            main: &#39;./src/index.js&#39;
        }
    }
</code></pre>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>output: 即使入口文件有多个，但是只有一个输出配置</p>
<pre><code class="javascript">var path = require(&#39;path&#39;)
var baseConfig = {
    entry: {
        main: &#39;./src/index.js&#39;
    },
    output: {
        filename: &#39;main.js&#39;,
        path: path.resolve(&#39;./build&#39;)
    }
}
module.exports = baseConfig
</code></pre>
<p>如果你定义的入口文件有多个，那么我们需要使用<strong>占位符</strong>来确保输出文件的唯一性</p>
<pre><code class="javascript">output: {
      filename: &#39;[name].js&#39;,
    path: path.resolve(&#39;./build&#39;)
}
</code></pre>
<p>注：filename应该比较好理解，就是对应于entry里面生成出来的文件名。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p><strong>loader的作用</strong>： </p>
<ol>
<li>实现对不同格式的文件的处理，比如说将scss转换为css，或者typescript转化为js</li>
<li>转换这些文件，从而使其能够被添加到依赖图中</li>
</ol>
<p>loader是webpack最重要的部分之一，通过使用不同的Loader，我们能够调用外部的脚本或者工具，实现对不同格式文件的处理，loader需要在webpack.config.js里边单独用module进行配置，需要的loader需要通过npm 进行安装。配置如下：</p>
<pre><code class="javascript">var baseConfig = {
  // ...
  module: {
    rules: [
      {
        test: /*匹配文件后缀名的正则*/,
        use: [
        loader: /*loader名字*/,
        query: /*额外配置*/
        ]
      }
    ]
  }
}
</code></pre>
<p>几个常用的loader：</p>
<ul>
<li>babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件。babel有些复杂，所以大多数都会新建一个.babelrc进行配置</li>
<li>css-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader</li>
<li>file-loader: 生成的文件名就是文件内容的MD5哈希值并会保留所引用资源的原始扩展名</li>
<li>url-loader: 功能类似 file-loader,但是文件大小低于指定的限制时，可以返回一个DataURL事实上，在使用less,scss,stylus这些的时候，npm会提示你差什么插件，差什么，你就安上就行了</li>
</ul>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p><strong>plugins和loader区别</strong></p>
<p><strong>loaders负责的是处理源文件的如css、jsx，一次处理一个文件。而plugins并不是直接操作单个文件，</strong>它直接对整个构建过程起作用。下面列举了一些我们常用的plugins和他的用法</p>
<ul>
<li>ExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。</li>
<li>HtmlWebpackPlugin:它依据一个简单的index.html模版，生成一个自动引用你打包后的js文件的新index.html</li>
<li>HotModuleReplacementPlugin: 它允许你在修改组件代码时，自动刷新实时预览修改后的结果注意永远不要在生产环境中使用HMR。这儿说一下一般情况分为开发环境，测试环境，生产环境。</li>
</ul>
<p>Case.webapck.config.js的全部内容:</p>
<pre><code class="javascript">const webpack = require(&quot;webpack&quot;)
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)
var ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)
var lessRules = {
  use: [
    {loader: &#39;css-loader&#39;},
    {loader: &#39;less-loader&#39;}
  ]
}
module.exports = {
  entry: {
    main: &#39;./src/index.js&#39;
  },
  output: {
    filename: &#39;[name].js&#39;,
    path: path.resolve(&#39;./build&#39;)
  },
  devServer: {
    contentBase: &#39;/src&#39;,
    historyApiFallback: true,
    inline: true,
    hot: true
  },
  module: {
    rules: [
      {test: /\.less$/, use: ExtractTextPlugin.extract(lessRules)}
    ]
  },
  plugins: [
    new ExtractTextPlugin(&#39;main.css&#39;)
  ]
}
</code></pre>
<h1 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h1><p>在产品阶段，还需要对资源进行别的<br>处理，例如压缩，优化，缓存，分离css和js。首先我们来定义产品环境</p>
<pre><code class="javascript">var ENV = process.env.NODE_ENV
var baseConfig = {
  // ... 
  plugins: [
    new webpack.DefinePlugin({
      &#39;process.env.NODE_ENV&#39;: JSON.stringify(ENV)
    })
  ]
}
</code></pre>
<p>然后还需要修改我们的script命令</p>
<pre><code class="javascript">&quot;scripts&quot;: {
    &quot;start&quot;: &quot;NODE_ENV=development webpack-dev-server&quot;,
    &quot;build&quot;: &quot;NODE_ENV=production webpack&quot;
}
</code></pre>
<p>process.env.NODE_ENV 将被一个字符串替代，它运行压缩器排除那些不可到达的开发代码分支。<br>当你引入那些不会进行生产的代码，下面这个代码将非常有用。</p>
<pre><code class="javascript">if (process.env.NODE_ENV === &#39;development&#39;) {
  console.warn(&#39;这个警告会在生产阶段消失&#39;)
}
</code></pre>
<h1 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h1><ul>
<li>OccurenceOrderPlugin: 为组件分配ID,通过这个插件webpack可以分析和优先考虑使用最多 的模块，然后为他们分配最小的ID</li>
<li>UglifyJsPlugin: 压缩代码</li>
</ul>
<p>使用方法</p>
<pre><code class="javascript">var baseConfig = {
  // ...
  new webpack.optimize.OccurenceOrderPlugin()
  new webpack.optimize.UglifyJsPlugin()
}
</code></pre>
<p>然后在我们使用npm run build会发现代码是压缩的</p>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> web </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less语言特性]]></title>
      <url>/2017/10/02/%E5%89%8D%E7%AB%AF/%E6%9E%84%E5%BB%BA%E7%94%9F%E6%80%81/Less%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>本文介绍Less语言特性</p>
<a id="more"></a>
<h1 id="Less语言特性"><a href="#Less语言特性" class="headerlink" title="Less语言特性"></a>Less语言特性</h1><h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><ul>
<li>在定义变量值时使用其它的变量</li>
<li>多次定义，<strong>当前作用域中最后一次定义</strong>的将被使用</li>
<li><strong>按需加载，不必强制在使用之前声明</strong></li>
</ul>
<h3 id="2-混合（Mixins）"><a href="#2-混合（Mixins）" class="headerlink" title="2.混合（Mixins）"></a>2.混合（Mixins）</h3><ul>
<li>可以定义一些通用的属性集为一个 class，然后在另一个 class 中去调用这些属性</li>
<li>任何 CSS class, id 属性集都可以以同样的方式引入</li>
<li>变量也会被混合，也就是说变量会被带到当前的作用域。</li>
</ul>
<h4 id="带参数混合"><a href="#带参数混合" class="headerlink" title="带参数混合"></a>带参数混合</h4><ul>
<li>定义一个带参数的属性集合，如果无默认值，调用必须传参</li>
<li>给参数设置默认值，调用可不传参</li>
<li>定义不带参数属性集合：隐藏（不在 CSS 中）+ 可引用</li>
</ul>
<h4 id="多参数混合"><a href="#多参数混合" class="headerlink" title="多参数混合"></a>多参数混合</h4><ul>
<li>使用分号或者逗号分隔，推荐使用分号分隔，因为逗号有两重含义：它既可以表示混合的参数，也可以表示一个参数中一组值的分隔符。如果编译器在混合的定义或者是调用中找到至少一个分号，就会假设参数是使用分号分隔的，所有的逗号都属于参数中的一组值的分隔符。</li>
<li>使用同样的名字和同样数量的参数定义多个混合是合法的。在被调用时，LESS会应用到所有可以应用的混合上。</li>
</ul>
<h5 id="arguments-变量"><a href="#arguments-变量" class="headerlink" title="@arguments 变量"></a>@arguments 变量</h5><ul>
<li>@arguments包含了所有传递进来的参数。</li>
</ul>
<h4 id="高级参数用法与-rest-变量"><a href="#高级参数用法与-rest-变量" class="headerlink" title="高级参数用法与 @rest 变量"></a>高级参数用法与 @rest 变量</h4><ul>
<li>不限制参数的数量，可以在变量名后添加 …，表示这里可以使用 N 个参数。</li>
<li>@rest 表示之后的参数</li>
</ul>
<h4 id="important关键字"><a href="#important关键字" class="headerlink" title="!important关键字"></a>!important关键字</h4><ul>
<li>在混合后面加上<code>!important</code>关键字表示将混合带来的所有属性标记为<code>!important</code></li>
</ul>
<h4 id="模式匹配与Guard表达式"><a href="#模式匹配与Guard表达式" class="headerlink" title="模式匹配与Guard表达式"></a>模式匹配与Guard表达式</h4><ul>
<li>只有满足匹配要求的混合才会被使用</li>
<li>也可以根据参数的数量进行匹配</li>
</ul>
<h4 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h4><ul>
<li>Guards 被用来匹配表达式，LESS 选择使用 guard混合（类似于 @media 的工作方式）执行条件判断，而不是加入 if/else 声明。</li>
<li>关键词 when，它引入了一个 guard 条件</li>
<li>Guards 支持的运算符包括：&gt; &gt;= = =&lt; &lt;。true关键字是唯一被判断为真的值</li>
<li>多个Guards可以通过逗号表示分隔，如果其中任意一个结果为 true，则匹配成功</li>
<li>不同的参数之间也可以比较，而参与比较的也可以一个参数都没有</li>
<li>如果需要根据值的类型匹配混合，可以使用 is* 函数</li>
<li>使用关键词 and 在 guard 中加入额外的条件</li>
<li>使用关键词 not 否定条件</li>
</ul>
<h3 id="3-嵌套规则"><a href="#3-嵌套规则" class="headerlink" title="3.嵌套规则"></a>3.嵌套规则</h3><ul>
<li>LESS 可以让我们以嵌套的方式编写层叠样式</li>
<li>注意 &amp; 符号的使用 — 如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用如:hover 和 :focus。</li>
</ul>
<h4 id="嵌套-Media-Queries"><a href="#嵌套-Media-Queries" class="headerlink" title="嵌套 Media Queries"></a>嵌套 Media Queries</h4><ul>
<li>Media query也可以使用同样的方式进行嵌套</li>
</ul>
<h3 id="amp-的高级用法"><a href="#amp-的高级用法" class="headerlink" title="&amp; 的高级用法"></a>&amp; 的高级用法</h3><ul>
<li>用在选择器中的&amp;还可以反转嵌套的顺序并且可以应用到多个类名上</li>
<li>&amp;也可以用在混合中用于指示嵌套这个混合的父选择器。</li>
</ul>
<h3 id="4-运算"><a href="#4-运算" class="headerlink" title="4.运算"></a>4.运算</h3><ul>
<li>任何数字、颜色或者变量都可以参与运算，运算应该被包裹在括号中</li>
<li>它能够分辨出颜色和单位</li>
</ul>
<h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5.函数"></a>5.函数</h3><ul>
<li>提供了多种函数用于控制颜色变化、处理字符串、算术运算等等</li>
</ul>
<h3 id="6-命名空间"><a href="#6-命名空间" class="headerlink" title="6.命名空间"></a>6.命名空间</h3><ul>
<li>将一些变量或者混合模块打包起来</li>
<li>使用 <code>&gt;</code> 取命名空间</li>
</ul>
<h3 id="7-作用域"><a href="#7-作用域" class="headerlink" title="7.作用域"></a>7.作用域</h3><ul>
<li>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止</li>
</ul>
<h3 id="8-注释"><a href="#8-注释" class="headerlink" title="8.注释"></a>8.注释</h3><ul>
<li>CSS 的注释格式</li>
<li>支持双斜线的注释，但是编译成 CSS 的时候自动过滤掉</li>
</ul>
<h3 id="9-导入（Import）"><a href="#9-导入（Import）" class="headerlink" title="9.导入（Import）"></a>9.导入（Import）</h3><ul>
<li>既可以导入CSS文件，也可以导入LESS文件。但只有导入的LESS文件才会被处理（编译），导入的CSS文件会保持原样。如果你希望导入一个CSS文件，保留.css后缀即可</li>
<li>编译过程中，对导入CSS文件只做一处处理：将导入的语句提到最前，紧跟在@charset之后</li>
<li>被导入的LESS文件会被复制到含导入语句的文件中，然后一起编译。导入和被导入的文件共享所有的混合、命名空间、变量以及其它结构。</li>
<li>如果导入语句是通过media query指定的，那么导入的语句编译之后会被包裹在@Media声明中。</li>
<li>LESSS文件的导入语句并不强制要求在顶部，它可以被入在规则内部、混合中或者其它的结构中。</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>很容易理解：</p>
<pre><code class="less">@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header { color: @light-blue; }
</code></pre>
<p>输出：</p>
<pre><code class="less">#header { color: #6c94be; }
</code></pre>
<p>甚至可以<strong>在定义变量值时使用其它的变量</strong>：</p>
<pre><code class="less">@fnord: &quot;I am fnord.&quot;;
@var: &#39;fnord&#39;;
content: @@var;
</code></pre>
<p>解析后：</p>
<pre><code class="less">content: &quot;I am fnord.&quot;;
</code></pre>
<p>如果对同一个变量定义两次的话，在<strong>当前作用域中最后一次定义</strong>的将被使用。这与CSS的机制类似，最后一次定义的值会成为这个属性的值。<br>比如：</p>
<pre><code class="less">@var: 0;
.class1 {
    @var: 1;
    .class {
        @var: 2;
        three: @var;
        @var: 3;
    }
    one: @var;
}
</code></pre>
<p>会编译成：</p>
<pre><code class="css">.class1.class {
    three: 3;
}
.class1 {
    one: 1;
}
</code></pre>
<p>变量是“<strong>按需加载</strong>”（lazy loaded）的，因此<strong>不必强制在使用之前声明</strong>。<br>下面是一个有效的LESS代码片段：</p>
<pre><code class="less">lazy-eval {
    width: @var;
}

@var: @a;
@a: 9%;
</code></pre>
<p>下面这个片段也是有效的：</p>
<pre><code class="less">.lazy-eval-scope {
    width: @var;
    @a: 9%;
}

@var: @a;
@a: 100%;
</code></pre>
<p>这两个片段都会编译成：</p>
<pre><code class="css">.lazy-eval-scope {
    width: 9%;
}
</code></pre>
<hr>
<h2 id="混合（Mixins）"><a href="#混合（Mixins）" class="headerlink" title="混合（Mixins）"></a>混合（Mixins）</h2><p>在 LESS 中我们<strong>可以定义一些通用的属性集为一个 class，然后在另一个 class 中去调用这些属性</strong>，下面有这样一个 class：</p>
<pre><code class="less">.bordered {
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
</code></pre>
<p>那如果我们现在需要在其他 class 中引入那些通用的属性集，那么我们只需要在任何 class 中像下面这样调用就可以了：</p>
<pre><code class="less">#menua {
    color: #111;
    .bordered;
}
.posta {
    color: red;
    .bordered;
}
</code></pre>
<p>.bordered class 里面的属性样式都会在 #menu a 和 .post a 中体现出来：</p>
<pre><code class="less">#menua {
    color: #111;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
.posta {
    color: red;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
</code></pre>
<p>任何 <strong>CSS class, id 属性集</strong>都可以以同样的方式引入。</p>
<blockquote>
<p>注意：变量也会被混合，也就是说变量会被带到当前的作用域。这个特性还有争议，也许在未来会有变化。</p>
</blockquote>
<h3 id="带参数混合-1"><a href="#带参数混合-1" class="headerlink" title="带参数混合"></a><strong>带参数混合</strong></h3><p>在 LESS 中，你还可以像函数一样<strong>定义一个带参数的属性集合</strong>：</p>
<pre><code class="less">.border-radius (@radius) {
    border-radius: @radius;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
}
</code></pre>
<p>然后在其他 class 中像这样调用它：</p>
<pre><code class="less">#header {
    .border-radius(4px);
}
.button {
    .border-radius(6px);
}
</code></pre>
<p>我们还可以像这样<strong>给参数设置默认值</strong>：</p>
<pre><code class="less">.border-radius (@radius: 5px) {
    border-radius: @radius;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
}
</code></pre>
<p>所以现在如果我们像这样调用它的话：</p>
<pre><code class="less">#header {
    .border-radius;
}
</code></pre>
<p>radius 的值就会是 <em>5px</em>。<br>你也可以<strong>定义不带参数属性集合</strong>，如果你想隐藏这个属性集合，不让它暴露到 CSS 中去，但是你还想在其他的属性集合中引用，你会发现这个方法非常的好用：</p>
<pre><code class="less">.wrap () {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}

pre { .wrap }
</code></pre>
<p>输出：</p>
<pre><code class="css">pre {
    text-wrap: wrap;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    word-wrap: break-word;
}
</code></pre>
<h3 id="多参数混合-1"><a href="#多参数混合-1" class="headerlink" title="多参数混合"></a>多参数混合</h3><p>多个参数可以<strong>使用分号或者逗号分隔，推荐使用分号分隔</strong>，因为<strong>逗号有两重含义：它既可以表示混合的参数，也可以表示一个参数中一组值的分隔符。</strong><br>使用分号作为参数分隔符意味着可以将逗号分隔的一组值作为一个变量处理。换句话说，<strong>如果编译器在混合的定义或者是调用中找到至少一个分号，就会假设参数是使用分号分隔的，所有的逗号都属于参数中的一组值的分隔符。</strong><br>2个参数，每个参数都含有通过逗号分隔的一组值的情况：.name(1, 2, 3; something, else)。<br>3个参数，每个参数只含一个数字的情况：.name(1, 2, 3)。<br>使用一个象征性的分号可以创建一个只含一个参数，但参数包含一组值的混合：.name(1, 2, 3;)。<br>逗号分隔的一组值参数的默认值：.name(@param1: red, blue;)。<br><strong>使用同样的名字和同样数量的参数定义多个混合是合法的。在被调用时，LESS会应用到所有可以应用的混合上。</strong>比如你调用混合时只传了一个参数.mixin(green)，那么所有只强制要求一个参数的混合都会被调用：</p>
<pre><code class="less">.mixin(@color) {
    color-1: @color;
}
.mixin(@color; @padding:2) {
    color-2: @color;
    padding-2: @padding;
}
.mixin(@color; @padding; @margin: 2) {
    color-3: @color;
    padding-3: @padding;
    margin: @margin @margin @margin @margin;
}
.some.selectordiv {
    .mixin(#008000);
}
</code></pre>
<p>编译结果：</p>
<pre><code class="less">.some.selectordiv {
    color-1: #008000;
    color-2: #008000;
    padding-2: 2;
}
</code></pre>
<h4 id="arguments-变量-1"><a href="#arguments-变量-1" class="headerlink" title="@arguments 变量"></a><strong>@arguments 变量</strong></h4><p><strong>@arguments包含了所有传递进来的参数。</strong> 如果你不想单独处理每一个参数的话就可以像这样写：</p>
<pre><code class="less">.box-shadow (@x: 0, @y: 0, @blur: 1px, @color: #000) {
    box-shadow: @arguments;
    -moz-box-shadow: @arguments;
    -webkit-box-shadow: @arguments;
}
.box-shadow(2px, 5px);
</code></pre>
<p>将会输出：</p>
<pre><code class="css">box-shadow: 2px5px1px#000;
-moz-box-shadow: 2px5px1px#000;
 -webkit-box-shadow: 2px5px1px#000;
</code></pre>
<h3 id="高级参数用法与-rest-变量-1"><a href="#高级参数用法与-rest-变量-1" class="headerlink" title="高级参数用法与 @rest 变量"></a>高级参数用法与 @rest 变量</h3><p>如果需要在 mixin 中<strong>不限制参数的数量，可以在变量名后添加 …，</strong>表示这里可以使用 N 个参数。</p>
<pre><code>.mixin (...) {        // 接受 0-N 个参数
     .mixin () {           // 不接受任何参数
     .mixin (@a: 1) {      // 接受 0-1 个参数
     .mixin (@a: 1, ...) { // 接受 0-N 个参数
     .mixin (@a, ...) {    // 接受 1-N 个参数
</code></pre><p><strong>此外：</strong></p>
<pre><code class="less">.mixin (@a, @rest...) {
    // @rest 表示 @a 之后的参数// @arguments 表示所有参数
}
</code></pre>
<h3 id="important关键字-1"><a href="#important关键字-1" class="headerlink" title="!important关键字"></a><strong>!important关键字</strong></h3><p>调用时<strong>在混合后面加上<code>!important</code>关键字表示将混合带来的所有属性标记为<code>!important</code>：</strong></p>
<pre><code class="less">.mixin (@a: 0) {
    border: @a;
    boxer: @a;
}
.unimportant {
    .mixin(1); 
}
.important {
    .mixin(2) !important; 
}
</code></pre>
<p>编译成：</p>
<pre><code class="css">.unimportant {
    border: 1;
    boxer: 1;
}
.important {
    border: 2!important;
    boxer: 2!important;
}
</code></pre>
<h3 id="模式匹配与Guard表达式-1"><a href="#模式匹配与Guard表达式-1" class="headerlink" title="模式匹配与Guard表达式"></a><strong>模式匹配与Guard表达式</strong></h3><p>LESS 提供了通过参数值控制 mixin 行为的功能，让我们先从最简单的例子开始：</p>
<pre><code class="less">.mixin (@s, @color) { ... }

.class {
    .mixin(@switch, #888);
}
</code></pre>
<p>如果要根据 @switch 的值控制 .mixin 行为，只需按照下面的方法定义 .mixin：</p>
<pre><code class="less">.mixin (dark, @color) {
    color: darken(@color, 10%);
}
.mixin (light, @color) {
    color: lighten(@color, 10%);
}
.mixin (@_, @color) {
    display: block;
}
</code></pre>
<p>然后调用：</p>
<pre><code class="less">@switch: light;

.class {
    .mixin(@switch, #888);
}
</code></pre>
<p>将会得到以下 CSS：</p>
<pre><code class="css">.class {
    color: #a2a2a2;
    display: block;
}
</code></pre>
<p>传给 .mixin 的颜色将执行 lighten 函数，如果 @switch 的值是 dark，那么则会执行 darken 函数输出颜色。<br>以下是整个过程如何发生的：</p>
<pre><code>1. 第一个.mixin 没有匹配，因为不满足 dark 条件；
2. 第二个.mixin 可以被匹配，因为它满足了 light 条件；
3. 第三个.mixin 也可以被匹配，因为它接受任何参数。
</code></pre><p><strong>只有满足匹配要求的混合才会被使用。</strong>混合中的变量可以匹配任何值，非变量形式的值只有与传入的值完全相等时才可以匹配成功。<br>我们<strong>也可以根据参数的数量进行匹</strong>配，比如：</p>
<pre><code class="less">.mixin (@a) {
    color: @a;
}
.mixin (@a, @b) {
    color: fade(@a, @b);
}
</code></pre>
<p>调用 .mixin 时，如果使用了一个参数，输出第一个 .mixin，使用了两个参数，则输出第二个。</p>
<h3 id="Guards-1"><a href="#Guards-1" class="headerlink" title="Guards"></a><strong>Guards</strong></h3><p>与上面匹配值或者匹配参数数量的情况不同，<strong>Guards 被用来匹配表达式</strong> (expressions)。如果你很熟悉编程函数的用法，那么很可能你已经掌握它的用法了。<br>为了尽可能地符合 CSS 的语言结构，<strong>LESS 选择使用 guard混合（guarded mixins）（类似于 @media 的工作方式）执行条件判断，而不是加入 if/else 声明。</strong><br>首先通过下面的例子开始介绍：</p>
<pre><code class="less">.mixin (@a) when (lightness(@a) &gt;= 50%) {
    background-color: black;
}
.mixin (@a) when (lightness(@a) &lt; 50%) {
    background-color: white;
}
.mixin (@a) {
    color: @a;
}
</code></pre>
<p>要点在于<strong>关键词 when，它引入了一个 guard 条件</strong> （这里只用到一个 guard）。现在如果运行下面的代码：</p>
<pre><code class="less">.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }
</code></pre>
<p>将会得到以下输出结果：</p>
<pre><code class="less">.class1 {
    background-color: black;
    color: #ddd;
}
.class2 {
    background-color: white;
    color: #555;
}
</code></pre>
<p><strong>Guards 支持的运算符包括：&gt; &gt;= = =&lt; &lt;</strong>。说明一下，<strong>true关键字是唯一被判断为真的值，也就是这两个混合是相等的</strong>：</p>
<pre><code class="less">.truth (@a) when (@a) { ... }
.truth (@a) when (@a = true) { ... }
</code></pre>
<p>其他不为 true 的值都判为假：</p>
<pre><code class="css">.class {
    .truth(40); // 不会匹配上面的 mixin
}
</code></pre>
<p><strong>多个Guards可以通过逗号表示分隔，如果其中任意一个结果为 true，则匹配成功</strong>：</p>
<pre><code class="less">.mixin (@a) when (@a &gt; 10), (@a &lt; -10) { ... }
</code></pre>
<p>值得注意的是<strong>不同的参数之间也可以比较，而参与比较的也可以一个参数都没有</strong>：</p>
<pre><code class="less">@media: mobile;

.mixin (@a) when (@media = mobile) { ... }
.mixin (@a) when (@media = desktop) { ... }

.max (@a, @b) when (@a &gt; @b) { width: @a }
.max (@a, @b) when (@a &lt; @b) { width: @b }
</code></pre>
<p><strong>如果需要根据值的类型匹配混合，可以使用 is* 函数</strong>：</p>
<pre><code class="less">.mixin (@a, @b: 0) when (isnumber(@b)) { ... }
.mixin (@a, @b: black) when (iscolor(@b)) { ... }
</code></pre>
<p><strong>几个检查基本类型的函数</strong>：</p>
<ul>
<li>iscolor</li>
<li>isnumber</li>
<li>isstring</li>
<li>iskeyword</li>
<li>isurl</li>
</ul>
<p>如果需要检查一个值（数字）使用了哪个单位，可以使用下面三个函数：</p>
<ul>
<li>ispixel</li>
<li>ispercentage</li>
<li>isem</li>
</ul>
<p>最后，你<strong>可以使用关键词 and 在 guard 中加入额外的条件</strong>:<br>.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { … }<br>或者，<strong>使用关键词 not 否定条件</strong>：<br>.mixin (@b) when not (@b &gt; 0) { … }</p>
<hr>
<h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a><strong>嵌套规则</strong></h2><p><strong>LESS 可以让我们以嵌套的方式编写层叠样式。</strong> 让我们先看下下面这段 CSS：</p>
<pre><code class="css">#header { color: black; }

#header.navigation {
font-size: 12px;
}

#header.logo {
width: 300px;
}

#header.logo:hover {
text-decoration: none;
}
</code></pre>
<p>在 LESS 中, 我们就可以这样写：</p>
<pre><code class="less">#header {
    color: black;

    .navigation {
        font-size: 12px;
    }

    .logo {
        width: 300px;
        &amp;:hover { text-decoration: none }
    }
}
</code></pre>
<p>或者这样写：</p>
<pre><code class="less">#header { color: black;
    .navigation { font-size: 12px }
    .logo { width: 300px;
        &amp;:hover { text-decoration: none }
    }
}
</code></pre>
<p>代码更简洁了，而且感觉跟 DOM 结构格式有点像。<br><strong>注意 &amp; 符号的使用 — 如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用如:hover 和 :focus。</strong><br>例如：</p>
<pre><code class="less">.bordered {
    &amp;.float {
        float: left;
    }
    .top {
        margin: 5px;
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="css">.bordered.float {
    float: left;
}
.bordered.top {
    margin: 5px;
}
</code></pre>
<h3 id="嵌套-Media-Queries-1"><a href="#嵌套-Media-Queries-1" class="headerlink" title="嵌套 Media Queries"></a><strong>嵌套 Media Queries</strong></h3><p><strong>Media query也可以使用同样的方式进行嵌套</strong>。</p>
<pre><code class="less">.one {
    @media (width: 400px) {
        font-size: 1.2em;
        @media printandcolor {
            color: blue;
        }
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="less">@media (width: 400px) {
    .one {
        font-size: 1.2em;
    }
}
@media (width: 400px) andprintandcolor {
    .one {
        color: blue;
        }
}
</code></pre>
<h2 id="amp-的高级用法-1"><a href="#amp-的高级用法-1" class="headerlink" title="&amp; 的高级用法"></a><strong>&amp; 的高级用法</strong></h2><p><strong>用在选择器中的&amp;还可以反转嵌套的顺序并且可以应用到多个类名上</strong>。<br>例如：</p>
<pre><code class="less">.child, .sibling {
    .parent &amp; {
        color: black;
    }
    &amp; + &amp; {
        color: red;
    }
}
</code></pre>
<p>输出：</p>
<pre><code class="css">.parent.child,
.parent.sibling {
    color: black;
}
.child + .child,
.child + .sibling,
.sibling + .child,
.sibling + .sibling {
    color: red;
}
</code></pre>
<p><strong>&amp;也可以用在混合中用于指示嵌套这个混合的父选择器。</strong></p>
<hr>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a><strong>运算</strong></h2><p><strong>任何数字、颜色或者变量都可以参与运算，运算应该被包裹在括号中</strong>。来看一组例子：</p>
<pre><code class="less">@base: 5%;
@filler: (@base * 2);
@other: (@base + @filler);

color: (#888 / 4);
background-color: (@base-color + #111);
height: (100% / 2 + @filler);
</code></pre>
<p>LESS 的运算已经超出了我们的期望，如果像下面这样的话，<strong>它能够分辨出颜色和单位</strong>：</p>
<pre><code class="less">@var: (1px + 5);
</code></pre>
<p>LESS 将会使用出现的单位，最终输出 6px。<br>也可以使用括号：</p>
<pre><code class="less">width: ((@var + 5) * 2);
</code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h2><p>LESS <strong>提供了多种函数用于控制颜色变化、处理字符串、算术运算等等</strong>。这些函数在函数手册中有详细介绍。<br>函数的用法非常简单，下面这个例子将介绍如何将 0.5 转换为 50%，将颜色饱和度增加 5%,以及颜色亮度降低25% 色相值增加 8 等</p>
<pre><code class="less">@base: #f04615;
@width: 0.5;

.class {
    width: percentage(0.5); // returns `50%`color:             saturate(@base, 5%);
    background-color: spin(lighten(@base, 25%), 8);
}
</code></pre>
<p><strong>命名空间</strong><br>有时候，你可能为了更好组织 CSS 或者单纯是为了更好的封装，将一些变量或者混合模块打包起来，你可以像下面这样在 #bundle 中定义一些属性集之后可以重复使用：</p>
<pre><code class="less">#bundle {
    .button () {
        display: block;
        border: 1px solid black;
        background-color: grey;
        &amp;:hover { background-color: white }
    }
    .tab { ... }
    .citation { ... }
}
</code></pre>
<p>你只需要在 #header a 中像<strong>这样引入 .button</strong>：</p>
<pre><code class="less">#headera {
    color: orange;
    #bundle &gt; .button;
}
</code></pre>
<hr>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><strong>作用域</strong></h2><p>LESS 中的作用域跟其他编程语言非常类似，<strong>首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止</strong>。</p>
<pre><code class="less">@var: red;

#page {
    @var: white;
    #header {
        color: @var; // white
    }
}

#footer {
    color: @var; // red
}
</code></pre>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><strong>注释</strong></h2><p>CSS 的注释格式在 LESS 中依然有效：</p>
<pre><code class="less">/* Hello, I&#39;m a CSS-style comment */.class { color: black }1
</code></pre>
<p>LESS 同样<strong>也支持双斜线的注释，但是编译成 CSS 的时候自动过滤掉</strong>：</p>
<pre><code class="css">// Hi, I&#39;m a silent comment, I won&#39;t show up in your CSS.class { color: white }1
</code></pre>
<h2 id="导入（Import）"><a href="#导入（Import）" class="headerlink" title="导入（Import）"></a><strong>导入（Import）</strong></h2><p>在LESS中，你<strong>既可以导入CSS文件，也可以导入LESS文件。但只有导入的LESS文件才会被处理（编译），导入的CSS文件会保持原样。如果你希望导入一个CSS文件，保留.css后缀即可</strong>：</p>
<pre><code class="less">@import &quot;lib.css&quot;;
</code></pre>
<p><strong>编译过程中，对导入CSS文件只做一处处理：将导入的语句提到最前，紧跟在@charset之后</strong>。<br>例如输入的文件有导入语句：</p>
<pre><code class="less">h1 { color: green; }
@import &quot;import/official-branding.css?urlParameter=23&quot;;
</code></pre>
<p>导入语句将被提到最前：</p>
<pre><code class="less">@import &quot;import/official-branding.css?urlParameter=23&quot;;
h1 { color: green; }
</code></pre>
<p><strong>被导入的LESS文件会被复制到含导入语句的文件中，然后一起编译。导入和被导入的文件共享所有的混合、命名空间、变量以及其它结构。</strong><br>另外，<strong>如果导入语句是通过media query指定的，那么导入的语句编译之后会被包裹在@Media声明中。</strong><br>例如有被导入的文件library.less：</p>
<pre><code class="less">@imported-color: red;
h1 { color: green; }
</code></pre>
<p>主样式文件导入了上面的library.less：</p>
<pre><code class="less">@import &quot;library.less&quot; screen and (max-width: 400px); // 通过media query指定的import@import &quot;library.less&quot;; // 无media query的import.class {
    color: @importedColor; // 使用导入的变量
}
</code></pre>
<p>将会编译出：</p>
<pre><code class="less">// 对应通过media query指定的import@media screen and (max-width: 400px) {
    h1 { color: green; }
}

// 对应无media query的importh1 { color: green; }
.class {
    // 使用导入的变量color: #ff0000;
}
</code></pre>
<p><strong>LESSS文件的导入语句并不强制要求在顶部，它可以被入在规则内部、混合中或者其它的结构中。</strong><br>例如放在规则内部：</p>
<pre><code class="less">pre {
    @import &quot;library.less&quot;;
    color: @importedColor;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 技术栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> less </tag>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax]]></title>
      <url>/2017/08/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/Ajax/</url>
      <content type="html"><![CDATA[<p>本文介绍Ajax知识体系。</p>
<p>参考一篇非常好的文章<a href="https://segmentfault.com/a/1190000008697448" target="_blank" rel="external">《Ajax知识体系大梳理》</a>，内容比较多，我就做一点关注点总结。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>Ajax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. </p>
<h2 id="浏览器为ajax做了什么"><a href="#浏览器为ajax做了什么" class="headerlink" title="浏览器为ajax做了什么"></a>浏览器为ajax做了什么</h2><p>1.标准浏览器通过 <code>XMLHttpRequest</code> 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest();
</code></pre>
<p>2.IE浏览器通过 <code>XMLHttpRequest</code> 或者 <code>ActiveXObject</code> 对象同样实现了ajax的功能.</p>
<h3 id="MSXML"><a href="#MSXML" class="headerlink" title="MSXML"></a>MSXML</h3><p>IE6及更低版本浏览器只能使用 <code>ActiveXObject</code> 对象来创建 XMLHttpRequest 对象实例. 创建时需要指明一个类似”Microsoft.XMLHTTP”这样的ProgID. </p>
<p>IE5及之后的浏览器均可以通过如下语句获取xhr对象:</p>
<pre><code class="javascript">var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3
var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用
</code></pre>
<h3 id="全平台兼容的XMLHttpRequest对象"><a href="#全平台兼容的XMLHttpRequest对象" class="headerlink" title="全平台兼容的XMLHttpRequest对象"></a>全平台兼容的XMLHttpRequest对象</h3><pre><code class="javascript">function getXHR(){
  var xhr = null;
  if(window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
      } catch (e) { 
        alert(&quot;您的浏览器暂不支持Ajax!&quot;);
      }
    }
  }
  return xhr;
}
</code></pre>
<h2 id="ajax有没有破坏js单线程机制"><a href="#ajax有没有破坏js单线程机制" class="headerlink" title="ajax有没有破坏js单线程机制"></a>ajax有没有破坏js单线程机制</h2><p>一般情况下, 浏览器有如下四种线程:</p>
<ul>
<li>GUI渲染线程</li>
<li>javascript引擎线程</li>
<li>浏览器事件触发线程</li>
<li>HTTP请求线程</li>
</ul>
<p>通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到<code>任务队列</code> 的末尾 , 等到js引擎空闲时, <code>任务队列</code> 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.</p>
<p><strong>浏览器中, js引擎线程会循环从 任务队列 中读取事件并且执行, 这种运行机制称作 Event Loop (事件循环).</strong></p>
<p>对于一个ajax请求, js引擎首先生成 <code>XMLHttpRequest</code> 实例对象, open过后再调用send方法. 至此, 所有的语句都是同步执行. 但从send方法内部开始, 浏览器为将要发生的网络请求创建了新的http请求线程, 这个线程独立于js引擎线程, 于是网络请求异步被发送出去了. 另一方面, js引擎并不会等待 ajax 发起的http请求收到结果, 而是直接顺序往下执行.</p>
<p>当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 <code>onreadystatechange</code> (当然也可能触发onload, 或者 onerror等等) . 该回调事件并没有被立即执行, 而是被添加到 <code>任务队列</code> 的末尾. 直到js引擎空闲了, <code>任务队列</code> 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 <code>onreadystatechange</code> 事件.</p>
<p>在 <code>onreadystatechange</code> 事件内部, 有可能对dom进行操作. 此时浏览器便会挂起js引擎线程, 转而执行GUI渲染线程, 进行UI重绘(repaint)或者回流(reflow). 当js引擎重新执行时, GUI渲染线程又会被挂起, GUI更新将被保存起来, 等到js引擎空闲时立即被执行.</p>
<p>以上整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 <code>GUI渲染线程</code> 和 <code>js引擎线程</code> 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.</p>
<h2 id="ajax与setTimeout排队问题"><a href="#ajax与setTimeout排队问题" class="headerlink" title="ajax与setTimeout排队问题"></a>ajax与setTimeout排队问题</h2><p>由于ajax异步, setTimeout回调本应该最先被执行, 然而实际上, 一次ajax请求, 并非所有的部分都是异步的, 至少<strong>“readyState==1”的 <code>onreadystatechange</code> 回调以及 <code>onloadstart</code> 回调就是同步执行的</strong>. 因此它们的输出排在最前面.</p>
<h2 id="XMLHttpRequest-属性解读"><a href="#XMLHttpRequest-属性解读" class="headerlink" title="XMLHttpRequest 属性解读"></a>XMLHttpRequest 属性解读</h2><p>追根溯源, XMLHttpRequest 实例对象具有如下的继承关系. (下面以a&lt;&lt;b表示a继承b)</p>
<p><code>xhr</code> &lt;&lt; <code>XMLHttpRequest.prototype</code> &lt;&lt; <code>XMLHttpRequestEventTarget.prototype</code> &lt;&lt; <code>EventTarget.prototype</code> &lt;&lt; <code>Object.prototype</code></p>
<p>通常, 一个xhr实例对象拥有10个普通属性+9个方法.</p>
<h3 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h3><p>只读属性, readyState属性记录了ajax调用过程中所有可能的状态.</p>
<h3 id="onreadystatechange"><a href="#onreadystatechange" class="headerlink" title="onreadystatechange"></a>onreadystatechange</h3><p>onreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调</p>
<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.</p>
<h3 id="statusText"><a href="#statusText" class="headerlink" title="statusText"></a>statusText</h3><p>只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 <code>OK</code> . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 <code>Moved Permanently</code> , 302的 <code>Found</code> , 303的 <code>See Other</code> , 307 的 <code>Temporary Redirect</code> , 400的 <code>Bad Request</code> , 401的 <code>Unauthorized</code> 等等.</p>
<h3 id="onloadstart"><a href="#onloadstart" class="headerlink" title="onloadstart"></a>onloadstart</h3><p>onloadstart事件回调方法在ajax请求发送之前触发, 触发时机在 <code>readyState==1</code> 状态之后, <code>readyState==2</code> 状态之前.</p>
<h3 id="onprogress"><a href="#onprogress" class="headerlink" title="onprogress"></a>onprogress</h3><p>onprogress事件回调方法在 <code>readyState==3</code> 状态时开始触发, 默认传入 ProgressEvent 对象, 可通过 <code>e.loaded/e.total</code> 来计算加载资源的进度, 该方法用于获取资源的下载进度.</p>
<h3 id="onload"><a href="#onload" class="headerlink" title="onload"></a>onload</h3><p>onload事件回调方法在ajax请求成功后触发, 触发时机在 <code>readyState==4</code> 状态之后.</p>
<p>可用于捕捉到一个ajax异步请求的成功状态, 并且执行回调。</p>
<h3 id="onloadend"><a href="#onloadend" class="headerlink" title="onloadend"></a>onloadend</h3><p>onloadend事件回调方法在ajax请求完成后触发, 触发时机在 <code>readyState==4</code> 状态之后(收到响应时) 或者<code>readyState==2</code> 状态之后(未收到响应时).</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>timeout属性用于指定ajax的超时时长. </p>
<h3 id="ontimeout"><a href="#ontimeout" class="headerlink" title="ontimeout"></a>ontimeout</h3><p>ontimeout方法在ajax请求超时时触发, 通过它可以在ajax请求超时时做一些后续处理.</p>
<h3 id="response-responseText"><a href="#response-responseText" class="headerlink" title="response responseText"></a>response responseText</h3><p>均为只读属性, response表示服务器的响应内容, 相应的, responseText表示服务器响应内容的文本形式.</p>
<h3 id="responseXML"><a href="#responseXML" class="headerlink" title="responseXML"></a>responseXML</h3><p>只读属性, responseXML表示xml形式的响应数据, 缺省为null, 若数据不是有效的xml, 则会报错.</p>
<h3 id="responseType"><a href="#responseType" class="headerlink" title="responseType"></a>responseType</h3><p>responseType表示响应的类型, 缺省为空字符串, 可取 <code>&quot;arraybuffer&quot;</code> , <code>&quot;blob&quot;</code> , <code>&quot;document&quot;</code> , <code>&quot;json&quot;</code> , and <code>&quot;text&quot;</code> 共五种类型.</p>
<h3 id="responseURL"><a href="#responseURL" class="headerlink" title="responseURL"></a>responseURL</h3><p>responseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL.</p>
<h3 id="withCredentials"><a href="#withCredentials" class="headerlink" title="withCredentials"></a>withCredentials</h3><p>withCredentials是一个布尔值, 默认为false, 表示跨域请求中不发送cookies等信息.</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>abort方法用于取消ajax请求, 取消后, readyState 状态将被设置为 <code>0</code> (<code>UNSENT</code>). </p>
<h3 id="getResponseHeader"><a href="#getResponseHeader" class="headerlink" title="getResponseHeader"></a>getResponseHeader</h3><p>getResponseHeader方法用于获取ajax响应头中指定name的值. </p>
<h3 id="getAllResponseHeaders"><a href="#getAllResponseHeaders" class="headerlink" title="getAllResponseHeaders"></a>getAllResponseHeaders</h3><p>getAllResponseHeaders方法用于获取所有安全的ajax响应头, 响应头以字符串形式返回. </p>
<h3 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader"></a>setRequestHeader</h3><p>设置请求头</p>
<h3 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h3><p>onerror方法用于在ajax请求出错后执行. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时触发</p>
<h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><p>upload属性默认返回一个 <code>XMLHttpRequestUpload</code> 对象, 用于上传资源</p>
<h3 id="overrideMimeType"><a href="#overrideMimeType" class="headerlink" title="overrideMimeType"></a>overrideMimeType</h3><p>overrideMimeType方法用于强制指定response 的 MIME 类型, 即强制修改response的 <code>Content-Type</code> . </p>
<h2 id="XHR一级"><a href="#XHR一级" class="headerlink" title="XHR一级"></a>XHR一级</h2><p>XHR1时, xhr对象具有如下缺点:</p>
<ul>
<li>仅支持文本数据传输, 无法传输二进制数据.</li>
<li>传输数据时, 没有进度信息提示, 只能提示是否完成.</li>
<li>受浏览器 <code>同源策略</code> 限制, 只能请求同域资源.</li>
<li>没有超时机制, 不方便掌控ajax请求节奏.</li>
</ul>
<h2 id="XHR二级"><a href="#XHR二级" class="headerlink" title="XHR二级"></a>XHR二级</h2><p>XHR2针对XHR1的上述缺点做了如下改进:</p>
<ul>
<li>支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单.</li>
<li>提供进度提示, 可通过 <code>xhr.upload.onprogress</code> 事件回调方法获取传输进度.</li>
<li>依然受 <code>同源策略</code> 限制, 这个安全机制不会变. XHR2新提供 <code>Access-Control-Allow-Origin</code> 等headers, 设置为 <code>*</code> 时表示允许任何域名请求, 从而实现跨域CORS访问</li>
<li>可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.</li>
</ul>
<p>目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的.</p>
<h2 id="XDomainRequest"><a href="#XDomainRequest" class="headerlink" title="XDomainRequest"></a>XDomainRequest</h2><p>XDomainRequest 对象是IE8,9折腾出来的, 用于支持CORS请求非成熟的解决方案. 以至于IE10中直接移除了它, 并重新回到了 XMLHttpRequest 的怀抱.</p>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h2><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><h3 id="支持promise"><a href="#支持promise" class="headerlink" title="支持promise"></a>支持promise</h3><p>$.ajax() 方法返回jqXHR对象(jq1.5起), 如果使用的不是XMLHttpRequest对象时, 如jsonp请求, 返回的jqXHR对象将尽可能模拟原生的xhr. 从jq1.5起, 返回的jqXHR对象实现了promise接口.</p>
<h3 id="使用转换器"><a href="#使用转换器" class="headerlink" title="使用转换器"></a>使用转换器</h3><p>$.ajax() 的转换器可以将支持的数据类型映射到其它数据类型. 如果需要将自定义数据类型映射到已知的类型. 需要使用 <code>contents</code> 选项在响应的 “Content-Type” 和实际数据类型之间添加一个转换函数.</p>
<h3 id="事件触发顺序"><a href="#事件触发顺序" class="headerlink" title="事件触发顺序"></a>事件触发顺序</h3><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios Vs jquery</p>
<ul>
<li>Axios支持node, jquery并不支持.</li>
<li>Axios基于promise语法, jq3.0才开始全面支持.</li>
<li>Axios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.</li>
<li>vue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.</li>
</ul>
<p>语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:</p>
<pre><code class="javascript">axios.get(&quot;https://api.github.com/users/louiszhai&quot;)
  .then(function(response){
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
</code></pre>
<p>除了get, 它还支持post, delete, head, put, patch, request请求. </p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p><a href="http://louiszhai.github.io/2016/11/02/fetch/" target="_blank" rel="external">Fetch进阶指南</a> .</p>
<h2 id="ajax跨域请求"><a href="#ajax跨域请求" class="headerlink" title="ajax跨域请求"></a>ajax跨域请求</h2><h3 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h3><p>实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)</p>
<h3 id="移动端CORS兼容性"><a href="#移动端CORS兼容性" class="headerlink" title="移动端CORS兼容性"></a>移动端CORS兼容性</h3><p>当前几乎所有的桌面浏览器(Internet Explorer 8+, Firefox 3.5+, Safari 4+和 Chrome 3+)都可通过名为跨域资源共享的协议支持ajax跨域调用.</p>
<p> CORS的技术在IOS Safari7.1及Android webview2.3中就早已支持, 即使低版本下webview的canvas在使用跨域的video或图片时会有问题, 也丝毫不影响CORS的在移动端的使用. </p>
<h3 id="CORS有关的headers"><a href="#CORS有关的headers" class="headerlink" title="CORS有关的headers"></a>CORS有关的headers</h3><h3 id="CORS请求"><a href="#CORS请求" class="headerlink" title="CORS请求"></a>CORS请求</h3><p>CORS请求分为两种, ① 简单请求; ② 非简单请求.</p>
<p>对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 <code>Origin</code> 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 <code>Access-Control-*</code> 等字段.</p>
<p>对于非简单请求, 比如Method为<code>POST</code>且Content-Type值为 <code>application/json</code> 的请求或者Method为 <code>PUT</code> 或 <code>DELETE</code> 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 <code>Access-Control-*</code> 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发).</p>
<h3 id="HTML启用CORS"><a href="#HTML启用CORS" class="headerlink" title="HTML启用CORS"></a>HTML启用CORS</h3><pre><code class="html">&lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;
</code></pre>
<h3 id="图片启用CORS"><a href="#图片启用CORS" class="headerlink" title="图片启用CORS"></a>图片启用CORS</h3><p>通常, 图片允许跨域访问, 也可以在canvas中使用跨域的图片, 但这样做会污染画布, 一旦画布受污染, 将无法读取其数据. 浏览器的这种安全机制规避了未经许可的远程服务器图片被滥用的风险.</p>
<p>因此如需在canvas中使用跨域的图片资源, 请参考如下apache配置片段(来自<a href="https://github.com/h5bp/server-configs-apache/blob/fc379c45f52a09dd41279dbf4e60ae281110a5b0/src/.htaccess#L36-L53" target="_blank" rel="external">HTML5 Boilerplate Apache server configs</a>).</p>
<h2 id="ajax文件上传"><a href="#ajax文件上传" class="headerlink" title="ajax文件上传"></a>ajax文件上传</h2><p>1) 为了上传文件, 我们得先选中一个文件. 一个type为file的input框就够了.</p>
<pre><code class="html">&lt;input id=&quot;input&quot; type=&quot;file&quot;&gt;
</code></pre>
<p>2) 然后用FormData对象包裹📦选中的文件.</p>
<pre><code class="javascript">var input = document.getElementById(&quot;input&quot;),
    formData = new FormData();
formData.append(&quot;file&quot;,input.files[0]);//key可以随意定义,只要后台能理解就行
</code></pre>
<p>3) 定义上传的URL, 以及方法. github上我搭建了一个 <a href="https://github.com/Louiszhai/node-webserver" target="_blank" rel="external">node-webserver</a>, 根据需要可以自行克隆下来npm start后便可调试本篇代码.</p>
<pre><code class="javascript">var url = &quot;http://localhost:10108/test&quot;,
    method = &quot;POST&quot;;
</code></pre>
<h3 id="js文件上传"><a href="#js文件上传" class="headerlink" title="js文件上传"></a>js文件上传</h3><p>4.1) 封装一个用于发送ajax请求的方法.</p>
<pre><code class="javascript">function ajax(url, method, data){
  var xhr = null;
  if(window.XMLHttpRequest) {
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
      } catch (e) { 
        alert(&quot;您的浏览器暂不支持Ajax!&quot;);
      }
    }
  }
  xhr.onerror = function(e){
    console.log(e);
  }
  xhr.open(method, url);
  try{
    setTimeout(function(){
      xhr.send(data);
    });
  }catch(e){
    console.log(&#39;error:&#39;,e);
  }
  return xhr;
}
</code></pre>
<p>4.2) 上传文件并绑定事件.</p>
<pre><code class="javascript">var xhr = ajax(url, method, formData);
xhr.upload.onprogress = function(e){
  console.log(&quot;upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;);
};
xhr.upload.onload = function(){
  console.log(&quot;upload onload.&quot;);
};
xhr.onload = function(){
  console.log(&quot;onload.&quot;);
}
</code></pre>
<h3 id="fetch上传"><a href="#fetch上传" class="headerlink" title="fetch上传"></a>fetch上传</h3><p>5) fetch只要发送一个post请求, 并且body属性设置为formData即可. 遗憾的是, fetch无法跟踪上传的进度信息.</p>
<pre><code class="javascript">fetch(url, {
  method: method,
  body: formData
  }).then(function(res){
  console.log(res);
  }).catch(function(e){
  console.log(e);
});
</code></pre>
<h3 id="jquery文件上传"><a href="#jquery文件上传" class="headerlink" title="jquery文件上传"></a>jquery文件上传</h3><p>6) jq的ajax提供了xhr属性用于自定义各种事件.</p>
<pre><code class="javascript">$.ajax({
  type: method,
  url: url,
  data: formData,
  processData : false,
  contentType : false ,//必须false才会自动加上正确的Content-Type
  xhr: function(){
    var xhr = $.ajaxSettings.xhr();//实际上就是return new window.XMLHttpRequest()对象
    if(xhr.upload) {
      xhr.upload.addEventListener(&quot;progress&quot;, function(e){
        console.log(&quot;jq upload progress:&quot;, e.loaded/e.total*100 + &quot;%&quot;);
      }, false);
      xhr.upload.addEventListener(&quot;load&quot;, function(){
        console.log(&quot;jq upload onload.&quot;);
      });
      xhr.addEventListener(&quot;load&quot;, function(){
        console.log(&quot;jq onload.&quot;);
      });
      return xhr;
    }
  }
});
</code></pre>
<h2 id="ajax请求二进制文件"><a href="#ajax请求二进制文件" class="headerlink" title="ajax请求二进制文件"></a>ajax请求二进制文件</h2><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>处理二进制文件主要使用的是H5的FileReader.</p>
<h2 id="如何等待多个ajax请求完成"><a href="#如何等待多个ajax请求完成" class="headerlink" title="如何等待多个ajax请求完成"></a>如何等待多个ajax请求完成</h2><p>原生js可以使用ES6新增的Promise.</p>
<p>这里先提供一个解析responses的函数.</p>
<pre><code class="javascript">function todo(responses){
  responses.forEach(function(response){
    response.json().then(function(res){
      console.log(res);
    });
  });
}
</code></pre>
<p>原生js使用 <code>Promise.all</code> 方法. 如下:</p>
<pre><code class="javascript">var p1 = fetch(&quot;http://localhost:10108/test1&quot;),
    p2 = fetch(&quot;http://localhost:10108/test2&quot;);
Promise.all([p1, p2]).then(function(responses){
  todo(responses);
  //TODO do somethings
});
//&quot;test1&quot;
//&quot;test2&quot;
</code></pre>
<p>jquery可以使用$.when方法. 该方法接受一个或多个Deferred对象作为参数, 只有全部成功才调用resolved状态的回调函数, 但只要其中有一个失败，就调用rejected状态的回调函数. 其实, jq的Deferred是基于 Promises/A规范实现, 但并非完全遵循. (传送门: <a href="http://www.css88.com/archives/4750/comment-page-1" target="_blank" rel="external">jQuery 中的 Deferred 和 Promises (2)</a> ).</p>
<pre><code class="javascript">var p1 = $.ajax(&quot;http://localhost:10108/test1&quot;),
    p2 = $.ajax(&quot;http://localhost:10108/test2&quot;);
$.when(p1, p2).then(function(res1, res2){
  console.log(res1);//[&quot;test1&quot;, &quot;success&quot;, Object]
  console.log(res2);//[&quot;test2&quot;, &quot;success&quot;, Object]
  //TODO do somethings
});
</code></pre>
<h2 id="ajax与history的兼容"><a href="#ajax与history的兼容" class="headerlink" title="ajax与history的兼容"></a>ajax与history的兼容</h2><p>如今, H5普及, pjax大行其道. pajax 就是 ajax+history.pushState 组合的一种技术. 使用它便可以无刷新通过浏览器前进和后退来改变页面内容.</p>
<p>IE8,9并不能使用 H5的history. 需要使用垫片 <a href="https://github.com/devote/HTML5-History-API" target="_blank" rel="external">HTML5 History API expansion for browsers not supporting pushState, replaceState</a> .</p>
<h3 id="pjax"><a href="#pjax" class="headerlink" title="pjax"></a>pjax</h3><p>pjax简单易用, 仅需要如下三个api:</p>
<ul>
<li>history.pushState(obj, title, url) 表示往页面history末尾新增一个历史项(history entry), 此时history.length会+1.</li>
<li>history.replaceState(obj, title, url) 表示替换当前历史项为新的历史项. 此时history.length保持不变.</li>
<li>window.onpopstate 仅在浏览器前进和后退时触发(history.go(1), history.back() 及location.href=”xxx” 均会触发), 此时可在history.state中拿到刚刚塞进去的state, 即obj对象(其他数据类型亦可).</li>
</ul>
<h2 id="ajax缓存处理"><a href="#ajax缓存处理" class="headerlink" title="ajax缓存处理"></a>ajax缓存处理</h2><p>js中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存.</p>
<pre><code class="javascript">xhr.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;);
xhr.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
//或者 URL 参数后加上  &quot;?timestamp=&quot; + new Date().getTime()
</code></pre>
<h2 id="ajax的错误处理"><a href="#ajax的错误处理" class="headerlink" title="ajax的错误处理"></a>ajax的错误处理</h2><p>前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外)</p>
<p>实际上, <code>$.ajax</code>方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 <code>$.ajax</code> 的error回调便会触发.</p>
<h2 id="ajax调试技巧"><a href="#ajax调试技巧" class="headerlink" title="ajax调试技巧"></a>ajax调试技巧</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><h2 id="后端接口测试技巧"><a href="#后端接口测试技巧" class="headerlink" title="后端接口测试技巧"></a>后端接口测试技巧</h2><h3 id="使用命令测试OPTIONS请求"><a href="#使用命令测试OPTIONS请求" class="headerlink" title="使用命令测试OPTIONS请求"></a>使用命令测试OPTIONS请求</h3><h3 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h3><h2 id="ajax移动端兼容性"><a href="#ajax移动端兼容性" class="headerlink" title="ajax移动端兼容性"></a>ajax移动端兼容性</h2><p>移动端的支持性比较弱, 使用需谨慎. </p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="什么是AJAX"><a href="#什么是AJAX" class="headerlink" title="什么是AJAX"></a>什么是AJAX</h2><p>AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。</p>
<h2 id="为什么要用ajax"><a href="#为什么要用ajax" class="headerlink" title="为什么要用ajax"></a>为什么要用ajax</h2><p>Ajax应用程序的优势在于：</p>
<ol>
<li>通过异步模式，提升了用户体验</li>
<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li>
<li>Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</li>
</ol>
<h2 id="介绍XMLhttprequest对象"><a href="#介绍XMLhttprequest对象" class="headerlink" title="介绍XMLhttprequest对象"></a>介绍XMLhttprequest对象</h2><p>Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。</p>
<h2 id="AJAX请求总共有多少种CALLBACK"><a href="#AJAX请求总共有多少种CALLBACK" class="headerlink" title="AJAX请求总共有多少种CALLBACK"></a>AJAX请求总共有多少种CALLBACK</h2><p>Ajax请求总共有八种Callback</p>
<ul>
<li>onSuccess</li>
<li>onFailure</li>
<li>onUninitialized</li>
<li>onLoading</li>
<li>onLoaded</li>
<li>onInteractive</li>
<li>onComplete</li>
<li>onException</li>
</ul>
<h2 id="在浏览器端如何得到服务器端响应的XML数据"><a href="#在浏览器端如何得到服务器端响应的XML数据" class="headerlink" title="在浏览器端如何得到服务器端响应的XML数据"></a>在浏览器端如何得到服务器端响应的XML数据</h2><p>XMLHttpRequest对象的responseXMl属性</p>
<h2 id="XMLHttpRequest对象在IE和Firefox中创建方式"><a href="#XMLHttpRequest对象在IE和Firefox中创建方式" class="headerlink" title="XMLHttpRequest对象在IE和Firefox中创建方式"></a>XMLHttpRequest对象在IE和Firefox中创建方式</h2><p>IE中通过new ActiveXObject()得到，Firefox中通过newXMLHttpRequest()得到</p>
<h2 id="XMLHttpRequest对象的常用方法和属性"><a href="#XMLHttpRequest对象的常用方法和属性" class="headerlink" title="XMLHttpRequest对象的常用方法和属性"></a>XMLHttpRequest对象的常用方法和属性</h2><p><strong>方法</strong></p>
<p><code>open(“method”,”URL”)</code> 建立对服务器的调用，第一个参数是HTTP请求方式可以为GET，POST或任何服务器所支持的您想调用的方式。第二个参数是请求页面的URL。</p>
<p><code>send()</code>方法，发送具体请求</p>
<p><code>abort()</code>方法，停止当前请求</p>
<p><strong>熟悉</strong></p>
<p><code>readyState</code>属性：请求的状态，有5个可取值</p>
<ul>
<li>0=未初始化</li>
<li>1=正在加载</li>
<li>2=以加载</li>
<li>3=交互中</li>
<li>4=完成</li>
</ul>
<p><code>responseText</code>属性：服务器的响应，表示为一个串</p>
<p><code>reponseXML</code> 属性：服务器的响应，表示为XML</p>
<p><code>status</code>属性：服务器的HTTP状态码，200对应ok，400对应error</p>
<h2 id="AJAX有哪些优点和缺点？"><a href="#AJAX有哪些优点和缺点？" class="headerlink" title="AJAX有哪些优点和缺点？"></a>AJAX有哪些优点和缺点？</h2><p><strong>优点</strong></p>
<ol>
<li>最大的一点是页面无刷新，用户的体验非常好。</li>
<li>使用异步方式与服务器通信，具有更加迅速的响应能力。</li>
<li>可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</li>
<li>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>ajax不支持浏览器back按钮。</li>
<li>安全问题 AJAX暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>破坏了程序的异常机制。</li>
<li>不容易调试。</li>
</ol>
<h2 id="jquery-ajax实现"><a href="#jquery-ajax实现" class="headerlink" title="jquery ajax实现"></a>jquery ajax实现</h2><pre><code class="javascript">$.ajax({
    url:&#39;/comm/test1.php&#39;,
    type:&#39;POST&#39;, //GET
    async:true,    //或false,是否异步
    data:{
        name:&#39;yang&#39;,age:25
    },
    timeout:5000,    //超时时间
    dataType:&#39;json&#39;,    //返回的数据格式：json/xml/html/script/jsonp/text
    beforeSend:function(xhr){
        console.log(xhr)
        console.log(&#39;发送前&#39;)
    },
    success:function(data,textStatus,jqXHR){
        console.log(data)
        console.log(textStatus)
        console.log(jqXHR)
    },
    error:function(xhr,textStatus){
        console.log(&#39;错误&#39;)
        console.log(xhr)
        console.log(textStatus)
    },
    complete:function(){
        console.log(&#39;结束&#39;)
    }
})
</code></pre>
<h2 id="原生js-ajax实现"><a href="#原生js-ajax实现" class="headerlink" title="原生js ajax实现"></a>原生js ajax实现</h2><pre><code class="javascript">$(&#39;#send&#39;).click(function(){
    //请求的5个阶段，对应readyState的值
        //0: 未初始化，send方法未调用；
        //1: 正在发送请求，send方法已调用；
        //2: 请求发送完毕，send方法执行完毕；
        //3: 正在解析响应内容；
        //4: 响应内容解析完毕；
    var data = &#39;name=yang&#39;;
    var xhr = new XMLHttpRequest();   //创建一个ajax对象
    xhr.onreadystatechange = function(event){    //对ajax对象进行监听
        if(xhr.readyState == 4){    //4表示解析完毕
            if(xhr.status == 200){    //200为正常返回
                console.log(xhr)
            }
        }
    };
    xhr.open(&#39;POST&#39;,&#39;url&#39;,true);    //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步
    xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;);    //可有可无
    xhr.send(data);        //发送
});
</code></pre>
<h2 id="与-post-get-getJSON-有什么不同"><a href="#与-post-get-getJSON-有什么不同" class="headerlink" title="与$.post , $.get ,$.getJSON 有什么不同"></a>与$.post , $.get ,$.getJSON 有什么不同</h2><p>\$.post，这个函数其实就是对\$.ajax进行了更进一步的封装，减少了参数，简化了操作，但是运用的范围更小了。\$.post简化了数据提交方式，只能采用POST方式提交。只能是异步访问服务器，不能同步访问，不能进行错误处理。在满足这些情况下，我们可以使用这个函数来方便我们的编程，它的主要几个参数，像method，async等进行了默认设置，我们不可以改变的。</p>
<h2 id="jquery-ajax中都支持哪些数据类型"><a href="#jquery-ajax中都支持哪些数据类型" class="headerlink" title="jquery ajax中都支持哪些数据类型"></a>jquery ajax中都支持哪些数据类型</h2><blockquote>
<p>DataType<br>类型：String<br>预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。</p>
</blockquote>
<p>可用值: json/xml/html/script/jsonp/text</p>
<h2 id="json-和-jsonp-的区别"><a href="#json-和-jsonp-的区别" class="headerlink" title="json 和 jsonp 的区别"></a>json 和 jsonp 的区别</h2><p>SON是一种数据交换格式，而JSONP是一种s创造出的一种非官方跨域数据交互协议。 </p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000008697448" target="_blank" rel="external">Ajax知识体系大梳理</a></li>
<li><a href="http://blog.csdn.net/chow__zh/article/details/9149811" target="_blank" rel="external">经典的20道AJAX面试题</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WEB安全]]></title>
      <url>/2017/08/02/%E5%89%8D%E7%AB%AF/%E8%B6%8B%E5%8A%BF%E6%8A%80%E6%9C%AF/WEB%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<p>本文介绍web安全。</p>
<p>工作中有接触过一部分，系统整理一下。后续需要补上攻防代码。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><p>Node.js 的 <code>crypto</code> 模块封装了诸多的加密功能, 包括 OpenSSL 的哈希、HMAC、加密、解密、签名和验证函数等.</p>
<p>在客户端加密, 是增加传输的过程中被第三方嗅探到密码后破解的成本. 对于游戏, 在客户端加密是防止外挂/破解等. 在服务端加密 (如 md5) 是避免管理数据库的 DBA 或者攻击者攻击数据库之后直接拿到明文密码, 从而提高安全性.</p>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p> SSL (Secure Socket Layer)的主要用途是:</p>
<ol>
<li>认证用户和服务器, 确保数据发送到正确的客户机和服务器;</li>
<li>加密数据以防止数据中途被窃取;</li>
<li>维护数据的完整性, 确保数据在传输过程中不被改变.</li>
</ol>
<p>存在三个特性:</p>
<ul>
<li>机密性：SSL协议使用密钥加密通信数据</li>
<li>可靠性：服务器和客户都会被认证, 客户的认证是可选的</li>
<li><p>完整性：SSL协议会对传送的数据进行完整性检查</p>
<p>IETF 把 SSL 标准化/强化. 标准化之后的名称改为传输层安全协议 (Transport Layer Security, TLS). 很多相关的文章都把这两者并列称呼 (TLS/SSL), 因为这两者可以视作同一个东西的不同阶段.</p>
</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>公钥基础设施 (Public Key Infrastructure, PKI) 是一种遵循标准的, 利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范. 其基础建置包含认证中心 (Certification Authority, CA) 、注册中心 (Register Authority, RA) 、目录服务 (Directory Service, DS) 服务器.</p>
<p>由 RA 统筹、审核用户的证书申请, 将证书申请送至 CA 处理后发出证书, 并将证书公告至 DS 中. 在使用证书的过程中, 除了对证书的信任关系与证书本身的正确性做检查外, 并透过产生和发布证书废止列表 (Certificate Revocation List, CRL) 对证书的状态做确认检查, 了解证书是否因某种原因而遭废弃. 证书就像是个人的身分证, 其内容包括证书序号、用户名称、公开金钥 (Public Key) 、证书有效期限等.</p>
<p>在 TLS/SLL 中你可以使用 OpenSSL 来生成 TLS/SSL 传输时用来认证的 public/private key. 不过这个 public/private key 是自己生成的, 而通过 PKI 基础设施可以获得权威的第三方证书 (key) 从而加密 HTTP 传输安全. 目前博客圈子里比较流行的是 <a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt 签发免费的 HTTPS 证书</a>.</p>
<p>需要注意的是, 如果 PKI 受到攻击, 那么 HTTPS 也一样不安全.</p>
<p>此外有的 CA 机构以邮件方式认证, 那么当某个网站的邮件服务收到攻击/渗透, 那么攻击者也可能以此从 CA 机构获取权威的正确的证书.</p>
<h3 id="CA工作原理"><a href="#CA工作原理" class="headerlink" title="CA工作原理"></a>CA工作原理</h3><p>现在假设客户A向银行B传送数字信息，为了保证信息传送的真实性、完整性和不可否认性，需要对要传送的信息进行数字加密和数字签名，其传送过程如下： </p>
<ul>
<li>客户A准备好要传送的数字信息（明文）。（<strong>准备明文</strong>） </li>
</ul>
<ul>
<li>客户A对数字信息进行哈希（hash）运算，得到一个信息摘要。（<strong>准备摘要</strong>） </li>
</ul>
<ul>
<li>客户A用自己的私钥（SK）对信息摘要进行加密得到客户A的数字签名，并将其附在数字信息上。（<strong>用私钥对数字信息进行数字签名</strong>）　 </li>
<li>客户A随机产生一个加密密钥（DES密钥），并用此密钥对要发送的信息进行加密，形成密文。（<strong>生成密文</strong>） </li>
<li>客户A用双方共有的公钥（PK）对刚才随机产生的加密密钥进行加密，将加密后的DES密钥连同密文一起传送给乙。（<strong>用公钥对DES密钥进行加密</strong>）　　 </li>
<li>银行B收到客户A传送过来的密文和加过密的DES密钥，先用自己的私钥（SK）对加密的DES密钥进行解密，得到DES密钥。（<strong>用私钥对DES密钥解密</strong>）　　 </li>
<li>银行B然后用DES密钥对收到的密文进行解密，得到明文的数字信息，然后将DES密钥抛弃（即DES密钥作废）。（<strong>解密文</strong>）　　 </li>
<li>银行B用双方共有的公钥（PK）对客户A的数字签名进行解密，得到信息摘要。银行B用相同的hash算法对收到的明文再进行一次hash运算，得到一个新的信息摘要。　　 （<strong>用公钥解密数字签名</strong>） </li>
<li>银行B将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。（<strong>对比信息摘要和信息</strong>） </li>
</ul>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><p>跨站脚本 (Cross-Site Scripting, XSS) 是一种代码注入方式， 其注入方式很简单包括但不限于 JavaScript / VBScript / CSS / Flash 等.</p>
<p>当其他用户浏览到这些网页时, 就会执行这些恶意脚本, 对用户进行 Cookie 窃取/会话劫持/钓鱼欺骗等各种攻击. 其原理, 如使用 js 脚本收集当前用户环境的信息 (Cookie 等), 然后通过 img.src, Ajax, onclick/onload/onerror 事件等方式将用户数据传递到攻击者的服务器上. </p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><strong>反射型XSS</strong>:非持久化，欺骗用户去点击链接,攻击代码包含在url中,被用户点击之后执行攻击代码.</li>
<li><strong>存储型XSS</strong>:持久型,攻击提交恶意代码到服务器，服务器存储该段代码,这样当其他用户请求后，服务器返回并发给用户，用户浏览此类页面时就可能受到攻击。例如:恶意用户的HTML或JS输入服务器-&gt;进入数据库-&gt;服务器响应时查询数据库-&gt;用户浏览器。</li>
</ul>
<h3 id="防范与过滤"><a href="#防范与过滤" class="headerlink" title="防范与过滤"></a>防范与过滤</h3><ul>
<li>输入编码过滤:对于每一个输入，在客户端和服务器端验证是否合法字符，长度是否合法，格式是否正确,对字符进行转义.非法字符过滤.</li>
<li>输出编码过滤:对所有要动态输出到页面的内容，<strong>进行相关的编码和转义</strong>.主要有HTML字符过滤和转义, JS脚本转义过滤. url转义过滤.</li>
<li>设置http-only,避免攻击脚本读取cookie.</li>
</ul>
<h3 id="攻防流程"><a href="#攻防流程" class="headerlink" title="攻防流程"></a>攻防流程</h3><h4 id="升级攻击"><a href="#升级攻击" class="headerlink" title="升级攻击"></a>升级攻击</h4><h5 id="append的利用"><a href="#append的利用" class="headerlink" title="append的利用"></a>append的利用</h5><p>直接给innerHTML赋值一段js，是无法被执行的。但是，jquery的append可以做到，究其原因，就是因为jquery会在将append元素变为fragment的时候，找到其中的script标签，再使用eval执行一遍。jquery的append使用的方式也是innerHTML。而innerHTML是会将unicode码转换为字符实体的。</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
    $username=&quot;\u003cscript\u003ealert(&#39;okok&#39;);&quot;;
?&gt;
$(&#39;#username_info&#39;).append(&quot;&lt;?php echo htmlentities($username);?&gt;&quot;);
</code></pre>
<p>虽然进行了转义，注入的代码还是会再次被执行。</p>
<h5 id="img标签的再次利用"><a href="#img标签的再次利用" class="headerlink" title="img标签的再次利用"></a>img标签的再次利用</h5><p>img标签，在加载图片失败的时候，会调用该元素上的onerror事件。我们正可以利用这种方式来进行攻击。</p>
<p><strong>Case</strong></p>
<pre><code class="php">&lt;?php
    $imgsrc=&quot;\&quot; onerror=\&quot;javascript:alert(&#39;侯医生&#39;);\&quot;&quot;;
?&gt;
</code></pre>
<p>解决方法：接着进行转义</p>
<pre><code class="javascript">&lt;img src=&quot;&lt;?php echo htmlentities($imgsrc);?&gt;&quot; /&gt;
</code></pre>
<h5 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h5><p>innerHTML赋值的script标签，不会被执行，但是innerHTML赋值一个img标签是可以被识别的。我们把img标签的左右尖括号，使用unicode进行伪装，让转义方法认不出来，即使innerHTML也可以利用上了</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
    $username=&quot;\u003cimg src=\&#39;\&#39; onerror=javascript:alert(\&#39;okok\&#39;);\u003e&quot;;
?&gt;
&lt;script&gt;
      document.getElementById(&#39;username_info&#39;).innerHTML = &quot;&lt;?php echo htmlentities($username);?&gt;&quot;;
&lt;/script&gt;
</code></pre>
<h4 id="升级防御"><a href="#升级防御" class="headerlink" title="升级防御"></a>升级防御</h4><p>将输出的字符串中的<code>\</code>反斜杠进行转义(json转义)。这样，<code>\</code>就不会被当做unicode码的开头来被处理了。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">document.getElementById(&#39;username_info&#39;).innerHTML = &lt;?php echo json_encode(htmlentities($username));?&gt;;
</code></pre>
<h4 id="XSS再升级"><a href="#XSS再升级" class="headerlink" title="XSS再升级"></a>XSS再升级</h4><p>有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。</p>
<p><strong>Case</strong></p>
<pre><code class="html">&lt;script&gt;
  var param = /=(.+)$/.exec(location.search);
  var value = decodeURIComponent(param[1]);
  $(&#39;#username_info&#39;).append(value);
&lt;/script&gt;
</code></pre>
<h4 id="防御再次升级"><a href="#防御再次升级" class="headerlink" title="防御再次升级"></a>防御再次升级</h4><p>这种从url中获取的信息，最好由后端获取，在前端转义后再行输出</p>
<p>使用url中的参数的时候要小心，更不要拿URL中的参数去eval。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">&lt;script&gt;
    var value = decodeURIComponent(&quot;&lt;?php echo htmlentities($_GET[&#39;username&#39;]);?&gt;&quot;);
    $(&#39;#username_info&#39;).append(value);
&lt;/script&gt;
</code></pre>
<h4 id="保护好你的cookie"><a href="#保护好你的cookie" class="headerlink" title="保护好你的cookie"></a>保护好你的cookie</h4><p>使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。</p>
<h3 id="CPS-策略"><a href="#CPS-策略" class="headerlink" title="CPS 策略"></a>CPS 策略</h3><p>计算脚本的 hashes 值，设置 CSP 头</p>
<p>策略指令可以参见 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="external">CSP Policy Directives</a>以及<a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="external">阮一峰的博文</a>, <a href="https://imququ.com/post/content-security-policy-reference.html" target="_blank" rel="external">屈大神的博文</a></p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="什么是CSRF攻击？"><a href="#什么是CSRF攻击？" class="headerlink" title="什么是CSRF攻击？"></a>什么是CSRF攻击？</h3><p>跨站请求伪造 (Cross-Site Request Forgery) 是一种伪造跨站请求的攻击方式.</p>
<p>例如利用你在 A 站 (攻击目标) 的 cookie / 权限等, 在 B 站 (恶意/钓鱼网站) 拼装 A 站的请求.</p>
<h3 id="如何攻击？"><a href="#如何攻击？" class="headerlink" title="如何攻击？"></a>如何攻击？</h3><h4 id="要合理使用post与get"><a href="#要合理使用post与get" class="headerlink" title="要合理使用post与get"></a>要合理使用post与get</h4><p>通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。</p>
<p><strong>Case</strong></p>
<p>你开发的网站中，有一个购买商品的操作，而商品ID图个省事儿，就使用了url中的get参数。</p>
<pre><code class="php+HTML">&lt;?php
// 从cookie中获取用户名，看似稳妥
$username = $_COOKIE[&#39;username&#39;];
$productId = $_GET[&#39;pid&#39;];
?&gt;

&lt;?php
echo $username . &#39;买入商品：&#39; . $productId;
?&gt;

//黑客的网站
&lt;img src=&quot;http://localhost:8082/lab/xsrflab/submit.php?pid=1&quot; /&gt;
</code></pre>
<p>所以，我们日常的开发，还是要遵循提交业务，严格按照post请求去做的。更不要使用jsonp去做提交型的接口，这样非常的危险。</p>
<h4 id="csrf攻击升级"><a href="#csrf攻击升级" class="headerlink" title="csrf攻击升级"></a>csrf攻击升级</h4><p>如果你使用了post请求来处理关键业务的，还是有办法可以破解的。</p>
<p><strong>Case</strong></p>
<pre><code class="php+HTML">&lt;?php
$username = $_COOKIE[&#39;username&#39;];
// 换为post了，可以规避黑客直接的提交
$productId = $_POST[&#39;pid&#39;];
?&gt;

&lt;?php
echo $username . &#39;买入商品：&#39; . $productId;
?&gt;

//黑客的网站
&lt;button id=&quot;clickme&quot;&gt;点我看相册&lt;/button&gt;
&lt;script&gt;
  $(&#39;#clickme&#39;).on(&#39;click&#39;, function () {
    // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。
    $(&#39;#myform&#39;).submit();
  });
&lt;/script&gt;
&lt;form id=&quot;myform&quot; style=&quot;display:none;&quot; target=&quot;myformer&quot; method=&quot;post&quot; action=&quot;http://myhost:8082/lab/xsrflab/submit.php&quot;&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;1&quot;&gt;
&lt;/form&gt;
&lt;iframe name=&quot;myformer&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p><strong>这种情况如何防御？</strong></p>
<p>最简单的办法就是加<strong>验证码</strong>，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作</p>
<p>另一种方式，就是在用访问的页面中，都种下验证用的<strong>token</strong>，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ol>
<li>在 HTTP 头中自定义属性并验证</li>
<li>检查 CSRF token.</li>
<li>cookie中加入hash随机数.</li>
<li>通过检查来过滤简单的 CSRF 攻击, 主要检查一下两个 header:</li>
</ol>
<ul>
<li><p>Origin Header</p>
</li>
<li><p>Referer Header</p>
</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人 (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独立的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对方直接对话, 但事实上整个会话都被攻击者完全控制. 在中间人攻击中, 攻击者可以拦截通讯双方的通话并插入新的内容.</p>
<p>目前比较常见的是在公共场所放置精心准备的免费 wifi, 劫持/监控通过该 wifi 的流量. 或者攻击路由器, 连上你家 wifi 攻破你家 wifi 之后在上面劫持流量等.</p>
<p>对于通信过程中的 MITM, 常见的方案是通过 PKI / TLS 预防, 及时是通过存在第三方中间人的 wifi 你通过 HTTPS 访问的页面依旧是安全的. 而 HTTP 协议是明文传输, 则没有任何防护可言.</p>
<p>如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。</p>
<p>不常见的还有强力的互相认证, 你确认他之后, 他也确认你一下; 延迟测试, 统计传输时间, 如果通讯延迟过高则认为可能存在第三方中间人; 等等.</p>
<h2 id="SQL-NoSQL-注入"><a href="#SQL-NoSQL-注入" class="headerlink" title="SQL/NoSQL 注入"></a>SQL/NoSQL 注入</h2><p>注入攻击是指当所执行的一些操作中有部分由用户传入时, 用户可以将其恶意逻辑注入到操作中. 当你使用 eval, new Function 等方式执行的字符串中有用户输入的部分时, 就可能被注入攻击. 上文中的 XSS 就属于一种注入攻击. </p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>Sql 注入是网站常见的一种注入攻击方式. 其原因主要是由于登录时需要验证用户名/密码</p>
<p><strong>Case</strong></p>
<p>例如上传密码为 <code>&#39;; DROP TABLE users; --</code> 使得最终执行的内容为:</p>
<pre><code class="sql">SELECT * FROM users WHERE usernae = &#39;myName&#39; AND password = &#39;&#39;; DROP TABLE users; --&#39;;
</code></pre>
<p>其能实现的功能, 包括但不限于删除数据 (经济损失), 篡改数据 (密码等), 窃取数据 (网站管理权限, 用户数据) 等. </p>
<p>防治手段常见于:</p>
<ul>
<li>给表名/字段名加前缀 (避免被猜到)</li>
<li>报错隐藏表信息 (避免被看到, 12306 早起就出现过的问题)</li>
<li>过滤可以拼接 SQL 的关键字符</li>
<li>对用户输入进行转义</li>
<li>验证用户输入的类型 (避免 limit, order by 等注入)</li>
<li>等…</li>
</ul>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p><strong>Case</strong></p>
<pre><code class="javascript">let {user, pass, age} = ctx.query;

db.collection.find({
  user, pass,
  $where: `this.age &gt;= ${age}`
})
</code></pre>
<h2 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h2><blockquote>
<p>DDoS即Distributed Denial of Service，分布式拒绝服务。也就是攻击者借助或者利用服务器技术，将多个计算机（肉鸡或僵尸机）联合起来作为攻击平台，对一个或者多个目标服务器，同一时间发送大量垃圾信息，或利用某种干扰信息的方式，导致目标服务器无法及时响应正常用户正常请求，或者直接导致目标服务器宕机，从而无法为正常用户提供服务的一种攻击行为。</p>
</blockquote>
<p>攻击方式:</p>
<ul>
<li>端口扫描攻击</li>
<li>ping洪水（flooding）攻击</li>
<li>SYN洪水（flooding）攻击</li>
<li>FTP跳转攻击</li>
</ul>
<p>防范手段:</p>
<ul>
<li>保证服务器系统的安全,确保服务器软件没有任何漏洞，防止攻击者入侵。</li>
<li>确保服务器采用最新系统，并打上安全补丁。</li>
<li>在服务器上删除未使用的服务，关闭未使用的端口。</li>
<li>对于服务器上运行的网站，确保其打了最新的补丁，没有安全漏洞。</li>
<li>隐藏服务器的真实IP地址</li>
</ul>
<h2 id="通用防范措施"><a href="#通用防范措施" class="headerlink" title="通用防范措施"></a>通用防范措施</h2><ol>
<li>开发时要提防用户产生的内容，要对用户输入的信息进行层层检测</li>
<li>要注意对用户的输出内容进行过滤(进行转义等)</li>
<li>重要的内容记得要加密传输(无论是利用https也好，自己加密也好)</li>
<li>get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。</li>
<li>对于URL上携带的信息，要谨慎使用。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000010913697" target="_blank" rel="external">前端需要知道的web安全知识</a></li>
<li><a href="http://wlh269.iteye.com/blog/733398" target="_blank" rel="external">CA认证简单介绍和工作流程</a></li>
<li><a href="https://segmentfault.com/a/1190000006672214" target="_blank" rel="external">[聊一聊系列]聊一聊WEB前端安全那些事儿</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>/2017/06/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>本文介绍跨域的知识</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>页面请求的url地址，必须与浏览器上url地址处于同域上（即域名，端口，协议相同）。</p>
<p>JS出于安全，不允许跨域调用其他页面的对象。</p>
<ul>
<li>其限制之一是不能通过ajax的方法去请求不同源中的文档。 </li>
<li>第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。</li>
</ul>
<p>特别注意两点：</p>
<ul>
<li>第一：如果是协议和端口造成的跨域问题“前台”是无能为力的</li>
<li>第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。“URL的首部”可以理解为“协议, 域名 和 端口 必须匹配”。</li>
</ul>
<p><strong>Case</strong></p>
<p>域名和域名对应ip，不允许：<code>http://www.a.com/a.js</code> 与 <code>http://70.32.92.74/b.js</code></p>
<p>主域相同，子域不同，不允许：<code>http://www.a.com/a.js</code> 与 <code>http://script.a.com/b.js</code></p>
<p>同一域名，不同二级域名，不允许（cookie这种情况下也不允许访问)：<code>http://www.a.com/a.js</code> 与 <code>http://a.com/b.js</code></p>
<h2 id="解决跨域请求的方式"><a href="#解决跨域请求的方式" class="headerlink" title="解决跨域请求的方式"></a>解决跨域请求的方式</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="Ans1"><a href="#Ans1" class="headerlink" title="Ans1"></a>Ans1</h5><p>ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>
<h5 id="Ans2"><a href="#Ans2" class="headerlink" title="Ans2"></a>Ans2</h5><p>第三方产生的响应为json数据的包装（故称之为jsonp，即json padding），形如：</p>
<pre><code class="javascript"> callback({&quot;name&quot;:&quot;hax&quot;,&quot;gender&quot;:&quot;Male&quot;})
</code></pre>
<p>这样浏览器会调用callback函数，并传递解析后json对象作为参数。本站脚本可在callback函数里处理所传入的数据。  </p>
<h5 id="Ans3"><a href="#Ans3" class="headerlink" title="Ans3"></a>Ans3</h5><p>JSONP是一种非正式传输协议，该协议的一个要点就是<strong>允许用户传递一个callback参数给服务端</strong>，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="1-ajax"><a href="#1-ajax" class="headerlink" title="1. $.ajax"></a>1. $.ajax</h5><p><strong>Case</strong></p>
<p>index.html</p>
<pre><code class="javascript">&lt;script&gt;  
    $.ajax({  
        url:&quot;http://localhost:3000/users/userlist&quot;,  
        type:&quot;get&quot;,  
        dataType:&quot;jsonp&quot;,
        dataFilter:function(json){    
          console.log(json);  
          return json;    
        },
        success:function(data){  
            console.log(data);  
        },
        error:function(XMLHttpRequest, textStatus, errorThrown){
          console.log(XMLHttpRequest.status);
          console.log(XMLHttpRequest.readyState);
          console.log(textStatus);
        }  
    });  
&lt;/script&gt;
</code></pre>
<p>Node.js 服务器代码</p>
<pre><code class="javascript">router.get(&quot;/userlist&quot;, function (req, res, next) {  
    var callback=req.query[&quot;callback&quot;];  
    var user = {name: &#39;Mr.Cao&#39;, gender: &#39;male&#39;, career: &#39;IT Education&#39;};  
    res.write(callback+&quot;(&quot;+ JSON.stringify(user)+&quot;)&quot;);  
    res.end();  
});
</code></pre>
<h5 id="2-getJSON"><a href="#2-getJSON" class="headerlink" title="2. $.getJSON"></a>2. $.getJSON</h5><p>jQuery的<code>$.getJSON</code>方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>
<h5 id="3-原生实现"><a href="#3-原生实现" class="headerlink" title="3. 原生实现"></a>3. 原生实现</h5><p><strong>Case</strong></p>
<p>假设要传输的数据 data 格式如下：</p>
<pre><code class="json">{
    name: &quot;chiaki&quot;,
    id&quot;: &quot;3001&quot;
}
</code></pre>
<p>由于是通过 <code>script</code> 标签进行请求，所以上述传输过程根本上是以下的形式：</p>
<pre><code class="html">&lt;script src = &#39;http://localhost:3001/ajax/deal?callback=jsonpCallback&amp;name=chiaki&amp;id=3001&amp;_=1473164876032&#39;&gt;&lt;/script&gt;
</code></pre>
<p><em>服务器 3000</em>请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback：</p>
<pre><code class="html">&lt;script src = &#39;http://localhost:3001/jsonServerResponse?jsonp=jsonpCallback&#39;&gt;&lt;/script&gt;

function jsonpCallback(data) {
    console.log(&quot;jsonpCallback: &quot;+data.name)
}
</code></pre>
<p><em>服务器 3001</em>上对应的处理函数：</p>
<pre><code class="javascript">app.get(&#39;/jsonServerResponse&#39;, function(req, res) {
    var cb = req.query.jsonp //这里得到请求页面的回调函数
    console.log(cb)
      //思考一下为什么这里要这样写
    var data = &#39;var data = {&#39; + &#39;name: $(&quot;#name&quot;).val() + &quot; - server 3001 jsonp process&quot;,&#39; + &#39;id: $(&quot;#id&quot;).val() + &quot; - server 3001 jsonp process&quot;&#39; + &#39;};&#39;
    var debug = &#39;console.log(data);&#39; //打印var data=&quot;&quot;;
    var callback = &#39;$(&quot;#submit&quot;).click(function() {&#39; + data + cb + &#39;(data);&#39; + debug + &#39;});&#39; 
    res.send(callback) //返回的是一个点击按钮的事件  
    res.end()
})
</code></pre>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>这种方式无法发送post请求</li>
<li>它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用比较方便；它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；</li>
<li>兼容性更好，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>在请求完毕后可以通过调用callback的方式回传结果。</li>
</ul>
<h3 id="document-domain跨子域"><a href="#document-domain跨子域" class="headerlink" title="document.domain跨子域"></a>document.domain跨子域</h3><p>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    function test(){
        var iframe = document.getElementById(&#39;￼ifame&#39;);
        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的
        var doc = win.document;//这里获取不到iframe里的document对象
        var name = win.name;//这里同样获取不到window对象的name属性
    }
&lt;/script&gt;
&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;
</code></pre>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>这个时候，document.domain就可以派上用场了，我们只要把<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a>和<a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</p>
</blockquote>
<p>在页面<a href="http://www.damonare.cn/a.html" target="_blank" rel="external">http://www.damonare.cn/a.html</a> 中设置document.domain:</p>
<pre><code class="javascript">&lt;iframe id = &quot;iframe&quot; src=&quot;http://damonare.cn/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    document.domain = &#39;damonare.cn&#39;;//设置成主域
    function test(){
        alert(document.getElementById(&#39;￼iframe&#39;).contentWindow);//contentWindow 可取得子窗口的 window 对象
    }
&lt;/script&gt;
</code></pre>
<p>在页面 <a href="http://damonare.cn/b.html" target="_blank" rel="external">http://damonare.cn/b.html</a>  中也设置document.domain:</p>
<pre><code class="javascript">&lt;script type=&quot;text/javascript&quot;&gt;
    document.domain = &#39;damonare.cn&#39;;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同
&lt;/script&gt;
</code></pre>
<blockquote>
<p><strong>Note:修改document.domain的方法只适用于不同子域的框架间的交互。</strong></p>
<p><strong>附：主域名与子域名的区别</strong></p>
<p>主域名：</p>
<p>由两个或两个以上的字母构成，中间由点号隔开，整个域名只有1个点号。比如：csdn.net</p>
<p>子域名：</p>
<p>是在主域名之下的域名，域名内容会有多个点号。比如：blog.csdn.net </p>
</blockquote>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>如果修改了document.domain，则在某些机器上的IE678里，获取location.href有权限异常。</li>
<li>如果页面修改了document.domain，则它包含的iframe，必须也设domain，才能进行交互。就算是同域的页面也必须要设。</li>
<li>设置document.doamin，也会影响到其它跟iframe有关的功能。典型的功能如：富文本编辑器（因为是iframe来做富文本编辑器的）、ajax的前进后退（因为IE67要用到iframe，参见：<a href="http://blog.sina.com.cn/s/blog_6e7f61f30100sddm.html" target="_blank" rel="external">IE6与location.hash和Ajax历史记录</a>）</li>
<li>设置document.doamin，导致ie6下无法向一个iframe提交表单。这一篇文章里列了问题象与解决方案：<a href="http://www.cnblogs.com/pigtail/archive/2012/06/06/2528136.html" target="_blank" rel="external">IE6与location.hash和Ajax历史记录</a></li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。</li>
<li>如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</li>
</ol>
<h3 id="location-hash（两个iframe之间），又称FIM"><a href="#location-hash（两个iframe之间），又称FIM" class="headerlink" title="location.hash（两个iframe之间），又称FIM"></a>location.hash（两个iframe之间），又称FIM</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><blockquote>
<p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，<strong>URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录</strong>。此方法的<strong>原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息</strong>（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），<strong>并通过监听自己的URL的变化来接收消息。</strong></p>
</blockquote>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>造成一些不必要的浏览器历史记录</li>
<li>有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变</li>
<li>数据直接暴露在了url中，数据容量和类型都有限等。</li>
</ul>
<p><strong>Case</strong></p>
<p>假如父页面是baidu.com/a.html,iframe嵌入的页面为google.com/b.html（此处省略了域名等url属性），要实现此两个页面间的通信可以通过以下方法。</p>
<ul>
<li>a.html传送数据到b.html</li>
<li>a.html下修改iframe的src为google.com/b.html#paco</li>
<li>b.html监听到url发生变化，触发相应操作</li>
<li>b.html传送数据到a.html，由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe<ul>
<li>b.html下创建一个隐藏的iframe，此iframe的src是baidu.com域下的，并挂上要传送的hash数据，如src=”<a href="http://www.baidu.com/proxy.html#data”" target="_blank" rel="external">http://www.baidu.com/proxy.html#data”</a></li>
<li>proxy.html监听到url发生变化，修改a.html的url（因为a.html和proxy.html同域，所以proxy.html可修改a.html的url hash）</li>
<li>a.html监听到url发生变化，触发相应操作</li>
</ul>
</li>
</ul>
<p>b.html页面的关键代码如下:</p>
<pre><code class="javascript">try {  
    parent.location.hash = &#39;data&#39;;  
} catch (e) {  
    // ie、chrome的安全机制无法修改parent.location.hash，  
    var ifrproxy = document.createElement(&#39;iframe&#39;);  
    ifrproxy.style.display = &#39;none&#39;;  
    ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;;  
    document.body.appendChild(ifrproxy);  
}
</code></pre>
<p>proxy.html页面的关键代码如下 :</p>
<pre><code class="javascript">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  
parent.parent.location.hash = self.location.hash.substring(1);
</code></pre>
<h3 id="通过CORS跨域"><a href="#通过CORS跨域" class="headerlink" title="通过CORS跨域"></a>通过CORS跨域</h3><blockquote>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
</blockquote>
<p><strong>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</strong></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>CORS要前后端同时做配置。</p>
<h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>纯js的ajax请求。</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest(); //ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
xhr.open(&quot;￼GET&quot;, &quot;/haorooms&quot;,true);
xhr.send();
</code></pre>
<p>以上的haorooms是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>
<pre><code class="javascript">var xhr = new XMLHttpRequest();//ie6以下用new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
xhr.open(&quot;￼GET&quot;, &quot;http://www.haorooms.com/CORS&quot;,true);
xhr.send();
</code></pre>
<p>当然，你也可以用jquery的ajax进行。</p>
<h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><p>PHP：只需要使用如下的代码设置即可。</p>
<pre><code class="php"> header(&quot;Access-Control-Allow-Origin:http://www.haorooms.com&quot;);
</code></pre>
<h4 id="CORS和JSONP对比"><a href="#CORS和JSONP对比" class="headerlink" title="CORS和JSONP对比"></a>CORS和JSONP对比</h4><ul>
<li>JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。</li>
<li>使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。</li>
<li>JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。</li>
</ul>
<h3 id="H5新特性window-postMessage"><a href="#H5新特性window-postMessage" class="headerlink" title="H5新特性window.postMessage"></a>H5新特性window.postMessage</h3><p>这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。</p>
<p>postMessage的使用方法：</p>
<pre><code class="javascript">otherWindow.postMessage(message, targetOrigin);
</code></pre>
<ul>
<li>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>
<li>message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)</li>
<li>targetOrigin: 是限定消息接收范围，不限制请使用 *</li>
</ul>
<p><strong>Case</strong></p>
<p>A页面通过postMessage方法发送消息：</p>
<pre><code class="javascript">window.onload = function() {  
    var ifr = document.getElementById(&#39;ifr&#39;);  
    var targetOrigin = &quot;http://www.google.com&quot;;  
    ifr.contentWindow.postMessage(&#39;hello world!&#39;, targetOrigin);  
};
</code></pre>
<p>B页面通过message事件监听并接受消息:</p>
<pre><code class="javascript">var onmessage = function (event) {  
  var data = event.data;//消息  
  var origin = event.origin;//消息来源地址  
  var source = event.source;//源Window对象  
  if(origin==&quot;http://www.baidu.com&quot;){  
    console.log(data);//hello world!  
  }  
};  
if (typeof window.addEventListener != &#39;undefined&#39;) {  
  window.addEventListener(&#39;message&#39;, onmessage, false);  
} else if (typeof window.attachEvent != &#39;undefined&#39;) {  
  //for ie  
  window.attachEvent(&#39;onmessage&#39;, onmessage);  
}
</code></pre>
<h3 id="通过window-name跨域"><a href="#通过window-name跨域" class="headerlink" title="通过window.name跨域"></a>通过window.name跨域</h3><blockquote>
<p>window对象有个name属性，该属性有个特征：<strong>即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</strong></p>
<p>由于安全原因，浏览器始终会保持 window.name 是string 类型。</p>
</blockquote>
<p><strong>如果在一个标签里面跳转网页的话，我们的 window.name 是不会改变的。</strong><br>基于这个思想，我们可以在某个页面设置好 window.name 的值，然后跳转到另外一个页面。在这个页面中就可以获取到我们刚刚设置的 window.name 了。</p>
<p>同样这个方法也可以应用到和iframe的交互</p>
<p><strong>Case</strong></p>
<p>我的页面(<a href="http://damonare.cn/index.html" target="_blank" rel="external">http://damonare.cn/index.html</a>)中内嵌了一个iframe：</p>
<pre><code class="html">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.google.com/iframe.html&quot;&gt;&lt;/iframe&gt;
</code></pre>
<p>在 iframe.html 中设置好了 window.name 为我们要传递的字符串。<br>在 index.html 中写了下面的代码：</p>
<pre><code class="javascript">var iframe = document.getElementById(&#39;iframe&#39;);
var data = &#39;&#39;;

iframe.onload = function() {
    iframe.onload = function(){
        data = iframe.contentWindow.name;
    }
    iframe.src = &#39;about:blank&#39;;
};
</code></pre>
<p><strong>或者将里面的 about:blank 替换成某个同源页面（about:blank，javascript: 和 data: 中的内容，继承了载入他们的页面的源。）</strong></p>
<p>这种方法与 document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据。</p>
<p>这个方式<strong>非常适合单向的数据请求</strong>，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p>
<h3 id="服务端代理"><a href="#服务端代理" class="headerlink" title="服务端代理"></a>服务端代理</h3><p>在数据提供方没有提供对JSONP协议或者window.name协议的支持，也没有对其它域开放访问权限，我们可以通过<strong>server proxy的方式来抓取数据</strong>。</p>
<p><strong>Case</strong></p>
<p>例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在Baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/,然后这个代理发送HTTP请求访问google.com下的getUsers.php</p>
<p>跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略的限制），客户端并没有产生跨域的Ajax请求。这个跨域方式下不需要和目标资源签订协议，带有侵略性。</p>
<h3 id="flash-URLLoader"><a href="#flash-URLLoader" class="headerlink" title="flash URLLoader"></a>flash URLLoader</h3><p>flash有自己的一套安全策略，服务器可以通过crossdomain.xml文件来声明能被哪些域的SWF文件访问，SWF也可以通过API来确定自身能被哪些域的SWF加载。</p>
<p><strong>Case</strong></p>
<p>当跨域访问资源时，例如从域baidu.com请求域google.com上的数据，我们可以借助flash来发送HTTP请求。</p>
<p>首先，修改域google.com上的crossdomain.xml(一般存放在根目录，如果没有需要手动创建) ，把baidu.com加入到白名单。其次，通过Flash URLLoader发送HTTP请求，最后，通过Flash API把响应结果传递给 JavaScript。</p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>Flash URLLoader是一种很普遍的跨域解决方案，不过需要支持<a href="http://lib.csdn.net/base/1" target="_blank" rel="external">iOS</a>的话，这个方案就不可行了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>单向的数据请求，我们应该优先选择JSONP或者window.name</li>
<li>双向通信优先采取location.hash</li>
<li>在未与数据提供方达成通信协议的情况下我们也可以用server proxy的方式来抓取数据。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="本地（使用文件协议）的跨域请求问题"><a href="#本地（使用文件协议）的跨域请求问题" class="headerlink" title="本地（使用文件协议）的跨域请求问题"></a>本地（使用文件协议）的跨域请求问题</h2><p>具体操作：右键浏览器快捷方式，选择属性，在目标中添加–allow-file-access-from-files即可。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/lxcao/article/details/52947291" target="_blank" rel="external">Web前端面试指导(四十六)：你了解跨域请求吗？</a></li>
<li><a href="https://www.zhihu.com/question/19966531" target="_blank" rel="external">JSONP 的工作原理是什么？</a></li>
<li><a href="http://blog.csdn.net/zhang070514/article/details/77604517" target="_blank" rel="external">前端面试之跨域请求</a></li>
<li><a href="http://web.jobbole.com/88519/" target="_blank" rel="external">前端跨域知识总结</a></li>
<li><a href="http://www.cnblogs.com/jkisjk/archive/2013/05/30/change_document_domain.html" target="_blank" rel="external">修改document.domain的注意事项</a></li>
<li><a href="http://www.cnblogs.com/greatluoluo/p/6273463.html" target="_blank" rel="external">深入理解前端跨域问题的解决方案——前端面试</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[事件机制]]></title>
      <url>/2017/05/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>本文介绍事件机制</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><h3 id="标准事件流"><a href="#标准事件流" class="headerlink" title="标准事件流"></a>标准事件流</h3><p>EMCAScript标准规定事件流包含三个阶段，分别为事件捕获阶段，处于目标阶段，事件冒泡阶段。</p>
<p><strong>Case</strong></p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;button&gt;click&lt;/button&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果点击按钮button，则标准事件触发分别经历以下三个阶段：</p>
<p><img src="http://images.cnitblog.com/blog2015/697856/201504/080003152437715.png" alt=""></p>
<p>事件触发一次经历三个阶段，所以我们在一个元素上注册事件也就可以在对应阶段注册事件，移除事件也同样</p>
<pre><code class="javascript">//标准注册事件函数
//target:target： 文档节点、document、window 或 XMLHttpRequest。
//函数的参数，分别为 注册事件类型---type不包含on，事件的回调函数，事件注册在捕获期间还是冒泡期间，true：捕获，false：冒泡
target.addEventListener(type, listener, useCapture);  

//在某一个元素上撤销已注册的事件。这里强调的是:这里的函数必须与已注册的函数是同一个函数！
target.removeEventListener(type, listener, useCapture);
</code></pre>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><ol>
<li>点击时<strong>是先判断是否处于事件阶段二</strong>，这个时候，我们已经处于了事件阶段，所以根本不存在捕获或者冒泡。<strong>这个时候会按照事件注册顺序，由事件队列中取出回调函数，执行之！</strong></li>
<li><code>addEventListener（function(),true）（将函数注册到捕获阶段和处于阶段）</code>,<code>addEventListener（function(),false）（将函数注册到处于阶段和冒泡阶段）</code>，注意注册的两个函数都是可以认为是在处于阶段的，因此函数是按注册的顺序来执行，第二个参数为true或者false都没有影响。</li>
</ol>
<h3 id="IE中事件流"><a href="#IE中事件流" class="headerlink" title="IE中事件流"></a>IE中事件流</h3><p>IE中事件流只有两个阶段： 处于目标阶段，冒泡阶段。 </p>
<p><strong>Case</strong></p>
<p><img src="http://images.cnitblog.com/blog2015/697856/201504/080003359931643.png" alt=""></p>
<p>对应着在IE中的事件注册和撤销事件函数</p>
<pre><code class="javascript">//target： 文档节点、document、window 或 XMLHttpRequest。
//函数参数： type----包含on.type一般为“onclick”,&quot;onkeydown&quot;
//          listener：事件触发时的回调函数。
target.attachEvent(type, listener);  
target.detachEvent(type,listener);   //参数与注册参数相对应。
</code></pre>
<h3 id="事件的执行顺序"><a href="#事件的执行顺序" class="headerlink" title="事件的执行顺序"></a>事件的执行顺序</h3><p>一般事件的执行顺序： <strong>事件的捕获阶段====&gt;处于目标阶段====&gt;事件的冒泡阶段====&gt;事件的默认行为</strong>。</p>
<p>正因为事件的默认行为是最后执行的，我们才得以机会阻止事件的默认行为。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">//阻止文本框获取焦点  
  var input=document.getElementById(&quot;inputText&quot;);
    input.onmousedown=function(event){
        event=event||window.event;
        if(event.preventDefault){  //非IE浏览器阻止事件默认行为
            event.preventDefault();
        }else{
            event.returnValue=false;//IE浏览器阻止事件默认行为
        }
    }
</code></pre>
<h3 id="跨浏览器注册事件"><a href="#跨浏览器注册事件" class="headerlink" title="跨浏览器注册事件"></a>跨浏览器注册事件</h3><pre><code class="javascript">var EventUtil =  {
    addEventListener: function (element, type, callback) {  //注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的冒泡阶段
        if (element.addEventListener) {
            element.addEventListener(type, callback, false);
        } else if (element.attachEvent) {
            element.attachEvent(&#39;on&#39; + type, callback);
        } else {
            element[&#39;on&#39; + type] = callback;
        }
    },                   
    removeEventListener: function(element, type, callback) {  //撤销事件
        if (element.removeEventListener) {
            element.removeEventListener(type, callback, false);
        } else if (element.detachEvent) {
            element.detachEvent(&#39;on&#39; + type, callback);
        } else {
            element[&#39;on&#39; + type] = null;
        }
    }
};
</code></pre>
<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><h3 id="DOM0级事件"><a href="#DOM0级事件" class="headerlink" title="DOM0级事件"></a>DOM0级事件</h3><p>将一个函数赋值给一个事件处理程序的属性。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var btn = document.getElementById(&#39;mybtn&#39;);
btn.onclick = function () {
  alert(&#39;click&#39;);
}
</code></pre>
<p><strong>优点</strong></p>
<ol>
<li>简单</li>
<li>具有跨浏览器优势。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>某一个属性只能赋值给一个函数，也就导致在某一个元素上的某一个事件属性只能对应着一个函数。多次注册时，已最后一次注册为准。</li>
<li>DOM0级事件全部都是默认在冒泡阶段执行。</li>
</ol>
<h3 id="DOM2级事件"><a href="#DOM2级事件" class="headerlink" title="DOM2级事件"></a>DOM2级事件</h3><pre><code class="javascript">var btn = document.getElementById(&#39;mybtn&#39;);

function fun1(){ alert(&quot;1&quot;);}
function fun2(){ alert(&quot;2&quot;);}

EventUtil.addEventListener(btn,&quot;click&quot;,fun1);  //注册事件
EventUtil.addEventListener(btn,&quot;click&quot;,fun1); //触发事件的时候会 先弹出 1 在弹出 2
</code></pre>
<p><strong>优点</strong></p>
<ol>
<li>可以多次注册</li>
<li>执行顺序与注册顺序一致。</li>
</ol>
<blockquote>
<p>一般因兼容性考虑，我们很少在事件的捕获阶段注册事件</p>
</blockquote>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有事件有关的信息。</p>
<h3 id="标准浏览器中的事件对象"><a href="#标准浏览器中的事件对象" class="headerlink" title="标准浏览器中的事件对象"></a>标准浏览器中的事件对象</h3><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>bubbles</td>
<td>boolean</td>
<td>只读</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>cancelable</td>
<td>boolean</td>
<td>只读</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>
</tr>
<tr>
<td>currentTarget</td>
<td>Element</td>
<td>只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>eventPhase</td>
<td>Intenger</td>
<td>只读</td>
<td>返回事件传播的当前阶段。</td>
</tr>
<tr>
<td>target</td>
<td>Element</td>
<td>只读</td>
<td>返回触发此事件的元素（事件的目标节点）。</td>
</tr>
<tr>
<td>timeStamp</td>
<td>Date</td>
<td>只读</td>
<td>返回事件生成的日期和时间。</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>只读</td>
<td>返回当前 Event 对象表示的事件的名称。</td>
</tr>
<tr>
<td>trusted</td>
<td>boolean</td>
<td>只读</td>
<td>该事件是否是浏览器生成（true代表是，false代表是开发人员创建</td>
</tr>
<tr>
<td>preventDefault</td>
<td>Function</td>
<td>只读</td>
<td>取消事件的默认行为在<a href="http://www.w3school.com.cn/jsref/event_cancelable.asp" target="_blank" rel="external">cancelable</a>=true时有效</td>
</tr>
<tr>
<td>stopPropagation</td>
<td>Function</td>
<td>只读</td>
<td>取消事件的捕获或者冒泡行为在<a href="http://www.w3school.com.cn/jsref/event_bubbles.asp" target="_blank" rel="external">bubbles</a>=true时有效</td>
</tr>
</tbody>
</table>
<p>在事件处理程序内部，对象this始终指向currentTarget的值，而target则只包含事件的实际目标。</p>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancelBubble</td>
<td>boolean</td>
<td>读/写</td>
<td>返回布尔值，指示事件是否是起泡冒泡</td>
</tr>
<tr>
<td>returnValue</td>
<td>boolean</td>
<td>读/写</td>
<td>返回布尔值，指示事件是否可拥可取消的默认动作。</td>
</tr>
<tr>
<td>srcElement</td>
<td>Element</td>
<td>只读</td>
<td>返回其事件监听器触发该事件的元素。</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>只读</td>
<td>被触发事件的类型</td>
</tr>
</tbody>
</table>
<p><strong>与标准浏览器事件对象对应关系</strong></p>
<ul>
<li>srcElement 对应 target;</li>
<li>event.returnValue=false 对应event.preventDefault();</li>
<li>event.cancelBubble=true 对应event.stopPropagation();</li>
<li>fromElement和toElement 对应 relatedTarget</li>
</ul>
<h3 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h3><pre><code class="javascript">var EventUtil =  {
  addEventListener: function (element, type, callback) {  //注册事件，因为浏览器的兼容性考虑，注册事件一般都是注册在事件的捕获阶段
    if (element.addEventListener) {
      element.addEventListener(type, callback, false);
    } else if (element.attachEvent) {
      element.attachEvent(&#39;on&#39; + type, callback);
    } else {
      element[&#39;on&#39; + type] = callback;
    }
  }, 
  getEvent:function(event){           //获取事件
    return event||window.event;
  },                
  getTarget:function(event){           //获取事件的触发目标
    return event.target||event.srcElement;
  },
  preventDefault:function(event){        //阻止事件的默认行为
    event.preventDefault?event.preventDefault():event.returnValue=false;
  },
  stopPropagation:function(event){          //阻止事件冒泡
    event.stopPropagation?event.stopPropagation:event.cancelBubble=true;
  },
  removeEventListener: function(element, type, callback) {  //撤销事件
    if (element.removeEventListener) {
      element.removeEventListener(type, callback, false);
    } else if (element.detachEvent) {
      element.detachEvent(&#39;on&#39; + type, callback);
    } else {
      element[&#39;on&#39; + type] = null;
    }
  }
};
</code></pre>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>这块更新较大，后续补上</p>
<h3 id="模拟鼠标事件"><a href="#模拟鼠标事件" class="headerlink" title="模拟鼠标事件"></a>模拟鼠标事件</h3><p>具体请查<a href="https://developer.mozilla.org/en-US/docs/Web/API/" target="_blank" rel="external">MDN APIs</a></p>
<h4 id="非IE浏览器"><a href="#非IE浏览器" class="headerlink" title="非IE浏览器"></a>非IE浏览器</h4><p>使用 <strong>MouseEvent()构造器来创建一个</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent" target="_blank" rel="external"><code>MouseEvent</code></a>.</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent" target="_blank" rel="external">API:MouseEvent</a></p>
<pre><code class="javascript">event = new MouseEvent(typeArg, mouseEventInit);
</code></pre>
<h4 id="IE浏览器模拟鼠标事件"><a href="#IE浏览器模拟鼠标事件" class="headerlink" title="IE浏览器模拟鼠标事件"></a>IE浏览器模拟鼠标事件</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="external">API:createEventObject</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/fireEvent" target="_blank" rel="external">API:fireEvent</a> IE11已废弃</p>
<pre><code class="javascript">var event=document.createEventObject();
event.screenX=100;
event.screenY=100;
event.clientX=100;
event.clientX=100;
event.ctrlKey=false;

btn.fireEvent(&quot;onclick&quot;,event);   //在这一步会设置event.serElement,以及触发事件类型
</code></pre>
<h3 id="模拟键盘事件"><a href="#模拟键盘事件" class="headerlink" title="模拟键盘事件"></a>模拟键盘事件</h3><h4 id="DOM3标准"><a href="#DOM3标准" class="headerlink" title="DOM3标准"></a>DOM3标准</h4><p>createEvent()传入字符串“KeyboardEvent”.返回的对象有initKeyEvent()方法</p>
<h4 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/fireEvent" target="_blank" rel="external">API:fireEvent</a> IE11已废弃</p>
<pre><code class="javascript">var event=document.createEventObject();
event.altKey=false;
event.ctrlKey=false;
event.shiftKey=false;
event.keyCode=65;

textbox.fireEvent(&quot;onkeydown&quot;,event);
</code></pre>
<h3 id="自定义DOM事件"><a href="#自定义DOM事件" class="headerlink" title="自定义DOM事件"></a>自定义DOM事件</h3><p>…</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="事件委托或是事件代理详解"><a href="#事件委托或是事件代理详解" class="headerlink" title="事件委托或是事件代理详解"></a>事件委托或是事件代理详解</h2><h3 id="为什么要用事件委托"><a href="#为什么要用事件委托" class="headerlink" title="为什么要用事件委托"></a>为什么要用事件委托</h3><p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；<strong>如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</strong></p>
<h3 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h3><p>事件委托是利用事件的<strong>冒泡原理</strong>来实现的</p>
<h3 id="事件委托怎么实现"><a href="#事件委托怎么实现" class="headerlink" title="事件委托怎么实现"></a>事件委托怎么实现</h3><p><strong>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源</strong>，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，<strong>标准浏览器用ev.target，IE浏览器用event.srcElement</strong>，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p>
<pre><code class="javascript">window.onload = function(){
  var oUl = document.getElementById(&quot;ul1&quot;);
  oUl.onclick = function(ev){
    var ev = ev || window.event;
    var target = ev.target || ev.srcElement;
    if(target.nodeName.toLowerCase() == &#39;li&#39;){
      //...
    }
  }
}
</code></pre>
<p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/renlong0602/p/4401113.html" target="_blank" rel="external">JavaScript系列—-事件机制</a></li>
<li><a href="http://www.cnblogs.com/yexiaochai/p/3567597.html" target="_blank" rel="external">【前端盲点】事件的几个阶段你真的了解么？？？</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[http]]></title>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/http/</url>
      <content type="html"><![CDATA[<p>本文介绍http。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p>TCP/IP协议族可以分为4层，分别是应用层、传输层、网络层和链路层。</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动。FTP（File Transfer Protocol， 文件传输协议）、DNS（Domain Name System，域名系统）和HTTP都属于该层。</li>
<li>传输层：提供处于网络连接中的两台计算机之间的数据传输。TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据协议）都属于该层。</li>
<li>网络层：用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</li>
<li>链路层：用来处理网络的硬件部分，包括操作系统、硬件的设备驱动、NIC（Network Interface Card，网卡）、光纤、诸如连接器之类的传输媒介等物理可见部分。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的过程使用了TCP 标志——SYN（synchronize）和ACK（acknowledgement）：</p>
<ol>
<li>发送端发送一个带SYN标志的数据包给对方。</li>
<li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。</li>
<li>发送端回传一个带ACK标志的数据包，表示握手结束。</li>
</ol>
<h2 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h2><p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通讯。以HTTP举例来说，过程是这样的：</p>
<ol>
<li>客户端在应用层（HTTP协议）发出一项想看某个Web页面的HTTP请求。</li>
<li>在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li>
<li>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。</li>
</ol>
<p>发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的<strong>首部信息</strong>；反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法，也叫封装（encapsulate）。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p><strong>Case</strong></p>
<blockquote>
<p>GET /search.jsp HTTP/1.1<br>Host: g.hxgoogle.com</p>
</blockquote>
<p>一个完整的请求报文由Header和Body组成，Header包括请求方法、请求URI、协议版本、可选的请求首部字段等，Body指报文主体。下面重点介绍一下请求URI和HTTP方法。</p>
<h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URI表示统一资源标识符，是Uniform Resource Identifier的缩写。</p>
<p>URI就是由某个协议方案（如http、ftp）表示的资源的定位标识符。</p>
<p><strong>Case</strong></p>
<blockquote>
<p>ftp://ftp.is.co.za/rfc/rfc1808.txt<br><a href="http://www.ietf.org/rfc/rfc2396.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2396.txt</a><br>ldap://[2001:db8::7]/c=GB?objectClass?one<br>mailto:John.Doe@example.com<br>tel:+1-816-555-1212</p>
</blockquote>
<p>URI用字符串标识某一互联网资源，而我们相对来说更熟悉的URL（UniformResource Locator，统一资源定位符）则是表示资源的地点。显然URL是URI的子集</p>
<p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：<code>http://host[&quot;:&quot;port][abs_path]</code></p>
<p>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p>HTTP/1.1中的方法：</p>
<ul>
<li>GET：请求访问已被URI识别的资源，资源经服务器端解析后返回响应内容。</li>
<li>POST：虽然GET方法也可以在Body中包含内容进行传输，不过一般不用，而是使用POST方法。POST在RESTful架构中一般用来修改资源。</li>
<li>PUT：用于传输资源到URI指定位置进行保存。由于PUT方法自身不带验证机制，存在安全问题，因此一般Web网站不使用该方法。若配合Web应用程序的验证机制或采用RESTful架构设计，可能会开放使用。PUT在RESTful架构中一般用来添加资源。</li>
<li>DELETE：删除资源。与PUT情况类似，一般不开放。</li>
<li>HEAD：获得报文首部（Header），用于确认URI的有效性及资源的更新日期等。</li>
<li>TRACE：追踪路径。发送请求时，在请求Header中加上Max-Forwards字段，譬如Max-Forwards: 2这样，每经过一个服务器就将该数字减1，当数字为0时停止传输，最后接收到请求的服务器返回状态码200 OK响应，响应包含最初的请求内容（将HTTP请求原样返回）。</li>
<li>CONNECT：要求在于代理服务器通信时建立隧道，用隧道协议进行TCP通信。主要使用SSL（Secure Sockets Layer， 安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。格式为CONNECT 代理服务器名:端口号 HTTP版本号。</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>HTTP响应同样可分为Header和Body，它一般长这样：</p>
<blockquote>
<p>HTTP/1.1 200 ok<br>Date: …<br>Server: ..<br>…<br>空行(CR + LF)</p>
<html><br>…<br></html>

</blockquote>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码的第一位数字指定了响应类别，共可分为5类：</p>
<ul>
<li>1XX：Informational（信息性状态码），表明接受的请求正在处理。</li>
<li>2XX：Success（成功状态码），表明请求正常处理完毕。</li>
<li>3XX：Redirection（重定向状态码），表明需进行附加操作以完成请求。</li>
<li>4XX：Client Error（客户端错误状态码），表明服务器无法处理请求。</li>
<li>5XX：Server Error（服务器错误状态码），表明服务器处理请求出错。</li>
</ul>
<p>下面列举几种常见的错误码和原因短语：</p>
<ul>
<li>200 OK：请求正常处理。</li>
<li>204 No Content：请求正常处理，但没有资源可返回。</li>
<li>206 Partial Content： 客户端进行了范围请求，服务器成功执行这部分GET请求。</li>
<li>301 Moved Permanently： 永久性重定向，表明该资源已被分配了新的URI。</li>
<li>302 Found： 临时性重定向，表明该资源暂时被分配了新的URI。</li>
<li>303 See Other：表明请求的资源存在另一个URI，明确要求客户端采用GET方法重定向请求资源。</li>
<li>400 Bad Request：请求报文中存在语法错误，需修改请求内容后再次发送。</li>
<li>401 Unauthorized*：请求需包含通过HTTP认证（BASIC认证、DIGEST认证等）的认证信息，浏览器初次接收401响应会弹出认证窗口。若之前已进行过一次请求，则表示用户认证失败。</li>
<li>403 Forbidden：请求资源的访问被服务器拒绝。服务器端没有必要给出拒绝的详细理由，不过也可以在响应主体部分对原因进行描述。未获得文件系统的访问授权（比如在IIS上部署网站时默认不能通过浏览器访问文件）、访问权限出现问题（比如从未授权的发送源IP地址试图访问）都有可能返回403响应。</li>
<li>404 Not Found：服务器无法找到请求的资源（也可在服务器端拒绝访问且不想说明理由时使用）。</li>
<li>500 Internal Server Error：服务器端执行请求时发生内部错误。多为服务器端程序出现Bug。</li>
<li>503 Service Unavailable：服务器处于超负载或正在停机维护，暂时无法处理请求。</li>
</ul>
<h2 id="HTTP消息报头"><a href="#HTTP消息报头" class="headerlink" title="HTTP消息报头"></a>HTTP消息报头</h2><p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。</p>
<h3 id="1-普通报头"><a href="#1-普通报头" class="headerlink" title="1. 普通报头"></a>1. 普通报头</h3><p>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息</p>
<h4 id="常用的普通报头"><a href="#常用的普通报头" class="headerlink" title="常用的普通报头"></a>常用的普通报头</h4><p><strong>Cache-Control</strong><br>Cache-Control用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。</p>
<p>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.</p>
<p><strong>Date</strong><br>Date普通报头域表示消息产生的日期和时间</p>
<p><strong>Connection</strong><br>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>
<h3 id="2-请求报头"><a href="#2-请求报头" class="headerlink" title="2. 请求报头"></a>2. 请求报头</h3><p>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。</p>
<h4 id="常用的请求报头"><a href="#常用的请求报头" class="headerlink" title="常用的请求报头"></a>常用的请求报头</h4><p><strong>Accept</strong><br>Accept请求报头域用于指定客户端接受哪些类型的信息。</p>
<p><strong>Accept-Charset</strong><br>Accept-Charset请求报头域用于指定客户端接受的字符集。</p>
<p><strong>Accept-Encoding</strong><br>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。</p>
<p><strong>Accept-Language</strong><br>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。</p>
<p><strong>Authorization</strong><br>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</p>
<p><strong>Host</strong>（发送请求时，该报头域是必需的）<br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>
<p><strong>User-Agent</strong><br>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的</p>
<h3 id="3-响应报头"><a href="#3-响应报头" class="headerlink" title="3. 响应报头"></a>3. 响应报头</h3><p>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</p>
<h4 id="常用的响应报头"><a href="#常用的响应报头" class="headerlink" title="常用的响应报头"></a>常用的响应报头</h4><p><strong>Location</strong><br>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</p>
<p><strong>Server</strong><br>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。</p>
<h3 id="4-实体报头"><a href="#4-实体报头" class="headerlink" title="4. 实体报头"></a>4. 实体报头</h3><p>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文和请求所标识的资源的元信息。</p>
<h4 id="常用的实体报头"><a href="#常用的实体报头" class="headerlink" title="常用的实体报头"></a>常用的实体报头</h4><p><strong>Content-Encoding</strong><br>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。</p>
<p><strong>Content-Language</strong><br>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。</p>
<p><strong>Content-Length</strong><br>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</p>
<p><strong>Content-Type</strong><br>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。</p>
<p><strong>Last-Modified</strong><br>Last-Modified实体报头域用于指示资源的最后修改日期和时间。</p>
<p><strong>Expires</strong><br>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。</p>
<h2 id="HTTP协议的一些特性"><a href="#HTTP协议的一些特性" class="headerlink" title="HTTP协议的一些特性"></a>HTTP协议的一些特性</h2><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。增加通信量的开销，而且频繁断开又重连会导致页面加载缓慢，影响用户体验。</p>
<h3 id="持久连接（HTTP-Persistent-Connections）"><a href="#持久连接（HTTP-Persistent-Connections）" class="headerlink" title="持久连接（HTTP Persistent Connections）"></a>持久连接（HTTP Persistent Connections）</h3><p>HTTP/1.1和一部分HTTP/1.0开始支持持久连接。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。HTTP/1.1中所有的连接默认都是持久连接。</p>
<h3 id="管线化（pipelining）"><a href="#管线化（pipelining）" class="headerlink" title="管线化（pipelining）"></a>管线化（pipelining）</h3><p>持久连接使得多数请求以管线化方式发送成为可能。以往发送请求后需等待并收到响应后才能发送下一个请求，管线化技术出现后，无需等待亦可发送下一个请求。这就实现了多个请求的并行发送，提高了网络通信效率。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP是无状态协议，它不对之前发生过的请求和响应状态进行管理。HTTP协议中引入的Cookie技术，也是为了解决状态管理问题。</p>
<p>具体来说，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态，过程如下：</p>
<ol>
<li><p>客户端第一次发送请求，请求报文中没有Cookie信息。</p>
</li>
<li><p>服务器端生成Cookie信息，在响应报文中通过Set-Cookie这个首部字段，通知客户端保存Cookie，大概长这样：</p>
<blockquote>
<p>HTTP/1.1 200 ok<br>…<br><set-cookie: sid="1345077140226724;path=/;expires=Fri,=">23-Oct-15 07:12:20 GMT&gt;<br>Content-Type: text/plain; charset=UTF-8</set-cookie:></p>
</blockquote>
</li>
<li><p>客户端再次发送请求时，自动在请求报文中加入Cookie值后发送出去。大概长这样：</p>
<blockquote>
<p>GET /image/ HTTP/1.1<br>Host: github.com<br>Cookie: sid=1345077140226724</p>
</blockquote>
</li>
<li><p>服务器端收到Cookie信息后，会去检查从哪个客户端发来的连接请求，然后对比服务器上的记录，得到之前的状态信息。</p>
</li>
</ol>
<h2 id="HTTP协议相关技术补充"><a href="#HTTP协议相关技术补充" class="headerlink" title="HTTP协议相关技术补充"></a>HTTP协议相关技术补充</h2><h3 id="中介"><a href="#中介" class="headerlink" title="中介"></a>中介</h3><p>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)。</p>
<h4 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理(Proxy)"></a>代理(Proxy)</h4><p>一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p>
<p>一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。</p>
<h4 id="网关-Gateway"><a href="#网关-Gateway" class="headerlink" title="网关(Gateway)"></a>网关(Gateway)</h4><p>一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p>
<p>网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。</p>
<h4 id="通道-Tunnel"><a href="#通道-Tunnel" class="headerlink" title="通道(Tunnel)"></a>通道(Tunnel)</h4><p>是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
<p>一个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h2><ol>
<li>支持客户/服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jianshu.com/p/2ecd288d27ad" target="_blank" rel="external">HTTP知识点总结</a></li>
<li><a href="http://www.cnblogs.com/puyaoyao/p/3705970.html" target="_blank" rel="external">HTTP协议详解（前端面试常考知识点）</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型与原型链]]></title>
      <url>/2017/05/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<p>本文介绍原型和原型链的概念，参考多篇热门博客，持续总结和更新思想。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h2><p>任何一个对象Object都有<code>_proto_</code>，它是每一个对象的私有属性，是天生自带的。</p>
<p>又叫做隐式原型</p>
<p>JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。ES5中有了对于这个内置属性标准的<strong>Get方法Object.getPrototypeOf()</strong></p>
<blockquote>
<p>Note: Object.prototype 这个对象是个例外，它的<code>__proto__</code>值为null </p>
</blockquote>
<p>隐式原型指向<strong>创建</strong>这个对象的函数(constructor)的prototype</p>
<p>一个对象的<strong>proto</strong>记录着自己的原型链，决定了自身的数据类型，改变<strong>proto</strong>就等于改变对象的数据类型。</p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。</p>
<h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h2><p><strong>原型对象</strong>。不是任何对象都有prototype，只有构造函数有prototype，是后天赋予的。</p>
<p>每创建一个函数都会有一个prototype属性，这个属性是一个指针，<strong>指向一个对象（通过该构造函数创建实例对象的原型对象）</strong>。</p>
<p>原型对象是包含特定类型的所有实例共享的属性和方法。<strong>原型对象的好处是，可以让所有实例对象共享它所包含的属性和方法。</strong></p>
<p>原型对象属于普通对象。</p>
<p>又叫做显式原型。</p>
<blockquote>
<p><strong>Note</strong>：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性</p>
</blockquote>
<p>函数的prototype不属于自身的原型链，它是子类创建的核心，决定了子类的数据类型，是连接子类原型链的桥梁。</p>
<p>在原型对象上定义方法和属性的目的是为了被子类继承和使用。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享。</p>
<h2 id="获取对象的原型"><a href="#获取对象的原型" class="headerlink" title="获取对象的原型"></a>获取对象的原型</h2><pre><code class="javascript">dog1.__proto__  //不推荐  
Object.getPrototypeOf(dog1) === Dog.prototype   //推荐
</code></pre>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的存在，主要是为了实现对象的<code>继承</code>。</p>
<p>原型链基本思路（图解）：</p>
<p><img src="http://img.blog.csdn.net/20161006191631510?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h2 id="原型链查找"><a href="#原型链查找" class="headerlink" title="原型链查找"></a>原型链查找</h2><p><strong>调用一个对象的属性或方法，一但这个对象中没有，就去这个对象的<code>_proto_</code>中查找。这个对象的<code>_proto_</code>指向自己构造函数的prototype属性</strong></p>
<p>关键的点在于找到创建这个对象的构造函数，本质上只有一种方式，也就是通过new来创建。</p>
<p>由Object.create(o)创建出来的对象它的隐式原型指向o。</p>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>JS在通过new 表达式创建一个对象的时候，通常会把父类的prototype赋值给新对象的<code>__proto__</code>属性</p>
<p>当使用<code>new</code>去调用构造函数时，相当于执行了</p>
<pre><code class="javascript">var o = {};
o.__proto__ = F.prototype;
F.call(o);
</code></pre>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>原型对象prototype上都有个预定义的<code>constructor</code>属性，用来引用它的函数对象。这是一种循环引用。</p>
<pre><code class="javascript">function F(){};
F.prototype.constructor === F;
</code></pre>
<p>在实际运用中，经常会有下列的写法</p>
<pre><code class="javascript">function F(){};
F.prototype = {
    constructor : F,
    doSomething : function(){}
}
</code></pre>
<p>这里要加<code>constructor</code>是因为重写了原型对象，constructor属性就消失了，需要自己手动补上。</p>
<p>实例对象的constructor属性指向其构造函数, 因此</p>
<pre><code class="javascript">Object.constructor === Function;
Function.constructor === Function;
</code></pre>
<p>由 Object.create() 创建出来的对象没有构造函数</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Function-prototype没有prototype属性"><a href="#Function-prototype没有prototype属性" class="headerlink" title="Function.prototype没有prototype属性"></a>Function.prototype没有prototype属性</h2><p><strong>原型对象属于普通对象。</strong>Function.prototype是个例外，它是原型对象，却又是函数对象，作为一个函数对象，它又没有prototype属性。</p>
<pre><code class="javascript">function person(){};  

console.log(typeof person.prototype) //Object  
console.log(typeof Object.prototype) // Object  
console.log(typeof Function.prototype) // 特殊 Function  
console.log(typeof Function.prototype.prototype) //undefined 函数对象却没有prototype属性
</code></pre>
<h2 id="构造函数的显示原型的隐式原型"><a href="#构造函数的显示原型的隐式原型" class="headerlink" title="构造函数的显示原型的隐式原型"></a>构造函数的显示原型的隐式原型</h2><p>内建对象(built-in object)比如Array()，<code>Array.prototype.__proto__</code>指向什么？</p>
<p><code>Array.prototype.__proto__ === Object.prototype</code>，或者也可以这么理解，所有的内建对象都是由Object()创建而来。</p>
<p>Array是函数对象，是Function的实例对象，Array是通过new Function创建出来的。因为Array是Function的实例，所以<code>Array.__proto__ ===  Function.prototype</code></p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><h3 id="解释1"><a href="#解释1" class="headerlink" title="解释1"></a>解释1</h3><p>instanceof 操作符的内部实现机制和隐式原型、显式原型有直接的关系。instanceof的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>内部实现原理：</p>
<pre><code class="javascript">//设 L instanceof R 
//通过判断
 L.__proto__.__proto__ ..... === R.prototype ？
//最终返回true or false
</code></pre>
<h3 id="解释2"><a href="#解释2" class="headerlink" title="解释2"></a>解释2</h3><p><code>A instanceof B</code> 是在 A 的原型链里查找 B 的 constructor，找到返回 true，找不到返回 false。</p>
<pre><code class="javascript">Function instanceof Object === true
Object instanceof Function === true

Object.__proto__ === Function.prototype; // true
Object.__proto__ == Object.prototype; // false
Function.prototype.__proto__ === Object.prototype; // true
</code></pre>
<h2 id="Function、Object关系"><a href="#Function、Object关系" class="headerlink" title="Function、Object关系"></a>Function、Object关系</h2><p><code>Object.prototype</code>是所有对象的根源<br><code>Object.prototype</code>只是挂载在<code>Object</code>函数对象上<br><code>Function.prototype</code>构造自<code>Object.prototype</code><br><code>Function.prototype</code> 只是挂载在<code>Function</code>函数对象上<br><code>Object</code>函数和<code>Function</code>函数构造自<code>Function.prototype</code><br><code>Object</code>字面量对象{}构造自<code>Object.prototype</code><br><code>Object</code>字面量对象<code>{}.__proto__</code>（原构造对象） === <code>Object.prototype</code><br><code>Function</code>函数 和 自定义函数 都继承（构造而成）自<code>Function.prototype</code><br><code>Function.prototype</code> 和 <code>Function.__proto__</code>（原构造对象）相同<br>所以，是先有的<code>Object.prototype</code>,再有的<code>Function.prototype</code>，再有的<code>Function</code>和<code>Object</code>函数对象</p>
<h2 id="Function、Object、Prototype、proto内存关系图"><a href="#Function、Object、Prototype、proto内存关系图" class="headerlink" title="Function、Object、Prototype、proto内存关系图"></a>Function、Object、Prototype、<strong>proto</strong>内存关系图</h2><ol>
<li>所有对象所有对象，包括函数对象的原型链最终都指向了Object.prototype，而<code>Object.prototype.__proto__===null</code>，原型链至此结束。</li>
<li>Animal.prototype是一个普通对象。</li>
<li>Object是一个函数对象，也是Function构造的，Object.prototype是一个普通对象。</li>
<li><code>Object.prototype.__type__</code>指向null。</li>
<li>Function.prototype是一个函数对象，前面说函数对象都有一个显示的prototype属性，但是Function.prototype却没有prototype属性，即Function.prototype.prototype===undefined，所有Function.prototype函数对象是一个特例，没有prototype属性。</li>
<li>Object虽是Function构造的一个函数对象，但是Object.prototype没有指向Function.prototype，即Object.prototype!==Function.prototype。</li>
</ol>
<p><img src="http://images.blogjava.net/blogjava_net/heavensay/web-front/8199006.png" alt=""></p>
<h2 id="经典原型链"><a href="#经典原型链" class="headerlink" title="经典原型链"></a>经典原型链</h2><p><img src="https://pic2.zhimg.com/50/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" alt=""></p>
<h2 id="《JavaScript-世界万物诞生记》"><a href="#《JavaScript-世界万物诞生记》" class="headerlink" title="《JavaScript 世界万物诞生记》"></a>《JavaScript 世界万物诞生记》</h2><p>Object作为一个机器可以看做是有由Function制造出来的，而Function作为一个对象可以看做是由Object制造出来的。</p>
<p><img src="https://pic2.zhimg.com/v2-52726a7f86690c0663452112d66836c5_r.png" alt=""></p>
<h2 id="《什么是-JS-原型链？》"><a href="#《什么是-JS-原型链？》" class="headerlink" title="《什么是 JS 原型链？》"></a>《什么是 JS 原型链？》</h2><blockquote>
<p>这篇流程讲的很清晰</p>
</blockquote>
<pre><code class="javascript">var obj = { name: &#39;obj&#39; }
</code></pre>
<h3 id="valueOf-toString-constructor-是怎么来？"><a href="#valueOf-toString-constructor-是怎么来？" class="headerlink" title="valueOf / toString / constructor 是怎么来？"></a>valueOf / toString / constructor 是怎么来？</h3><ol>
<li><code>obj.__proto__</code> 有很多属性，包括 valueOf、toString、constructor 等</li>
<li><code>obj.__proto__</code> 其实也有一个叫做 <code>__proto__</code> 的属性，值为 null</li>
</ol>
<h3 id="共享原型链"><a href="#共享原型链" class="headerlink" title="共享原型链"></a>共享原型链</h3><p>如果我们改写 <code>obj2.__proto__.toString</code>，那么 obj.toString 其实也会变！</p>
<h3 id="差异化"><a href="#差异化" class="headerlink" title="差异化"></a>差异化</h3><p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？</p>
<p>直接赋值就好了：</p>
<pre><code class="javascript">obj.toString = function(){ return &#39;新的 toString 方法&#39; }
</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>「读」属性时会<strong>沿着原型链搜索</strong>。</p>
<p>「新增」属性时<strong>不会</strong>去看原型链（但是如果你给这个属性加了一些配置，则不一样）。</p>
<h2 id="《最详尽的-JS-原型与原型链终极详解》"><a href="#《最详尽的-JS-原型与原型链终极详解》" class="headerlink" title="《最详尽的 JS 原型与原型链终极详解》"></a>《最详尽的 JS 原型与原型链终极详解》</h2><h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p>对象也有区别，大致可以分为两类，即：普通对象（Object）和函数对象（Function）。<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p>
<h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p><strong>实例的构造函数属性（constructor）指向构造函数。</strong></p>
<h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在默认情况下，所有的<strong>原型对象</strong>都会<strong>自动获得</strong>一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数,即：<code>Person.prototype.constructor == Person</code></p>
<p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p>
<p><code>Function.prototype</code> 为什么是函数对象呢？</p>
<pre><code class="javascript">var A = new Function ();
Function.prototype = A;
</code></pre>
<p><strong>凡是通过 new Function( ) 产生的对象都是函数对象</strong>。因为 A 是函数对象，所以<code>Function.prototype</code> 是函数对象。</p>
<h3 id="四-原型链"><a href="#四-原型链" class="headerlink" title="四. 原型链"></a>四. 原型链</h3><p><code>Person.prototype.__proto__</code> 是什么？</p>
<p><code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。所以 <code>Person.prototype.__proto__ === Object.prototype</code></p>
<h3 id="五-函数对象"><a href="#五-函数对象" class="headerlink" title="五. 函数对象"></a>五. 函数对象</h3><h5 id="所有函数对象的-proto-都指向Function-prototype，它是一个空函数"><a href="#所有函数对象的-proto-都指向Function-prototype，它是一个空函数" class="headerlink" title="所有函数对象的__proto__都指向Function.prototype，它是一个空函数"></a>所有<em>函数对象</em>的<code>__proto__</code>都指向Function.prototype，它是一个空函数</h5><p><strong>所有的构造器都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了·Function.prototype·的属性及方法。如length、call、apply、bind</strong></p>
<p><code>Function.prototype</code>也是唯一一个<code>typeof XXX.prototype</code>为 <code>function</code>的<code>prototype</code>。其它的构造器的<code>prototype</code>都是一个对象</p>
<p><code>Function.prototype</code>的<code>__proto__</code>是谁呢？</p>
<pre><code class="javascript">Function.prototype.__proto__ === Object.prototype
</code></pre>
<p>这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<h3 id="六-Prototype"><a href="#六-Prototype" class="headerlink" title="六. Prototype"></a>六. Prototype</h3><p>可以用一个 ES5 提供的新方法：<code>Object.getOwnPropertyNames</code>获取所有（<strong>包括不可枚举的属性</strong>）的属性名<strong>不包括 prototy 中的属性</strong>，返回一个数组</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/sinat_21274091/article/details/52741788" target="_blank" rel="external">JS重点整理之JS原型链彻底搞清楚</a></li>
<li><a href="http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html" target="_blank" rel="external">Js中Prototype、<strong>proto</strong>、Constructor、Object、Function关系介绍</a></li>
<li><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="external">js中<strong>proto</strong>和prototype的区别和关系？</a></li>
<li><a href="https://segmentfault.com/a/1190000005363885" target="_blank" rel="external">JavaScript之原型链</a></li>
<li><a href="https://segmentfault.com/q/1010000000249140" target="_blank" rel="external">Function为何是Object的实例呢</a></li>
<li><a href="https://segmentfault.com/q/1010000002736664" target="_blank" rel="external">js 原型的问题 Object 和 Function 到底是什么关系？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/22989691" target="_blank" rel="external">JavaScript 世界万物诞生记</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23090041?refer=study-fe" target="_blank" rel="external">「每日一题」什么是 JS 原型链？</a></li>
<li><a href="http://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="external">最详尽的 JS 原型与原型链终极详解，没有「可能是」</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[json]]></title>
      <url>/2017/04/30/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/json/</url>
      <content type="html"><![CDATA[<p>本文介绍json。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="JSON是什么"><a href="#JSON是什么" class="headerlink" title="JSON是什么"></a>JSON是什么</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。是前后台数据交互最常见的一种数据格式。</p>
<p><strong>特点</strong></p>
<ul>
<li>JavaScript 对象表示法（JavaScript Object Notation）。 </li>
<li>JSON 是存储和交换文本信息的语法。类似 XML。 </li>
<li>JSON 比 XML 更小、更快，更易解析。</li>
</ul>
<h2 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h2><ol>
<li>数据在键值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ol>
<blockquote>
<p>注：JSON 值可以是 null ，不能是 undefined</p>
</blockquote>
<h2 id="JSON-文件"><a href="#JSON-文件" class="headerlink" title="JSON 文件"></a>JSON 文件</h2><ul>
<li>JSON 文件的文件类型是 “.json”</li>
<li>JSON 文本的 MIME 类型是 “application/json”</li>
</ul>
<h2 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h2><h3 id="1-JSON字符串转换为JSON对象"><a href="#1-JSON字符串转换为JSON对象" class="headerlink" title="1. JSON字符串转换为JSON对象:"></a>1. JSON字符串转换为JSON对象:</h3><pre><code class="javascript">var obj =eval(&#39;(&#39;+ str +&#39;)&#39;);
var obj = JSON.parse(str);
</code></pre>
<h3 id="2-JSON对象转换为JSON字符串："><a href="#2-JSON对象转换为JSON字符串：" class="headerlink" title="2. JSON对象转换为JSON字符串："></a>2. JSON对象转换为JSON字符串：</h3><pre><code class="javascript">var last=JSON.stringify(obj);
</code></pre>
<h3 id="3-数组转JSON字符串"><a href="#3-数组转JSON字符串" class="headerlink" title="3. 数组转JSON字符串"></a>3. 数组转JSON字符串</h3><pre><code class="javascript"> var array=[1,2,3,4];
 JSON.stringify($(array));
</code></pre>
<h3 id="4-JSON字符串转数组，使用jquery"><a href="#4-JSON字符串转数组，使用jquery" class="headerlink" title="4. JSON字符串转数组，使用jquery"></a>4. JSON字符串转数组，使用jquery</h3><pre><code class="javascript"> $(JSON.parse(&#39;{&quot;0&quot;:1,&quot;1&quot;:2,&quot;2&quot;:3,&quot;length&quot;:3}&#39;));
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="JSON与XML的差异化"><a href="#JSON与XML的差异化" class="headerlink" title="JSON与XML的差异化"></a>JSON与XML的差异化</h2><p><strong>相似</strong></p>
<ul>
<li>JSON 是纯文本</li>
<li>JSON 具有“自我描述性”（人类可读）</li>
<li>JSON 具有层级结构（值中存在值）</li>
<li>JSON 可通过 JavaScript 进行解析</li>
<li>JSON 数据可使用 AJAX 进行传输</li>
</ul>
<p><strong>不同</strong></p>
<ul>
<li>没有结束标签</li>
<li>更短</li>
<li>读写的速度更快</li>
<li>能够使用内建的 JavaScript eval() 方法进行解析</li>
<li>使用数组</li>
<li>不使用保留字</li>
</ul>
<h2 id="JSON与XML使用地方"><a href="#JSON与XML使用地方" class="headerlink" title="JSON与XML使用地方"></a>JSON与XML使用地方</h2><p><strong>使用 XML</strong></p>
<ul>
<li>读取 XML 文档</li>
<li>使用 XML DOM 来循环遍历文档</li>
<li>读取值并存储在变量中</li>
</ul>
<p><strong>使用 JSON</strong></p>
<ul>
<li>读取 JSON 字符串</li>
<li>用 eval() 处理 JSON 字符串</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/lxcao/article/details/52735632" target="_blank" rel="external">Web前端面试指导(二十六)：JSON 格式是什么？你了解吗？</a></li>
<li><a href="http://blog.csdn.net/crper/article/details/45625283" target="_blank" rel="external">JSON知识点汇总_W3SCHOOL</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存泄漏]]></title>
      <url>/2017/04/29/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>本文介绍JS内存泄漏</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="js的回收机制"><a href="#js的回收机制" class="headerlink" title="js的回收机制"></a>js的回收机制</h2><p>垃圾收集算法所依赖的主要概念之一就是内存引用。</p>
<p>在内存管理情况下，如果一个对象访问变量（可以是隐含的或显式的），则称该对象引用另一个对象。</p>
<p>通常情况下有两种实现方式：标记清除和引用计数。引用计数不太常用，标记清除较为常用。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记和扫描算法经过以下3个步骤：</p>
<ol>
<li>roots：通常，root是代码中引用的全局变量。例如，在JavaScript中，可以充当root的全局变量是“窗口”对象。Node.js中的相同对象称为“全局”。所有root的完整列表由垃圾收集器构建。</li>
<li>然后算法会检查所有root和他们的子对象并且标记它们是活动的（即它们不是垃圾）。任何root不能达到的，将被标记为垃圾。</li>
<li>最后，垃圾回收器释放所有未标记为活动的内存块，并将该内存返回给操作系统。</li>
</ol>
<p><img src="http://jbcdn2.b0.upaiyun.com/2017/11/f3a624c2b1f1a9a511deffc4ad1bd57a.gif" alt=""></p>
<p>这个算法比引用计数垃圾收集算法更好。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p>
<h2 id="抵制垃圾收集器的直观行为"><a href="#抵制垃圾收集器的直观行为" class="headerlink" title="抵制垃圾收集器的直观行为"></a>抵制垃圾收集器的直观行为</h2><p>垃圾收集是不可预测的。你不能真正知道什么时候进行收集，这意味着在某些情况下，程序会使用更多的内存，虽然这是实际需要的。在其它情况下，在特别敏感的应用程序中，短暂暂停是很可能出现的。尽管非确定性意味着不能确定何时进行集合，但大多数垃圾收集实现了共享在分配期间进行收集的通用模式。如果没有执行分配，大多数垃圾收集会保持空闲状态。如以下情况：</p>
<ol>
<li>大量的分配被执行。</li>
<li>大多数这些元素（或所有这些元素）被标记为无法访问（假设我们将一个引用指向不再需要的缓存）。</li>
<li>没有进一步的分配执行。</li>
</ol>
<h2 id="常见内存泄漏"><a href="#常见内存泄漏" class="headerlink" title="常见内存泄漏"></a>常见内存泄漏</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window。如果不小心创建一个全局变量this，会有一些问题。</p>
<p>通过加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.</p>
<p>意外的全局变量当然是一个问题。更多的时候，你的代码会受到显式的全局变量的影响，而这些<strong>全局变量在垃圾收集器中是无法收集的</strong>。需要特别注意用于临时存储和处理大量信息的全局变量。如果必须使用全局变量来存储数据，那么确保将其分配为空值，或者在完成后重新分配。</p>
<h3 id="闭包引起的内存泄漏"><a href="#闭包引起的内存泄漏" class="headerlink" title="闭包引起的内存泄漏"></a>闭包引起的内存泄漏</h3><ul>
<li>将事件处理函数定义在外部，解除闭包,</li>
</ul>
<ul>
<li>在定义事件处理函数的外部函数中，删除对dom的引用</li>
</ul>
<h3 id="超出DOM引用"><a href="#超出DOM引用" class="headerlink" title="超出DOM引用"></a>超出DOM引用</h3><p>在某些情况下，开发人员会在数据结构中存储DOM节点，例如你想快速更新表格中的几行内容的情况。如果在字典或数组中存储对每个DOM行的引用，则会有两个对同一个DOM元素的引用：一个在DOM树中，另一个在字典中。如果你不再需要这些行，则需要使两个引用都无法访问。</p>
<p>在涉及DOM树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（标签）的引用，并决定从DOM中删除该表格，还需要保留对该特定单元格的引用，则可能会出现严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元之外的所有东西，但情况并非如此。由于单元格是表格的一个子节点，并且子节点保留着对父节点的引用，所以对表格单元格的这种引用，会将整个表格保存在内存中。</p>
<h3 id="被遗忘的定时器或者回调"><a href="#被遗忘的定时器或者回调" class="headerlink" title="被遗忘的定时器或者回调"></a>被遗忘的定时器或者回调</h3><p>对于提供监视的库和其它接受回调的工具，通常在确保所有回调的引用在其实例无法访问时，会变成无法访问的状态。</p>
<p>当使用监视器时，你需要确保做了一个明确的调用来删除它们。</p>
<p>幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当被监测对象变得无法访问，它们就会自动收集监测处理器。这是过去的一些浏览器无法处理的情况（例如旧的IE6）。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="IE7-8引用计数使用循环引用产生的问题"><a href="#IE7-8引用计数使用循环引用产生的问题" class="headerlink" title="IE7/8引用计数使用循环引用产生的问题"></a>IE7/8引用计数使用循环引用产生的问题</h2><pre><code class="javascript">function fn(){
  var a = {};
  var b= {};
  a.pro = b;
  b.pro = a;
}
fn();
</code></pre>
<p>在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。在IE7与IE8上，内存直线上升。</p>
<p>IE中有一部分对象并不是原生js对象。例如，其内存泄漏DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p>
<p>IE9+并不存在循环引用导致Dom内存泄漏问题</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.jianshu.com/p/763ba9562864" target="_blank" rel="external">JS哪些操作会造成内存泄漏？</a></li>
<li><a href="http://web.jobbole.com/93078/" target="_blank" rel="external">JavaScript 中的内存泄漏以及如何处理</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据类型]]></title>
      <url>/2017/04/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这篇文章整理一些数据类型的点和坑。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>String、boolean、Number、undefined、null</p>
<p>ECMAScript 2015新增:Symbol(创建后独一无二且不可变的数据类型)</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>在JavaScript中字符串是一组由16位值组成的不可变的有序序列，每个字符通常来自Unicode字符集。（《JavaScript权威指南》）</p>
<p><strong>在JavaScript中所有基础类型都不可以修改</strong></p>
<p> String()方法同样能实现 toString()的效果，但是 <strong>可以对 null 和undefined进行操作</strong>。</p>
<blockquote>
<p>内部原理：先调用 toString(),如果可以转换成字符串，就将结果直接返回。否则，再进行判断是 null 还是 undefined，然后返回‘null’ 或 ‘undefined’</p>
</blockquote>
<p>如果知道变量不可能是 null  或 undefined，就使用 toString()性能比 String(), 因为 String()内部还要做判断，所以有损性能。</p>
<h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>if() 语句的 ()  内部就是调用了 Boolean函数</p>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>和大多数编程语言不同，JavaScript的number类型不区分整数和浮点数，所有数字都适用浮点数表示。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ol>
<li>var d=0/0;  注意：在js里是不会报错的，而是返回 NaN </li>
<li>可以通过Number.NaN 来获取 </li>
<li>NaN和 任何 对象做运算都会返回 NaN</li>
<li>isNaN()判断是不是 NaN</li>
</ol>
<blockquote>
<p>isNaN()内部执行原理：同样适用于对象。实现原理：首相调用对象的valueOf()方法，如果能转换成数字就直接做判断；如果不能就再调用toString()方法，然后测试返回值。</p>
</blockquote>
<h4 id="将其他数据类型转换成Number类型"><a href="#将其他数据类型转换成Number类型" class="headerlink" title="将其他数据类型转换成Number类型"></a>将其他数据类型转换成Number类型</h4><ul>
<li>Number():可以针对所有的数据类型进行转换；</li>
<li>parseInt()和parseFloat() 只针对字符串进行转化。</li>
</ul>
<blockquote>
<p>Number()内部实现的原理：同isNaN(), 也是先调用 valueOf(), 然后调用 toString()。所以可想而知，性能是比较差的。优先使用 parseInt()  或者 parseFloat()</p>
</blockquote>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>表示未定义（声明）过的变量</p>
<p>Note：如果Object类型的 对象变量开始不知道赋值什么，不要  <code>var demo={}</code>；最好设置成null；</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>已声明未赋值</p>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>Object、Array、Date、RegExp、Function</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p><strong>Case</strong></p>
<pre><code class="javascript">var s=&#39;test&#39;;
s.len=4;
console.log(s.len);//undefined
</code></pre>
<p><strong>只要引用了字符串属性，JavaScript就会通过调用 new String(s) 来创建一个临时对象</strong>，我们使用的indexOf方法和length属性正是来源于这个临时对象，<strong>每次使用都创建一次，然后销毁。这个临时对象就是包装对象</strong>，不只是string，number和boolean类型同样有包装对象。</p>
<p>上面代码可以这样解析</p>
<pre><code class="javascript">var s=&#39;test&#39;;//创建字符串类型变量
s.len=4;//创建包装对象，为包装对象添加属性len
//引用完毕，销毁包装对象
console.log(s.len);//创建包装对象，查找其len属性，没有找到，返回undefined
</code></pre>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>函数转换：parseInt()、parseFloat()、toString()<br>强类型转换：Boolean()、Number()、String()<br>弱类型转换：“==”、“-”、“+”、if（）</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a=[0], b=a, b=[1];
console.log(a+b);
</code></pre>
<p>最后问题可以变为[0]+[1]，一不小心就会写为1，但是这时候我们调用的是数组的toString方法，实际是’0’+’1’=’01’</p>
<p><strong>类型转换表</strong>：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>转换为字符串</th>
<th>转换为数字</th>
<th>转换为布尔值</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>“undefined”</td>
<td>NaN</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>“null”</td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>“true”</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>false</td>
<td>“false”</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>“”</td>
<td></td>
<td>0</td>
<td>false</td>
</tr>
<tr>
<td>“2.5”</td>
<td></td>
<td>2.5</td>
<td>true</td>
</tr>
<tr>
<td>“string”</td>
<td></td>
<td>NaN</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>“0”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>1</td>
<td>“1”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>NaN</td>
<td>“NaN”</td>
<td></td>
<td>false</td>
</tr>
<tr>
<td>Infinity</td>
<td>“Infinity”</td>
<td></td>
<td>true</td>
</tr>
<tr>
<td>[2]</td>
<td>“2”</td>
<td>2</td>
<td>true</td>
</tr>
</tbody>
</table>
<p><strong>Case</strong></p>
<pre><code class="javascript">Boolean([]);//true
Object(3);//new Number(3)
5+&quot;&quot;;//String(5)
+&quot;5&quot;;//5，变成了数字 Number(&quot;5&quot;)
&quot;5&quot;-0;//5,也是数字
</code></pre>
<h2 id="toString和valueOf"><a href="#toString和valueOf" class="headerlink" title="toString和valueOf"></a>toString和valueOf</h2><p>valueOf()内部调用了toObject()方法。</p>
<p>toString()方法 将其他数据类型转换成 String类型。但是如果对 null 或undefined  进行操作的话就会报错。</p>
<h3 id="对象转为字符串"><a href="#对象转为字符串" class="headerlink" title="对象转为字符串"></a>对象转为字符串</h3><p>对象转换为字符串过程大概是这样</p>
<ol>
<li>如果对象具有toString方法则调用该方法，如果方法返回的是一个基本类型（有坑爹的toString方法不返回string类型的），JavaScript把这个值转换为字符串返回</li>
<li>如果对象没有toString方法，或者该方法返回的不是一个基本类型，那么就会调用valueOf方法，如果存在valueOf方法并且valueOf返回的是基本类型，那么将值转换为字符串输出</li>
<li>再如果就只能报错了</li>
</ol>
<h3 id="对象转为数字"><a href="#对象转为数字" class="headerlink" title="对象转为数字"></a>对象转为数字</h3><p>对象转换为数字过程大概是这样</p>
<ol>
<li>如果对象有valueOf方法，并且方法返回基本类型，则把值转换为数字返回</li>
<li>如果对象具有toString方法，且方法返回基本类型，则转换为数字返回</li>
<li>否则就报错</li>
</ol>
<p>上面情况只是针对强制转换，也就是我们显示的调用String或者Number构造函数的时候的处理，在平常使用中，<strong>在”显示“相关操作中会优先调用toString方法，而在运算相关操作中会优先调用valueOf方法</strong>。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var o = {
        x: 8,
        valueOf: function(){
            return this.x + 2;
        },
        toString: function(){
            return this.x;
        }
    };
console.log(String(o));//&quot;8&quot;
console.log(Number(o)); //10
console.log(o+1);//11，运算相关
alert(o);//&quot;8&quot;，显现相关
</code></pre>
<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><p>有几个看起来比较蹊跷需要我们注意</p>
<ol>
<li>typeof是运算符，不是方法，也就是说和加减号一样用，不考虑优先级问题，没必要给操作数加括号，当然加了也没事儿，说实话可读性还挺高</li>
<li>typeof返回值都是小写字符串</li>
<li>null的类型不是null，而是”object”</li>
<li>NaN这个不是数字的类型也是”number”</li>
<li>function明明也是对象，但是typeof却给了”function”类型</li>
<li>其它对象都返回”object”,很没有识别性</li>
</ol>
<h3 id="instanceof操作符"><a href="#instanceof操作符" class="headerlink" title="instanceof操作符"></a>instanceof操作符</h3><p><strong>对于基本类型，instanceof 永远返回false</strong></p>
<pre><code class="javascript">1 instanceof Number; //false
new Number(1) instanceof Number; //true
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="undefined-和null-的区别和注意点"><a href="#undefined-和null-的区别和注意点" class="headerlink" title="undefined 和null 的区别和注意点"></a>undefined 和null 的区别和注意点</h2><ol>
<li>如果用 “==” 进行比较，他们是相等的，因为比较的是值</li>
<li><p>区分他们有两种方法（他们的核心都是比较他们的数据类型）</p>
<p>1）使用typeof将他们区分开  </p>
<p>2）使用<strong>全等“===”: 比较的是 值和 数据类型</strong>，只有全都相同才返回 true</p>
</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3521118.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——数据类型</a></li>
<li><a href="https://www.2cto.com/kf/201312/266358.html" target="_blank" rel="external">javascript之六种数据类型以及特殊注意点</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[上下文]]></title>
      <url>/2017/03/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p>这篇文章介绍上下文以及Apply, call and bind的概念和常用方法。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><code>this</code>的指向就是我们这里所说的<strong>执行上下文（执行环境）</strong></p>
<p><code>this</code>指向的永远是调用该方法的对象</p>
<p>在 ES5 中，其实 this 的指向，始终坚持一个原理：<strong>this 永远指向最后调用它的那个对象</strong></p>
<h3 id="怎么改变-this-的指向"><a href="#怎么改变-this-的指向" class="headerlink" title="怎么改变 this 的指向"></a>怎么改变 this 的指向</h3><h4 id="使用-ES6-的箭头函数"><a href="#使用-ES6-的箭头函数" class="headerlink" title="使用 ES6 的箭头函数"></a>使用 ES6 的箭头函数</h4><p>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</p>
<p><strong>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined</strong></p>
<h4 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h4><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>基本作用: <strong>改变对象的执行上下文</strong></p>
<p>call 的语法为：<code>fun.call(thisArg[, arg1[, arg2[, ...]]])</code></p>
<p>如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 thisArg 会指向该原始值的自动包装对象。</p>
<p>call是apply的语法糖。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>基本作用: <strong>改变对象的执行上下文</strong></p>
<p>语法：<code>fun.apply(thisArg, [argsArray])</code></p>
<blockquote>
<p>Note: argsArray从ECMAScript 5 开始可以使用类数组对象。</p>
</blockquote>
<p>当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><code>bind</code>是在EcmaScript5中扩展的方法（IE6,7,8不支持）</p>
<p>MDN的解释是：<code>bind()</code>方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 <code>bind()</code>方法的第一个参数作为 <code>this</code>，传入 <code>bind()</code> 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p><strong>注意：<code>bind</code>方法的返回值是函数。所以，bind 是创建一个新的函数，要手动去调用</strong></p>
<p><code>bind()</code>最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的this值。常见的错误，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="上下文指向"><a href="#上下文指向" class="headerlink" title="上下文指向"></a>上下文指向</h2><h3 id="执行上下文结果"><a href="#执行上下文结果" class="headerlink" title="执行上下文结果"></a>执行上下文结果</h3><pre><code class="javascript">function func () {
    this.a = 1;
    console.log(this.a);
}
func();  // 1
a或window.a; //1
</code></pre>
<p>由于<code>func</code>是全局对象<code>window</code>下的一个方法，那么调用该方法的对象就应该是全局对象<code>window</code>，所以<code>this</code>理论上指向的对象就应该是<code>window</code></p>
<h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>e.g.1</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
function a() {
 var name = &quot;Cherry&quot;;
 console.log(this.name);   // windowsName
 console.log(&quot;inner:&quot; + this); // inner: Window
}
a();
console.log(&quot;outer:&quot; + this)   // outer: Window
</code></pre>
<p>e.g.2</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
 var a = {
  name: &quot;Cherry&quot;,
  fn : function () {
   console.log(this.name);  // Cherry
  }
 }
 a.fn();
</code></pre>
<p>e.g.3</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
  name: &quot;Cherry&quot;,
  fn : function () {
    console.log(this.name);  // Cherry
  }
}
window.a.fn();
</code></pre>
<p>e.g.4</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 // name: &quot;Cherry&quot;,
 fn : function () {
  console.log(this.name);  // undefined
 }
}
window.a.fn();
</code></pre>
<p>e.g.5</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : null,
 // name: &quot;Cherry&quot;,
 fn : function () {
  console.log(this.name);  // windowsName
 }
}
var f = a.fn;
f();
</code></pre>
<p>e.g.6</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
function fn() {
 var name = &#39;Cherry&#39;;
 innerFunction();
 function innerFunction() {
  console.log(this.name);  // windowsName
 }
}
fn()
</code></pre>
<h2 id="call-与-apply"><a href="#call-与-apply" class="headerlink" title="call 与 apply"></a>call 与 apply</h2><h3 id="为什么需要改变执行上下文"><a href="#为什么需要改变执行上下文" class="headerlink" title="为什么需要改变执行上下文"></a>为什么需要改变执行上下文</h3><p>A对象有一个方法，而B对象因为某种不可言说的情况也需要用到一样的方法，那么这时候我们是单独为B扩展个方法呢，还是借用一下A的方法呢？当然是借用A的啦，既完成了需求，又减少了内存的占用</p>
<h3 id="call-与-apply-异同"><a href="#call-与-apply-异同" class="headerlink" title="call 与 apply 异同"></a>call 与 apply 异同</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，立即执行</p>
<p>都用来改变当前函数调用的对象。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><code>call</code>方法从第二个参数开始可以接收任意个参数</p>
<p><code>apply</code>方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入func中</p>
<p><code>foo.call(this,arg1,arg2) == foo.apply(this, arguments)==this.foo(arg1, arg2)</code></p>
<h3 id="call和apply常用用法"><a href="#call和apply常用用法" class="headerlink" title="call和apply常用用法"></a>call和apply常用用法</h3><h4 id="1-数组之间追加"><a href="#1-数组之间追加" class="headerlink" title="1.数组之间追加"></a>1.数组之间追加</h4><pre><code class="javascript">var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; 
var array2 = [&quot;Doe&quot; , 555 , 100]; 
Array.prototype.push.apply(array1, array2); 
/* array1 值为  [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */
</code></pre>
<h4 id="2-获取数组中的最大值和最小值"><a href="#2-获取数组中的最大值和最小值" class="headerlink" title="2. 获取数组中的最大值和最小值"></a>2. 获取数组中的最大值和最小值</h4><pre><code class="javascript">var  numbers = [5, 458 , 120 , -215 ]; 
var maxInNumbers = Math.max.apply(Math, numbers),   //458
    maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458
</code></pre>
<h4 id="3-验证是否是数组（前提是toString-方法没有被重写过）"><a href="#3-验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="3.验证是否是数组（前提是toString()方法没有被重写过）"></a>3.验证是否是数组（前提是toString()方法没有被重写过）</h4><pre><code class="javascript">functionisArray(obj){ 
    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ;
}
</code></pre>
<h4 id="4-类（伪）数组使用数组方法"><a href="#4-类（伪）数组使用数组方法" class="headerlink" title="4.类（伪）数组使用数组方法"></a>4.类（伪）数组使用数组方法</h4><pre><code class="javascript">var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;));
</code></pre>
<h4 id="5-给每一个-log-消息添加一个”-app-”的前辍"><a href="#5-给每一个-log-消息添加一个”-app-”的前辍" class="headerlink" title="5. 给每一个 log 消息添加一个”(app)”的前辍"></a>5. 给每一个 log 消息添加一个”(app)”的前辍</h4><pre><code class="javascript">function log(){
  var args = Array.prototype.slice.call(arguments);
  args.unshift(&#39;(app)&#39;);
  console.log.apply(console, args);
};
</code></pre>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="箭头函数this"><a href="#箭头函数this" class="headerlink" title="箭头函数this"></a>箭头函数this</h3><pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : &quot;Cherry&quot;,
 func1: function () {
  console.log(this.name)  
 },
 func2: function () {
  setTimeout( () =&gt; {
   this.func1()
  },100);
 }
};
a.func2()  // Cherry
</code></pre>
<p>替代方法：在函数内部使用 _this = this</p>
<pre><code class="javascript">var name = &quot;windowsName&quot;;
var a = {
 name : &quot;Cherry&quot;,
 func1: function () {
  console.log(this.name)  
 },
 func2: function () {
  var _this = this;
  setTimeout( function() {
   _this.func1()
  },100);
 }
};
a.func2()  // Cherry
</code></pre>
<h2 id="bind-1"><a href="#bind-1" class="headerlink" title="bind"></a>bind</h2><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p><code>bind</code> 是返回<strong>对应函数</strong>，便于<strong>稍后调用</strong>；<code>apply</code> 、<code>call</code> 则是立即调用 。</p>
<pre><code class="javascript">var a ={
 name : &quot;Cherry&quot;,
 fn : function (a,b) {
  console.log( a + b)
 }
}
var b = a.fn;
b.bind(a,1,2)    //没有输出
</code></pre>
<p>bind 是创建一个新的函数，我们必须要手动去调用：</p>
<pre><code class="javascript">var a ={
  name : &quot;Cherry&quot;,
  fn : function (a,b) {
   console.log( a + b)
  }
 }
 var b = a.fn;
 b.bind(a,1,2)()   // 3
</code></pre>
<h3 id="连续-bind-多次输出的值"><a href="#连续-bind-多次输出的值" class="headerlink" title="连续 bind() 多次输出的值"></a>连续 bind() 多次输出的值</h3><pre><code class="javascript">var bar = function(){
    console.log(this.x);
}
var foo = {
    x:3
}
var sed = {
    x:4
}
var func = bar.bind(foo).bind(sed);
func(); //3

var fiv = {
    x:5
}
var func = bar.bind(foo).bind(sed).bind(fiv);
func(); //3
</code></pre>
<p>原因是，在Javascript中，<strong>多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</strong>可以理解成每次bind后生成一个新函数，而这个新函数的没有this指向。</p>
<h3 id="bind使用"><a href="#bind使用" class="headerlink" title="bind使用"></a>bind使用</h3><h4 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h4><pre><code class="javascript">var foo = {
    bar : 1,
    eventBind: function(){
        $(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) {
            /* Act on the event */
            console.log(this.bar);      //1
        }.bind(this));
    }
}
</code></pre>
<h4 id="偏函数（Partial-Functions）"><a href="#偏函数（Partial-Functions）" class="headerlink" title="偏函数（Partial Functions）"></a>偏函数（Partial Functions）</h4><p>这是一个很好的特性，使用<code>bind()</code>我们设定函数的预定义参数，然后调用的时候传入其他参数即可：</p>
<pre><code class="javascript">function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

// 预定义参数37
var leadingThirtysevenList = list.bind(undefined, 37);

var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
</code></pre>
<h4 id="和setTimeout一起使用"><a href="#和setTimeout一起使用" class="headerlink" title="和setTimeout一起使用"></a>和setTimeout一起使用</h4><p>一般情况下<code>setTimeout()</code>的this指向window或global对象。当使用类的方法时需要this指向类实例，就可以使用<code>bind()</code>将this绑定到回调函数来管理实例。</p>
<p><strong>注意：对于事件处理函数和setInterval方法也可以使用上面的方法</strong></p>
<pre><code class="javascript">function Bloomer() {
  this.petalCount = Math.ceil(Math.random() * 12) + 1;
}

// 1秒后调用declare函数
Bloomer.prototype.bloom = function() {
  window.setTimeout(this.declare.bind(this), 1000);
};

Bloomer.prototype.declare = function() {
  console.log(&#39;我有 &#39; + this.petalCount + &#39; 朵花瓣!&#39;);
};
</code></pre>
<h4 id="绑定函数作为构造函数"><a href="#绑定函数作为构造函数" class="headerlink" title="绑定函数作为构造函数"></a>绑定函数作为构造函数</h4><p>绑定函数也适用于使用new操作符来构造目标函数的实例。当使用绑定函数来构造实例，<strong>注意：this会被忽略</strong>，但是传入的参数仍然可用。</p>
<pre><code class="javascript">function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function() { 
  return this.x + &#39;,&#39; + this.y; 
};

var p = new Point(1, 2);
p.toString(); // &#39;1,2&#39;


var emptyObj = {};
var YAxisPoint = Point.bind(emptyObj, 0/*x*/);
// 实现中的例子不支持,
// 原生bind支持:
var YAxisPoint = Point.bind(null, 0/*x*/);

var axisPoint = new YAxisPoint(5);
axisPoint.toString(); // &#39;0,5&#39;

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new Point(17, 42) instanceof YAxisPoint; // true
</code></pre>
<p>Point和YAxisPoint共享原型，因此使用<code>instanceof</code>运算符判断时为true。</p>
<h4 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h4><p><code>bind()</code>也可以为需要特定this值的函数创造捷径。</p>
<pre><code class="javascript">var slice = Array.prototype.slice;
// ...
slice.call(arguments);
</code></pre>
<p>如果使用<code>bind()</code>的话，情况变得更简单：</p>
<pre><code class="javascript">var unboundSlice = Array.prototype.slice;
var slice = Function.prototype.call.bind(unboundSlice);
// ...
slice(arguments);
</code></pre>
<h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="apply-实现"><a href="#apply-实现" class="headerlink" title="apply()实现"></a>apply()实现</h2><p>模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<pre><code class="javascript">Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&#39;arr[&#39; + i + &#39;]&#39;);
        }
        result = eval(&#39;context.fn(&#39; + args + &#39;)&#39;)
    }

    delete context.fn
    return result;
}
</code></pre>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind()实现"></a>bind()实现</h2><p>通过给目标函数指定作用域来简单实现:</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  self = this;  //保存this，即调用bind方法的目标函数
  return function(){
      return self.apply(context,arguments);
  };
};
</code></pre>
<p>考虑到<a href="http://blog.jobbole.com/77956/" target="_blank" rel="external">函数柯里化</a>的情况，我们可以构建一个更加健壮的<code>bind()</code>：</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  var args = Array.prototype.slice.call(arguments, 1),
  self = this;
  return function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply(context,finalArgs);
  };
};
</code></pre>
<p>这次的<code>bind()</code>方法可以绑定对象，也支持在绑定的时候传参。</p>
<p>Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p>
<pre><code class="javascript">Function.prototype.bind = function(context){
  var args = Array.prototype.slice(arguments, 1),
  F = function(){},
  self = this,
  bound = function(){
      var innerArgs = Array.prototype.slice.call(arguments);
      var finalArgs = args.concat(innerArgs);
      return self.apply((this instanceof F ? this : context), finalArgs);
  };

  F.prototype = self.prototype;
  bound.prototype = new F();
  retrun bound;
};
</code></pre>
<p>这是《JavaScript Web Application》一书中对<code>bind()</code>的实现：通过设置一个中转构造函数F，使绑定后的函数与调用<code>bind()</code>的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的<code>bind()</code>实现。</p>
<p>对于为了在浏览器中能支持<code>bind()</code>函数，只需要对上述函数稍微修改即可：</p>
<pre><code class="javascript">Function.prototype.bind = function (oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1), 
      fToBind = this, 
      fNOP = function () {},
      fBound = function () {
        return fToBind.apply(
          this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
          aArgs.concat(Array.prototype.slice.call(arguments))
        );
      };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000002662251" target="_blank" rel="external">Javascript中bind()方法的使用与实现</a></li>
<li><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="external">JavaScript深入之call和apply的模拟实现</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[继承]]></title>
      <url>/2017/03/25/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>本文介绍继承的写法，参考《JS高程》。<br>封装、多态待补。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><pre><code class="javascript">function Parent0(){
    this.name = &quot;parent0&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child0(){
    Parent0.call( this ); // 或apply
    this.type = &quot;child0&quot;;
}
</code></pre>
<p>问题：</p>
<p>这种方式，父类原型上的东西（<strong>原型对象</strong>）是没法继承的，因此函数复用也就无从谈起，（部分继承）</p>
<h3 id="原型链式继承（借用原型链实现继承）"><a href="#原型链式继承（借用原型链实现继承）" class="headerlink" title="原型链式继承（借用原型链实现继承）"></a>原型链式继承（借用原型链实现继承）</h3><pre><code class="javascript">function Parent1(){
    this.name = &quot;parent1&quot;;
    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;];
}
function Child1(){
    this.name = &quot;child1&quot;;
}
Child1.prototype = new Parent1();
</code></pre>
<p>这种方式确实解决了上面借用构造函数继承方式的缺点。</p>
<p>问题：</p>
<ol>
<li><strong>注意：包含引用类型会被共享</strong></li>
<li><strong>构造子类型无法向超类型构造函数传参。</strong></li>
</ol>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>这里所谓的组合是指组合借用构造函数和原型链继承两种方式。</p>
<pre><code class="javascript">//2.原型连继承和借用构造函数 组合实现继承 （组合继承解决原型链继承的引用类型原型属性被实例共享问题）  
function father(name) {  
  this.faName = &#39;father&#39;;  
}  
father.prototype.getfaName = function() {  
  console.log(this.faName);  
};  
function child(args) {  
  this.chName = &#39;child&#39;;  
  father.apply(this,[]); //第二次调用父类构造函数  
}  
child.prototype = new father(); //第一次调用父类构造函数  
child.prototype.constructor = child;  
child.prototype.getchName = function() {  
  console.log(this.chName);  
};  
/* 
缺点：1.两次调用父类构造函数：（第一次是在创建子类原型的时候，第二次是在子类构造函数内部） 
     2.子类继承父类的属性，第二次一组在子类实例上，第一次一组在子类原型上（在子类原型上创建不必要的多余的属性）（实例上的屏蔽原型上的同名属性）效率低 
*/
</code></pre>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><pre><code class="javascript">function object (o) {
    function F() {}
    F.prototype = o;
    return new F();
}
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person1 = object (person);
person1.name = &quot;Gerg&quot;;
person1.friends.push(&quot;Job&quot;);
console.log(person1.name);
console.log(person1.friends);

var person2 = object(person);
console.log(person2.name);
console.log(person2.friends);

或es5
var person = {
    name: &quot;Nicholas&quot;,
    friends: [&quot;shelby&quot;,&quot;Count&quot;,&quot;Van&quot;]
}
var person2 = object.create(person);
</code></pre>
<p>object函数就是改变构造函数的prototype对象的，比如说你要继承person中的属性，那么就写一个空函数，把空函数的prototype对象修改成person。</p>
<p>问题：</p>
<p>引用类型有问题，同原型链式继承</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><pre><code class="javascript">function createAnother(original){
 var clone = Object.create(original); //通过调用函数创建一个新对象
 clone.sayHi = function(){    //以某种方式来增强这个对象
  alert(&quot;Hi&quot;);
 };

 return clone;      //返回这个对象
}

var person = {
 name: &quot;Bob&quot;,
 friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();
</code></pre>
<p>问题：</p>
<p>添加函数，不能复用</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><pre><code class="javascript">function inheritPrototype(subType, superType){
 var protoType = Object.create(superType.prototype); //创建对象
 protoType.constructor = subType;     //增强对象
 subType.prototype = protoType;      //指定对象
}

function SuperType(name){
 this.name = name;
 this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
}
SuperType.prototype.sayName = function(){
 alert(this.name);
}

function SubType(name, age){
 SuperType.call(this, name);　　//第二次调用SuperType()

 this.age = age;
}
inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function(){
 alert(this.age);
}

var instance = new SubType(&quot;Bob&quot;, 18);
instance.sayName();
instance.sayAge();
</code></pre>
<p>将新创建的对象（即副本）赋值给子类型的原型这种方法只调用了一次SuperType构造函数，instanceof 和isPrototypeOf()也能正常使用。</p>
<h3 id="ES6中继承"><a href="#ES6中继承" class="headerlink" title="ES6中继承"></a>ES6中继承</h3><p><code>Class</code> 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code class="javascript">class Parent {
}
class Child1 extends Parent {
    constructor(x, y, colors) {
         super(x, y); // 调用父类的constructor(x, y)
         this.colors = colors;
    }
    toString() {
         return this.colors + &#39; &#39; + super.toString(); // 调用父类的toString()
    }
}
</code></pre>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>
<p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
<p>另一个需要注意的地方是， 在子类的构造函数中， 只有调用super之后， 才可以使用this关键字， 否则会报错。 这是因为子类实例的构建， 是基于对父类实例加工， 只有super方法才能返回父类实例。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="ES6继承的原理"><a href="#ES6继承的原理" class="headerlink" title="ES6继承的原理"></a>ES6继承的原理</h2>]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面向对象]]></title>
      <url>/2017/02/28/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>本文介绍面向对象编程的思想</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="方法一：Object"><a href="#方法一：Object" class="headerlink" title="方法一：Object()"></a>方法一：Object()</h3><h3 id="方法二：对象字面量"><a href="#方法二：对象字面量" class="headerlink" title="方法二：对象字面量"></a>方法二：对象字面量</h3><p><strong>Case</strong></p>
<pre><code class="javascript">var bitch = new Object();
bitch.boobs = &#39;huge&#39;;
bitch[&#39;bf&#39;] = {name:Jhon,age:22};
</code></pre>
<p>在调用Object()构造函数时，new运算符实际上是可以省略的，这点可以推广到其他很多构造函数上，但有两个是例外：String() 和 Number()。<strong>对这两个函数而言，如果不加new，只是作一次数据类型的转换，得到的将是基本数据类型的值；而带new运算符的话，得到的将是String/Number的实例。</strong></p>
<p>这两种方法创建对象简单直观，但也存在问题，那就是<strong>无法批量生产对象</strong>。由此，工厂模式应运而生。</p>
<h3 id="方法三：工厂模式（注意区别于设计模式中的工厂模式）"><a href="#方法三：工厂模式（注意区别于设计模式中的工厂模式）" class="headerlink" title="方法三：工厂模式（注意区别于设计模式中的工厂模式）"></a>方法三：工厂模式（注意区别于设计模式中的工厂模式）</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    var bitch = new Object();
    bitch.boobs = boobs;
    bitch.bf = {name:bfName,age:bfAge};
    bitch.cry = function(){console.log(&#39;Crying&#39;);}
　　return bitch;
}
　　bitch=Bitch(&#39;huge&#39;,&#39;Jhon&#39;,22);
</code></pre>
<p><strong>工厂模式解决了对象的批量生产问题，但还有个问题没有解决——对象的识别问题</strong>。也就是说，这样创建出来的对象是独立的个体，跟其他对象没关系，即使是用同一个函数创建出来的对象，也是互不相识的:</p>
<p><code>bitch instanceof Bitch //false</code></p>
<h3 id="方法四：构造函数模式"><a href="#方法四：构造函数模式" class="headerlink" title="方法四：构造函数模式"></a>方法四：构造函数模式</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    this.boobs=boobs;
    this.bf={name:bfName, age:bfAge};
　  this.cry = function(){console.log(&#39;Crying&#39;);}
}
bitch=new Bitch(&#39;huge&#39;,&#39;Jhon&#39;,22);
</code></pre>
<p>对比工厂模式可以发现构造函数模式的特点：一，没有显示创建对象，而是直接将对象属性赋给了this指针；二，没有return语句；三，调用时需要用new运算府。其实，最关键的地方在于这个new运算符，如果不加这个new，那构造函数就是个普通函数；而任何普通函数在调用时前面加new运算符的话就会变成构造函数。</p>
<p>对象识别没有问题，但存在一个问题：对象的所有函数属性在每个对象上都要重新创建一遍，而这些函数实际上完全相同</p>
<h3 id="方法五：原型模式"><a href="#方法五：原型模式" class="headerlink" title="方法五：原型模式"></a>方法五：原型模式</h3><p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boobs,bfName,bfAge){
    this.boobs=boobs;
    this.bf={name:bfName, age:bfAge};
}
Bitch.prototype.cry = function(){console.log(&#39;Crying&#39;);};
</code></pre>
<p>组合使用构造函数模式和原型模式，前者负责个性，后者负责共性</p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>通过闭包访问</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Bitch(boo,bfName,bfAge){
    var boobs = boo; // 私有属性
    this.bf={name:bfName, age:bfAge}; // 公共属性
    this.watchBoobs = function(){ return &#39;huge&#39;; }; // 私有属性的访问接口
}
Bitch.prototype.cry = function(){console.log(&#39;Crying&#39;);};
</code></pre>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>Case</strong></p>
<pre><code class="javascript">function Sup(a){
    this.a = a;
}
Sup.prototype.foo = function(){console.log(&#39;Function of Sup.prototype&#39;);}
function Sub(a,b){
    this.a = a;
    this.b = b;
}
Sub.prototype = new Sup();
Sub.prototype.bar = function(){console.log(&#39;Function of Sub.prototype&#39;);}
</code></pre>
<p>注意比较JS继承与传统OO语言继承之间的差别，我觉得区别主要有两点：</p>
<ul>
<li>传统OO语言的继承是类的继承，是抽象概念之间的继承，实现继承并不需要父类的实例；而JS的继承则是实例的继承，子类继承的是父类的一个实例。</li>
<li>传统OO语言的继承分public/private/protected等不同的继承方式，而JS本身连私有变量的概念都没有，就更不可能区分共有继承和私有继承了。</li>
</ul>
<p>上述JS实现继承的方式称为“原型模式”，这种方式存在几个缺点：</p>
<ul>
<li>在创建子类实例时，不能向父类的构造函数传递参数</li>
<li>当父类属性存在引用类型值时，会造成致命问题。</li>
</ul>
<p>解决方法：借用构造函数模式，将二者结合起来</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Sup(a){
    this.a = a;
}
Sup.prototype.foo = function(){console.log(&#39;Function of Sup.prototype&#39;);}
function Sub(a,b){
    Sup.apply(this,arguments);    //Sup.call(this,a);不方便扩展
    this.b = b;
}
Sub.prototype = new Sup();
Sub.prototype.construtor = Sub;
Sub.prototype.bar = function(){console.log(&#39;Function of Sub.prototype&#39;);}
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/zhangjianhu/p/4548693.html" target="_blank" rel="external">由几道JS笔试题引发的知识点探究十五——JS面向对象编程</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逗号、冒号与括号]]></title>
      <url>/2017/02/27/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E9%80%97%E5%8F%B7%E3%80%81%E5%86%92%E5%8F%B7%E4%B8%8E%E6%8B%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>有看见一些很好的博文做这点，感觉有必要对这些坑总结记录一下。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="逗号"><a href="#逗号" class="headerlink" title="逗号"></a>逗号</h2><p><strong>连续声明一些变量</strong></p>
<p><strong>方法参数，对象属性</strong>我们使用逗号隔开</p>
<p><strong>赋值表达式</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a=(1,2,3);
</code></pre>
<p>在表达式与运算符中提到过逗号运算符就是对应这种情况，这时表达式计算结果是最后一个子表达式结果，也就是3。千万不要误会前面的子表达式不会执行，每个子表达式都会执行，只不过“返回值”是最后一个表达式结果。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">var a,b;
a=(b=1,2);
console.log(a);//2
console.log(b);//1
</code></pre>
<h2 id="冒号"><a href="#冒号" class="headerlink" title="冒号"></a>冒号</h2><p><strong>?:运算符</strong></p>
<p><strong>对象字面量</strong></p>
<p><strong>switch语句</strong></p>
<p><strong>声明label</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">x:y:z:1,2,3;
//相当于
x:
 y:
  z:1,2,3
</code></pre>
<p>其实冒号还有个作用：声明label，JavaScript中语句可以有个标签前缀，我们称之为标记语句</p>
<h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h2><p><strong>对象直接量声明</strong></p>
<p><strong>函数声明或者函数直接量</strong></p>
<p><strong>组织复合语句</strong></p>
<h3 id="大括号没有带来块级作用域"><a href="#大括号没有带来块级作用域" class="headerlink" title="大括号没有带来块级作用域"></a>大括号没有带来块级作用域</h3><ol>
<li>在function外使用声明变量（无论是否使用var）</li>
<li>在function内不是用var 声明变量</li>
<li>直接赋值于window属性</li>
<li>除了这三种剩下的就是function范围内的局部变量了</li>
</ol>
<p><strong>Case</strong></p>
<pre><code class="javascript">{a:1};        //1
var x={a:1};
{a:1,b:2};    //报错
var y={a:1,b:2};
</code></pre>
<p><strong>{a:1}</strong> JavaScript有传说中的“语句优先”，也就是当大括号既可以被理解为复合语句块也可以被理解为对象直接量的时候，JavaScript会将其理解为复合语句快。{a:1}其实就是 <strong>a: 1</strong>，想想冒号的作用是不是知道为什么返回值是1了。</p>
<p><strong>{a:1,b:2};</strong> 看了上面这个就简单了，可以翻译为：<strong>a:1,b:2</strong> 结合逗号和冒号作用，结果似乎显而易见了，就是2嘛。然而其实报错了，这是为什么？在<strong>逗号运算符后面必须是表达式</strong>，而标签语句十个label statement，是条语句，所以就报错了。</p>
<p><strong>Case</strong></p>
<pre><code class="javascript">{foo:[1,2,3]}[0];
{a:1}+2;
2+{a:1};
</code></pre>
<p><strong>大括号虽然看起来没什么作用，但起到了语句分隔符作用</strong>，{foo:[1,2,3]}[0]可以理解为</p>
<pre><code class="javascript">{foo:[1,2,3]};
[0];
</code></pre>
<p>所以返回值是[0]，同样{a:1}+2变为</p>
<pre><code class="javascript">{a:1};
+2
</code></pre>
<p>但是！为什么2+{a:1}就不一样了呢？这时加法运算符导致的，加号是左结合的，{}被解析为表达式（得是表达式相加嘛），根据<a href="http://www.cnblogs.com/dolphinX/p/3521118.html" target="_blank" rel="external">数据类型</a>中知识对象{a:1}转换为NaN</p>
<h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h2><p><strong>函数声明或调用表达式参数表</strong></p>
<p><strong>与一些关键字组成条件语句</strong></p>
<p><strong>分组运算符</strong></p>
<p>对于简单的json字符串转为对象的时候，因为浏览器兼容性原因，不能使用JSON对象，又懒得引入json2，所以就会用eval()处理，大概写法这样</p>
<pre><code class="javascript">var jsonStr=...;
var jsonObj=eval(&#39;(&#39; + jsonStr + &#39;)&#39;);
</code></pre>
<p>为什么还要加上个小括号呢？像我们上面解释的大括号的作用，json字符串 “{a:1,b:2}” 这样的格式会被理解为语句，也就是传说中的label statement，上面提到过逗号运算符不能在label statement后面，所以会报错，而加上括号后由于分组运算符只能包含表达式，所以{}变成直接量语法，这样就是我们希望的内容了。</p>
<h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h3><p>函数表达式和函数声明区别:</p>
<p>常用的区分方式是根据上下文，如果function fn(){}作为右值出现（赋值表达式右边）那么就是表达式，否则就是函数声明。有几种看起来不常规的方式需要我们注意</p>
<pre><code class="javascript">new function fn(){}; //表达式，因为在new 表达式中
(function(){}());//表达式，在分组运算符中
</code></pre>
<p>所以应该称立即执行函数为立即调用的函数表达式！</p>
<h2 id="中括号"><a href="#中括号" class="headerlink" title="中括号"></a>中括号</h2><p><strong>数组相关</strong></p>
<p><strong>获取对象属性值</strong></p>
<p><strong>Case</strong></p>
<pre><code class="javascript">[1,2,3,4,5][0..toString.length];    // 2
&#39;foo&#39;.split(&#39;&#39;) + [];    //&quot;f,o,o&quot;
</code></pre>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3529249.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——逗号、冒号与括号</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[表达式与运算符]]></title>
      <url>/2017/02/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/javascript/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<p>这篇文章整理一些表达式和运算符的点和坑。</p>
<a id="more"></a>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="表达式形式"><a href="#表达式形式" class="headerlink" title="表达式形式"></a>表达式形式</h3><ol>
<li><p>原始表达式</p>
<blockquote>
<p>常量、变量、保留字</p>
</blockquote>
</li>
<li><p>对象、数组初始化表达式</p>
<blockquote>
<p>var obj={a:1,b:2};<br>var a=[1,2,3];</p>
</blockquote>
</li>
<li><p>函数定义表达式</p>
<blockquote>
<p>var fn=function(){}</p>
</blockquote>
</li>
<li><p>属性访问表达式</p>
<blockquote>
<p>Math.abs</p>
</blockquote>
</li>
<li><p>调用表达式</p>
<blockquote>
<p>alert(‘hello’);</p>
</blockquote>
</li>
<li><p>对象创建表达式</p>
<blockquote>
<p>new object();</p>
</blockquote>
</li>
</ol>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p><strong>Case</strong></p>
<pre><code class="javascript">var f = function g(){ console.log(g);};
f();//function g(){ console.log(g);};
typeof g();//g is not defined
</code></pre>
<p>当我们使用函数声明的方式定义一个函数的时候，实际上声明了一个变量，在上面例子中就是f，并把函数赋值给这个变量，<strong>普通的函数表达式没有创建该变量，也就是我们所说的创建了一个匿名函数，但是如果函数表达式包含名称，也就是上面例子的g，那么函数的局部作用域将包含将包含该名称，并且把创建的函数绑定到该名称上</strong>，在上面例子中g变成了函数的局部变量，变量指向函数本身，所以我们调用f的时候会把其本身打印出来。但是g只作为函数的局部变量存在，我们在外部调用g的时候就会报错了。</p>
<blockquote>
<p>命名函数表达式在创建的时候，会在当前作用域最前段添加一个新的对象{func_name:refer_function_expression},然后，将作用域链添加到<br>函数表达式的[[scope]]中，接着在删除该对象。</p>
</blockquote>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><pre><code class="javascript">(function(){})();
</code></pre>
<blockquote>
<p>(函数定义表达式)函数调用表达式</p>
</blockquote>
<p>当函数执行有命名冲突的时候，函数依次填入 变量＝》函数＝》参数，所以最后被填入的参数f会覆盖函数定义f</p>
<h3 id="表达式返回值"><a href="#表达式返回值" class="headerlink" title="表达式返回值"></a>表达式返回值</h3><h4 id="函数定义表达式"><a href="#函数定义表达式" class="headerlink" title="函数定义表达式"></a>函数定义表达式</h4><p><strong>函数定义表达式</strong>返回的是函数对象本身，我们在调用alert或者console.log的时候会调用其toString方法</p>
<pre><code class="javascript">console.log(function(){alert(&#39;a&#39;);}) //function (){alert(&#39;a&#39;);}
</code></pre>
<h4 id="函数调用表达式"><a href="#函数调用表达式" class="headerlink" title="函数调用表达式"></a>函数调用表达式</h4><p><strong>函数调用表达式</strong>自然是返回函数的return结果，但在JavaScript中并不是所有的函数都有return语句，对于没有return语句的function，其调用表达式返回undefined，对于只写个return的坑爹做法同样也是返回undefined</p>
<pre><code class="javascript">(function(){})(); //undefined
(function(){return;})();//undefined
</code></pre>
<h4 id="对象创建表达式"><a href="#对象创建表达式" class="headerlink" title="对象创建表达式"></a>对象创建表达式</h4><p><strong>对象创建表达式</strong>本来也应该很简单，返回new的对象就可以了</p>
<pre><code class="javascript">typeof new Date(); //&quot;object&quot;
</code></pre>
<p><strong>Case</strong></p>
<pre><code class="javascript">function Test(){
    return new Date();
}
var test=new Test();
console.log(test instanceof Test);//false
console.log(test);//Sat Jan 18 2014 14:57:08 GMT+0800 (CST)
</code></pre>
<pre><code class="javascript">function Test(){
    return new Date();
}
function Test2(){
    return 2;
}
typeof new Test();
new Test2() instanceof Test2;//true，竟然是true
</code></pre>
<p><strong>当使用function的构造函数创建对象（new XXX）的时候，如果函数return基本类型或者没有return（其实就是return undefined）的时候， new 返回的是对象的实例；如果函数return的是一个对象，那么new 将返回这个对象而不是函数实例</strong>。</p>
<p>这里千万别把构造函数（使用new）和普通函数调用混淆了，普通函数调用还是该返回什么返回什么的。见Case1。</p>
<pre><code class="javascript">&#39;foo&#39; == new function(){ return String(&#39;foo&#39;); }; //false,后者为{}
&#39;foo&#39; == new function(){ return new String(&#39;foo&#39;); };//true
</code></pre>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="运算符优先级与结合性"><a href="#运算符优先级与结合性" class="headerlink" title="运算符优先级与结合性"></a>运算符优先级与结合性</h3><p>运算符的优先级《JavaScript权威指南》中有个表阐述的很好（我去掉了位运算部分），其中R/L代表结合性是右结合还是左结合，num-&gt;num表示操作符期望的数据类型和计算结果类型，lval指左值</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>结合性</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>++</td>
<td>自增</td>
<td>R</td>
<td>lval-&gt;num</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>R</td>
<td>lval-&gt;num</td>
</tr>
<tr>
<td>-</td>
<td>求反</td>
<td>R</td>
<td>num-&gt;num</td>
</tr>
<tr>
<td>+（一个操作数）</td>
<td>转换为数字</td>
<td>R</td>
<td>num-&gt;num</td>
</tr>
<tr>
<td>~</td>
<td>按位求反</td>
<td>R</td>
<td>int-&gt;int</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>R</td>
<td>bool-&gt;bool</td>
</tr>
<tr>
<td>delete</td>
<td>删除属性</td>
<td>R</td>
<td>lval-&gt;bool</td>
</tr>
<tr>
<td>typeof</td>
<td>检测数据类型</td>
<td>R</td>
<td>any-&gt;str</td>
</tr>
<tr>
<td>void</td>
<td>返回undefined</td>
<td>R</td>
<td>any-&gt;undefined</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*、/、%</td>
<td>乘、除、求余</td>
<td>L</td>
<td>num,num-&gt;num</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+、-</td>
<td>加、减</td>
<td>L</td>
<td>num,num-&gt;num</td>
</tr>
<tr>
<td>+</td>
<td>字符串拼接</td>
<td>L</td>
<td>str,str-&gt;str</td>
</tr>
<tr>
<td>&lt;、&lt;=、&gt;、&gt;=</td>
<td>数字大小或字母表顺序</td>
<td>L</td>
<td>num/str,num/str-&gt;bool</td>
</tr>
<tr>
<td>instanceof</td>
<td>对象类型</td>
<td>L</td>
<td>obj,function-&gt;bool</td>
</tr>
<tr>
<td>in</td>
<td>测试属性是否存在</td>
<td>L</td>
<td>str,obj-&gt;bool</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>==</td>
<td>判断相等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>！=</td>
<td>判断不等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>===</td>
<td>判断恒等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td>!==</td>
<td>判断非恒等</td>
<td>L</td>
<td>any,any-&gt;bool</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>逻辑或</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
<tr>
<td>?:</td>
<td>条件运算符</td>
<td>R</td>
<td>bool,any,any-&gt;any</td>
</tr>
<tr>
<td>=赋值 *=、/=、+=、-=</td>
<td>赋值 运算且赋值</td>
<td>R</td>
<td>lval,any-&gt;any</td>
</tr>
<tr>
<td>,</td>
<td>忽略第一个操作数，返回第二个操作数</td>
<td>L</td>
<td>any,any-&gt;any</td>
</tr>
</tbody>
</table>
<p>有几个我们需要注意的地方</p>
<ul>
<li>typeof的优先级相当的高，比加减乘除神马的都高，所以虽然是操作符，在在复杂表达式的时候我们还是习惯家括号，看个例子</li>
</ul>
<pre><code class="javascript">  typeof 2*3;//NaN
  typeof (2*3);//&quot;number&quot;
  typeof 2+3;// &quot;number3&quot;
</code></pre>
<ul>
<li>++、–是右结合的操作符（优先级最高的几个都是右结合），而且比加减乘除优先级高。同时自增、自减运算符的运算数得是左值（可以放在赋值符号左边的值），而不能是常数</li>
</ul>
<pre><code class="javascript">  var a=0,b=0;
  a+++b;//0
  a;//1，++优先级比+高，所以相当于(a++)+b
  b;//0
</code></pre>
<ul>
<li><p>赋值运算符的优先级相当的低</p>
</li>
<li><p>逻辑非!也在优先级队列的前端，比加减乘除高，但逻辑与、逻辑或优先级很低，不如加减乘除</p>
</li>
</ul>
<h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>在JavaScript中严格按照从左到右的顺序计算表达式，然后再按照优先级和结合性计算各个表达式和运算符作用结果。</p>
<h3 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h3><p>“===”是严格意义的相等，只需注意NaN和NaN不等就行了。</p>
<p>使用”==”的时候会在哪些情况下做类型转换，又会换成什么样子？</p>
<ol>
<li>如果两个值类型相同，则执行严格相等的运算</li>
<li>如果两个值的类型不同<ul>
<li>如果一个是null，一个是undefined，那么相等</li>
<li>如果一个是数字，一个是字符串，先将字符串转为数字，然后比较</li>
<li>如果一个值是true/false则将其转为1/0比较</li>
<li>如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较</li>
<li>其它就不相等了</li>
</ul>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="Case1-function与new-function"><a href="#Case1-function与new-function" class="headerlink" title="Case1.function与new function"></a>Case1.function与new function</h2><p>只要new 表达式之后的constructor返回一个引用对象（数组，对象，函数等），都将覆盖new创建的匿名对象。如果返回一个原始类型，那么就返回一个new创建的匿名对象。</p>
<pre><code class="javascript">var result=new function(){return &quot;圆心&quot;};
alert(result);//[object object]
</code></pre>
<p>此时等于：</p>
<pre><code class="javascript">function 匿名类(){
  return &quot;圆心&quot;;
}
var result= new 匿名类(); 
alert(result);  //此时为对象
</code></pre>
<p>如果改成</p>
<pre><code class="javascript">var result=new function(){return new String(&quot;圆心&quot;)};
alert(result);//圆心
</code></pre>
<p>返回一个对象，覆盖了new创建的匿名函数对象。</p>
<p>由于 new String 会构造一个对象，而不是一个 string 直接量，且new String(x) 如果带参数，那么alert它的时候就会返回 x。所以 result将返回 new String(”圆心”) 这个对象，而 alert result则显示 “圆心”。</p>
<pre><code class="javascript">//A
var result=function(){return&quot;圆心&quot;}();
alert(result());  //圆心
//B
var result=function(){return&quot;圆心&quot;};
alert(result);// function(){return&quot;圆心&quot;};
alert(result());  //圆心
</code></pre>
<p>A等于</p>
<pre><code class="javascript">var 匿名函数=function(){return&quot;圆心&quot;};
result=匿名函数();//返回匿名函数的执行结果
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://www.cnblogs.com/dolphinX/p/3524977.html" target="_blank" rel="external">JavaScript面试时候的坑洼沟洄——表达式与运算符</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML基础]]></title>
      <url>/2017/01/26/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>HTML的一些基础概念理解。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="对Web标准的理解"><a href="#对Web标准的理解" class="headerlink" title="对Web标准的理解"></a>对Web标准的理解</h2><p>1.html：</p>
<ul>
<li>标签字母要小写</li>
<li>标签要闭合</li>
<li>标签不允许随意嵌套</li>
</ul>
<p>2.css和js:</p>
<ul>
<li>尽量使用外链css样式表和js脚本。</li>
<li>样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快。</li>
<li>不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</li>
</ul>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h3 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h3><p>渲染引擎 + JS引擎</p>
<h3 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h3><ul>
<li>Trident内核：IE，360，搜狗浏览器；</li>
<li>Gecko内核：Netscape6及以上版本，Mozilla FireFox(火狐浏览器)</li>
<li>Presto内核：Opera</li>
<li>Blink内核：Opera；</li>
<li>Webkit内核：Safari，Chrome</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><strong>Trident内核</strong>：和W3C标准脱节，大量Bug等安全问题</li>
<li><strong>Presto内核</strong>：速度最快，缺点是兼容性。</li>
<li><strong>Gecko内核</strong>：功能强大，消耗很多的资源。</li>
<li><strong>Webkit内核</strong>：速度较快，兼容性较低</li>
</ul>
<h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><h3 id="为什么要语义化"><a href="#为什么要语义化" class="headerlink" title="为什么要语义化"></a>为什么要语义化</h3><ul>
<li>有利于seo</li>
<li>方便其他设备监听 屏幕阅读设备 盲人阅读器</li>
<li>方便团队协作开发</li>
</ul>
<h3 id="语义化元素"><a href="#语义化元素" class="headerlink" title="语义化元素"></a>语义化元素</h3><ul>
<li>header, footer, hgroup, nav, article, section</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h2><h3 id="Doctype作用？"><a href="#Doctype作用？" class="headerlink" title="Doctype作用？"></a>Doctype作用？</h3><p>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>
<h3 id="标准模式与兼容模式各有什么区别"><a href="#标准模式与兼容模式各有什么区别" class="headerlink" title="标准模式与兼容模式各有什么区别?"></a>标准模式与兼容模式各有什么区别?</h3><p>标准模式的排版和JS运作模式是以浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容方式显示。</p>
<h3 id="HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-？"><a href="#HTML5为什么只需要写-lt-DOCTYPE-HTML-gt-？" class="headerlink" title="HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;？"></a>HTML5为什么只需要写&lt;!DOCTYPE HTML&gt;？</h3><p>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为；</p>
<p>而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><h3 id="html加载顺序"><a href="#html加载顺序" class="headerlink" title="html加载顺序"></a>html加载顺序</h3><p>正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载HTML网页，一边开始解析</li>
<li>解析过程中，发现<code>&lt;script&gt;</code>标签</li>
<li>暂停解析，网页渲染的控制权转交给JavaScript引擎</li>
<li>如果<code>&lt;script&gt;</code>标签引用了外部脚本，就下载该脚本，否则就直接执行</li>
<li>执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</li>
</ol>
<h3 id="js放在网页尾部加载"><a href="#js放在网页尾部加载" class="headerlink" title="js放在网页尾部加载"></a>js放在网页尾部加载</h3><ul>
<li>js放在head中会立即执行，阻塞后续的资源下载与执行。</li>
<li>因为js有可能会修改dom，如果不阻塞后续的资源下载，dom的操作顺序不可控。在DOM结构生成之前就调用DOM，JavaScript会报错</li>
</ul>
<h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><p>1.css需要分块，首页的css独立，其余的css需要动态加载，因为html的绘制会被css阻塞，这样可以减少首次进入时的白屏时间。</p>
<blockquote>
<p>js的执行依赖前面的样式。即只有前面的样式全部下载完成后才会执行js，但是此时外链css和外链js是并行下载的。</p>
</blockquote>
<p>2.defer=”true”属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。</p>
<blockquote>
<p>对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，<code>defer</code>属性不起作用。</p>
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h3><blockquote>
<p><code>DOCTYPE html</code></p>
</blockquote>
<p>IE6+兼容，都是标准模式，IE6-是怪异模式</p>
<h3 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h3><blockquote>
<p><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</code></p>
</blockquote>
<p>xmlns是XHTML namespace的缩写。</p>
<p>作用：xml采用名字空间声明，通过网址来识别标记。</p>
<p>XHTML是HTML先xml过度的标记语言，它需要符合xml文档规则，因此，也需要定义名字空间，又因为XHTML1.0不能自定义标识，所以，它的名字空间都相同</p>
<h3 id="webkit"><a href="#webkit" class="headerlink" title="webkit"></a>webkit</h3><blockquote>
<p><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code></p>
</blockquote>
<p>对于双核浏览器，如果用户手动调节成兼容模式，那么无法切换为极速模式</p>
<h3 id="X-UA-Compatible"><a href="#X-UA-Compatible" class="headerlink" title="X-UA-Compatible"></a>X-UA-Compatible</h3><blockquote>
<p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;</code></p>
</blockquote>
<p>IE8的专用标记，指定IE8去模拟某个版本IE浏览器的渲染方式(比如IE6)，以此来解决部分兼容问题</p>
<p>谷歌做了个外挂：Google Chrome Frame(谷歌内嵌浏览器框架GCF)。这个插件可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器。</p>
<p>这样写可以达到的效果是如果安装了GCF，则使用GCF来渲染页面，如果为安装GCF，则使用最高版本的IE内核进行渲染。</p>
<h3 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h3><blockquote>
<p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;...&quot; type=&quot;image/x-icon&quot; /&gt;</code></p>
</blockquote>
<p>固定写法，定义网站图标</p>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> HTML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS]]></title>
      <url>/2017/01/02/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/css/CSS/</url>
      <content type="html"><![CDATA[<p>整理CSS知识点。</p>
<a id="more"></a>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="流动布局"><a href="#流动布局" class="headerlink" title="流动布局"></a>流动布局</h3><p>需了解实现块居中常见的几种方式</p>
<h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><ul>
<li>仍处于标准文档流中。</li>
<li>没设置宽度值，设置了浮动属性，元素的宽度随内容的变化而变化。</li>
<li>设置为浮动属性，会对紧邻之后的元素造成影响，紧邻之后的元素会紧挨着该元素显示。</li>
<li>当父元素包含块缩成一条时，用clear:both方法无效，它一般用于紧邻后面的元素的清除浮动，要用overflow属性。</li>
<li>清除浮动的方法有两种:<ul>
<li>使用clear属性 - clear: both; 这种方法需要在浮动元素后面添加一个空的节点。兼容IE6需要添加zoom:1;</li>
<li>同时设置width:100%(或固定宽度) + overflow:hidden。浮动元素得有一个父元素。</li>
<li>使用after伪类，这种方式公认最好</li>
</ul>
</li>
<li>浮动布局可实现横向多列布局；文字环绕效果。</li>
</ul>
<h3 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>static是默认值</li>
<li>它表示块保留在原本应该在的位置，不会重新定位</li>
</ul>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><ul>
<li>相对于自身原有位置进行偏移</li>
<li>仍处于标准文档流中</li>
<li>随即拥有偏移属性和z-index属性</li>
</ul>
<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><ul>
<li>一个固定定位（position属性的值为fixed）元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。</li>
<li>一个固定定位元素不会保留它原本在页面应有的空隙。</li>
</ul>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><ul>
<li>相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 并且它会随着页面滚动而移动。</li>
<li>完全脱离了标准文档流。</li>
<li>随即拥有偏移属性和z-index属性。</li>
</ul>
<h3 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h3><p>Flexbox又叫弹性盒模型。它可以简单使用一个元素居中（包括水平垂直居中），可以让扩大和收缩元素来填充容器的可利用空间，可以改变源码顺序独立布局，以及还有其他的一些功能。合理使用它能够大大减少布局方面的工作。此外在移动端使用flex也比较常见。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li>display:flex;</li>
<li>justify-content (水平对齐方式)</li>
<li>align-items (垂直对齐方式)</li>
</ul>
<p>使用请参考:</p>
<ul>
<li><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">CSS flex完全指南</a></li>
<li><a href="http://gold.xitu.io/entry/57675f8f80dda4005f9bbe0c" target="_blank" rel="external">flex历险记</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></li>
<li><a href="http://www.cnblogs.com/lixuemin/p/6110434.html" target="_blank" rel="external">3分钟看懂flex布局</a></li>
</ul>
<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>响应式布局是指，网页可以自动识别设备屏幕宽度，根据不同的宽度采用不同的CSS的样式，从而达到兼容各种设备的效果。</p>
<p>响应式布局使用媒体查询(CSS3 Media Queries), 根据不同屏幕分辨率采用不同CSS规则, 使用方式如下:</p>
<pre><code class="css">@media screen and (max-width:1024px) {
  /* 视窗宽度小于1024px时 */
  ....
}
</code></pre>
<h4 id="Bootstrap-grid系统的实现"><a href="#Bootstrap-grid系统的实现" class="headerlink" title="Bootstrap grid系统的实现"></a>Bootstrap grid系统的实现</h4><p>它提供了一套响应式，移动优先的流式栅格系统(grid system)，将屏幕分成12列来实现响应式的。它的实现原理非常简单，Media Query加上float布局，如果想了解实现细节，请参考我另外一篇博客<a href="https://segmentfault.com/a/1190000005771076" target="_blank" rel="external">Boostrap网格系统</a>。</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>每一个盒子有四条边界：外边距边界margin, 边框边界border, 内边距边界padding与内容边界content。</p>
<p><strong>IE盒模型和W3C盒模型区别</strong>：</p>
<ul>
<li>在W3C模型中: 总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</li>
<li>在IE模型中: 总宽度 = margin-left + width + margin-right</li>
</ul>
<p>在CSS3中引入了<strong>box-sizing属性</strong>, 它可以允许改变默认的CSS盒模型对元素宽高的计算方式.共包括两个选项：</p>
<ul>
<li><strong>content-box：标准盒模型，CSS定义的宽高只包含content的宽高</strong></li>
<li><strong>border-box：IE盒模型，CSS定义的宽高包括了content，padding和border</strong></li>
</ul>
<h2 id="定位机制"><a href="#定位机制" class="headerlink" title="定位机制"></a>定位机制</h2><p>css有三种基本定位机制: 标准文档流, 浮动和绝对定位。</p>
<h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><ul>
<li>从左到右，从上向下，输出文档内容</li>
<li>由块级元素和行级元素组成</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul>
<li>行内元素不能设置宽高，默认没高度和宽度，宽度由其内容决定。</li>
<li>行内元素虽然不能设置宽高，但是设置成绝对定位后，可以设置宽高。</li>
<li>行内元素：<code>a font(em strong i) img span</code></li>
</ul>
<h4 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h4><ul>
<li>块元素默认没高度，可以设置宽高，默认占据一行。</li>
<li><strong>一行只有一个块元素</strong></li>
<li><strong>空的块元素将在布局中消失</strong></li>
<li>块元素：<code>div p ul li table form html5(header section footer)</code></li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><ul>
<li>设置为浮动的元素将会往左(float:left)或者往右(float:right)漂移, 直到遇到阻挡 - 其他浮动元素或者父元素的边框。浮动元素不在标准文档流中占据空间,但会对其后的浮动元素造成影响。</li>
</ul>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul>
<li>设置为绝对定位的元素(posistion:absolute)将从标准文档流中删除，其所占据的标准流空间也不存在。然后通过top,left,right,bottom属性对其相对父元素进行定位。</li>
</ul>
<h2 id="选择器优先级及使用"><a href="#选择器优先级及使用" class="headerlink" title="选择器优先级及使用"></a>选择器优先级及使用</h2><h3 id="css选择器分类"><a href="#css选择器分类" class="headerlink" title="css选择器分类　"></a>css选择器分类　</h3><ol>
<li>标签选择器(如：body,div,p,ul,li)</li>
<li>类选择器(如：class=”head”,class=”head_logo”)</li>
<li>ID选择器(如：id=”name”,id=”name_txt”)</li>
<li>全局选择器(如：*号)</li>
<li>组合选择器(如：.head .head_logo,注意两选择器用空格键分开)</li>
<li>后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)</li>
<li>群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示</li>
<li>继承选择器(如：div p,注意两选择器用空格键分开)</li>
<li>伪类选择器(如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。)</li>
<li>字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)</li>
<li>子选择器 (如：div&gt;p ,带大于号&gt;)</li>
<li>CSS 相邻兄弟选择器器 (如：h1+p,带加号+)</li>
</ol>
<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><h4 id="不同级别"><a href="#不同级别" class="headerlink" title="不同级别"></a>不同级别</h4><ol>
<li>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</li>
<li>作为style属性写在元素内的样式</li>
<li>id选择器</li>
<li>类选择器</li>
<li>标签选择器</li>
<li>通配符选择器</li>
<li>浏览器自定义或继承</li>
</ol>
<p>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</p>
<h4 id="同一级别"><a href="#同一级别" class="headerlink" title="同一级别"></a>同一级别</h4><p>同一级别中后写的会覆盖先写的样式</p>
<h4 id="多个级别"><a href="#多个级别" class="headerlink" title="多个级别"></a>多个级别</h4><p>计算方法（权值实际并不是按十进制，用数字表示只是说明思想，一万个class也不如一个id权值高）</p>
<ul>
<li>内联样式表的权值为 1000</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1</li>
</ul>
<p>css选择器使用强烈建议采用低权重原则，利于充分发挥css的继承性，复用性，模块化、组件化。</p>
<h3 id="CSS选择器的解析原则"><a href="#CSS选择器的解析原则" class="headerlink" title="CSS选择器的解析原则"></a>CSS选择器的解析原则</h3><p>郑重的声明选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。<a href="http://blog.csdn.net/jinboker/article/details/52126021" target="_blank" rel="external">为什么CSS选择器是从右往左解析 ？？？</a></p>
<p>简要概括：</p>
<ul>
<li>遍历节点树小很多</li>
<li>匹配的是dom元素的父节点，避免HTML、CSS没下载完需要等待</li>
</ul>
<h2 id="CSS3新特性及应用"><a href="#CSS3新特性及应用" class="headerlink" title="CSS3新特性及应用"></a>CSS3新特性及应用</h2><h3 id="新的元素选择器"><a href="#新的元素选择器" class="headerlink" title="新的元素选择器"></a>新的元素选择器</h3><p>E:nth-last-child(n), E:nth-of-type(n), E:nth-last-of-type(n), E:last-child, E:first-of-type, E:only-child, E:only-of-type, E:empty, E:checked, E:enabled, E:disabled, E::selection, E:not(s)</p>
<h3 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h3><p>confont是指使用字体文件取代图片文件，来展示图标和一些特殊字体等元素。它使用CSS3中的@font-face属性，它允许加载自定义字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。</p>
<p>它有很多优势: 首先它的体积要比图片小得多; 特定的属性(颜色,大小,透明)等修改起来就像是操作字体一样简单;iconfont具有矢量性, 放大缩小不会失真;</p>
<h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p>又称圆角属性，通常使用该属性将图片圆角化，如头像。</p>
<pre><code class="css">border-radius: 50%;
</code></pre>
<p>border-radius另外一个常用的手段是CSS动画。</p>
<h3 id="word-wrap-amp-text-overflow"><a href="#word-wrap-amp-text-overflow" class="headerlink" title="word-wrap &amp; text-overflow"></a>word-wrap &amp; text-overflow</h3><p>word-wrap属性用来指出浏览器在单词内进行断句，防止字符串太长而找不到它的自然断句点时产生的溢出。</p>
<pre><code class="css">word-wrap: break-word;
</code></pre>
<p>text-overflow用于文本溢出:</p>
<pre><code class="css">text-overflow: ellipsis; //对溢出部分加上...
</code></pre>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a>background</h3><p>主要是以下三个属性:</p>
<ul>
<li>background-clip 规定背景的绘制区域, 取值为border-box | padding-box | content-box | no-clip</li>
<li>background-origin 规定背景的定位区域, 取值为border | padding | content</li>
<li>background-size 规定背景图片的尺寸, 取值为[<length> | <percentage> | auto]{1,2} | cotain</percentage></length></li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="通用浏览器"><a href="#通用浏览器" class="headerlink" title="通用浏览器"></a>通用浏览器</h3><h4 id="不同浏览器的标签默认的外补丁和内补丁不同"><a href="#不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="不同浏览器的标签默认的外补丁和内补丁不同"></a>不同浏览器的标签默认的外补丁和内补丁不同</h4><p><strong>问题症状</strong>：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</p>
<p><strong>解决方案</strong>：CSS里加 <em>{margin:0;padding:0;},<em>*但不推荐，而且它也并不完善。</em></em></p>
<p>淘宝的样式初始化：</p>
<pre><code class="css">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; }
    body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
    h1, h2, h3, h4, h5, h6{ font-size:100%; }
    address, cite, dfn, em, var { font-style:normal; }
    code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
    small{ font-size:12px; }
    ul, ol { list-style:none; }
    a { text-decoration:none; }
    a:hover { text-decoration:underline; }
    sup { vertical-align:text-top; }
    sub{ vertical-align:text-bottom; }
    legend { color:#000; }
    fieldset, img { border:0; }
    button, input, select, textarea { font-size:100%; }
    table { border-collapse:collapse; border-spacing:0; }
</code></pre>
<h4 id="上下margin重合问题"><a href="#上下margin重合问题" class="headerlink" title="上下margin重合问题"></a>上下margin重合问题</h4><p><strong>问题症状</strong>：相邻的两个div margin-left margin-right 不会重合，但相邻的margin-top margin-bottom会重合。有两种情况：</p>
<ol>
<li>兄弟级的块之间，margin这个属性上下边距，经常会发生重叠的情况，以数值大的为准，而不会相加。</li>
<li>父子级的块之间，子级的上下margin会与父级上下margin重叠，以数值大的为准，而不会相加。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>第一种情况：</p>
<ol>
<li>float浮动</li>
<li>inline-block</li>
</ol>
<p>第二种情况：</p>
<ol>
<li>父级加overflow:hidden</li>
</ol>
<ol>
<li>父级加加padding </li>
<li>父级加加border </li>
<li>子级加position:absolute</li>
</ol>
<h4 id="img默认有间距"><a href="#img默认有间距" class="headerlink" title="img默认有间距"></a>img默认有间距</h4><p><strong>问题症状</strong>：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p>
<p><strong>解决方案</strong>：使用float属性为img布局</p>
<p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。</p>
<h4 id="标签最低高度设置min-height不兼容"><a href="#标签最低高度设置min-height不兼容" class="headerlink" title="标签最低高度设置min-height不兼容"></a>标签最低高度设置min-height不兼容</h4><p><strong>问题症状</strong>：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p>
<p><strong>解决方案</strong>：如果我们要设置一个标签的最小高度200px，需要进行的设置为：</p>
<pre><code class="css">.box{min-height:200px; height:auto !important; height:200px; overflow:visible;}
</code></pre>
<p>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p>
<h4 id="超链接访问过后样式就混乱了，hover样式不出现"><a href="#超链接访问过后样式就混乱了，hover样式不出现" class="headerlink" title="超链接访问过后样式就混乱了，hover样式不出现"></a>超链接访问过后样式就混乱了，hover样式不出现</h4><p><strong>问题症状</strong>：主要是其CSS属性的排序问题。</p>
<p><strong>解决方案</strong>：一般来说，最好按照这个顺序：L-V-H-A</p>
<pre><code class="css">a:link{}  a:visited{}  a:hover{}  a:active{}
</code></pre>
<h4 id="chrome默认会将小于12px的文本强制按照12px来解析"><a href="#chrome默认会将小于12px的文本强制按照12px来解析" class="headerlink" title="chrome默认会将小于12px的文本强制按照12px来解析"></a>chrome默认会将小于12px的文本强制按照12px来解析</h4><p><strong>解决方案</strong>：给其添加属性：</p>
<pre><code class="css">-webkit-text-size-adjust: none;
</code></pre>
<h4 id="鼠标的手势问题"><a href="#鼠标的手势问题" class="headerlink" title="鼠标的手势问题"></a>鼠标的手势问题</h4><p><strong>问题症状</strong>：FireFox的cursor属性不支持hand，但是支持pointer，IE两个都支持；</p>
<p><strong>解决方案</strong>：为了兼容都用pointer</p>
<h4 id="消除ul、ol等列表的缩进"><a href="#消除ul、ol等列表的缩进" class="headerlink" title="消除ul、ol等列表的缩进"></a>消除ul、ol等列表的缩进</h4><p><strong>解决方案</strong>：样式应写成:</p>
<pre><code class="css">list-style:none;margin:0px;padding:0px;
</code></pre>
<p>其中margin属性对IE有效，padding属性对FireFox有效</p>
<h4 id="透明度问题"><a href="#透明度问题" class="headerlink" title="透明度问题"></a>透明度问题</h4><p><strong>解决方案</strong>：</p>
<pre><code class="css">opacity: 0.6 ;     //一般 
filter: alpha(opacity=60)    //IE
filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60);        //IE6
</code></pre>
<h3 id="IE6常见BUG"><a href="#IE6常见BUG" class="headerlink" title="IE6常见BUG"></a>IE6常见BUG</h3><h4 id="IE6双倍边距bug-1"><a href="#IE6双倍边距bug-1" class="headerlink" title="IE6双倍边距bug(1)"></a>IE6双倍边距bug(1)</h4><p><strong>问题症状</strong>：块属性标签添加了浮动float之后，若在浮动方向上也有margin值，则margin值会加倍。其实这种问题主要就是会把某些元素挤到了第二行</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>给float元素添加display：inline</li>
<li>就是hack处理了，对IE6进行 _margin-left:5px;(原先为10px)</li>
</ul>
<h4 id="IE6双倍边距bug-2"><a href="#IE6双倍边距bug-2" class="headerlink" title="IE6双倍边距bug(2)"></a>IE6双倍边距bug(2)</h4><p><strong>问题症状</strong>：行内属性标签，为了设置宽高，我们经常就会设置成display：block; 后采用float布局，又有横行的margin的情况这样一来就产生上述的问题。</p>
<p><strong>解决方案</strong>：在display:block;后面加入display:inline;display:table;</p>
<h4 id="IE6中3像素问题"><a href="#IE6中3像素问题" class="headerlink" title="IE6中3像素问题"></a>IE6中3像素问题</h4><p><strong>问题症状</strong>：当元素使用float浮动后，元素与相邻的元素之间会产生3px的间隙。诡异的是如果右侧的容器没设置高度时3px的间隙在相邻容器的内部，当设定高度后又跑到容器的相反侧了。</p>
<p><strong>解决方案</strong>：需要使布局在同一行的元素都加上float浮动。</p>
<h4 id="IE6中奇数宽高的BUG"><a href="#IE6中奇数宽高的BUG" class="headerlink" title="IE6中奇数宽高的BUG"></a>IE6中奇数宽高的BUG</h4><p><strong>问题症状</strong>：IE6中奇数的高宽显示大小与偶数高宽显示大小存在一定的不同。其中要问题是出在奇数高宽上。</p>
<p><strong>解决方案</strong>：需要尽量将外部定位的div高宽写成偶数即可。</p>
<h4 id="IE6和FF中图片链接的下方有间隙"><a href="#IE6和FF中图片链接的下方有间隙" class="headerlink" title="IE6和FF中图片链接的下方有间隙"></a>IE6和FF中图片链接的下方有间隙</h4><p><strong>问题症状</strong>：IE6中图片的下方会存在一定的间隙，尤其在图片垂直挨着图片的时候，即可看到这样的间隙。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>需要将img标签定义为display:block </li>
<li>定义vertical-align对应的属性。</li>
<li>为img对应的样式写入font-size:0</li>
</ol>
<h4 id="IE6下空元素的高度BUG"><a href="#IE6下空元素的高度BUG" class="headerlink" title="IE6下空元素的高度BUG"></a>IE6下空元素的高度BUG</h4><p><strong>问题症状</strong>：如果一个元素中没有任何内容，当在样式中为这个元素设置了0-19px之间的高度时。此元素的高度始终为19px。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>在元素的css中加入：overflow:hidden</li>
<li>在元素中插入html注释：&lt;!– &gt;</li>
<li>在元素中插入html的空白符：&nbsp;</li>
<li>在元素的css中加入：font-size:0</li>
</ol>
<h4 id="重复文字的BUG"><a href="#重复文字的BUG" class="headerlink" title="重复文字的BUG"></a>重复文字的BUG</h4><p><strong>问题症状</strong>：在某些比较复杂的排版中，有时候浮动元素的最后一些字符会出现在clear清除元素的下面。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>确保元素都带有display:inline</li>
<li>在最后一个元素上使用“margin-right:-3px</li>
<li>为浮动元素的最后一个条目加上条件注释，&lt;!–[if !IE]&gt;xxx&lt;![endif]–&gt;</li>
<li>在容器的最后元素使用一个空白的div，为这个div指定不超过容器的宽度。</li>
</ol>
<h4 id="IE6中-z-index失效"><a href="#IE6中-z-index失效" class="headerlink" title="IE6中 z-index失效"></a>IE6中 z-index失效</h4><p><strong>问题症状</strong>：具体BUG为，元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的BUG</p>
<p>原因：z-index起作用有个小小前提，就是元素的position属性要 是relative，absolute或是fixed。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li>position:relative改为position:absolute；</li>
<li>去除浮动；</li>
<li>浮动元素添加position属性（如relative，absolute等）。</li>
</ol>
<p><strong>IE6结语：实际上中，很多BUG的解决方法都可以使用display:inline、font-size:0、float解决。因此我们在书写代码时要记住，一旦使用了float浮动，就为元素增加一个display:inline样式，可以有效的避免浮动造成的样式错乱问题。使用空DIV时，为了避免其高度影响布局美观，也可以为其加上font-size:0 这样就很容易避免一些兼容上的问题。</strong></p>
<h4 id="png24位的图片在IE6下面会出现背景"><a href="#png24位的图片在IE6下面会出现背景" class="headerlink" title="png24位的图片在IE6下面会出现背景"></a>png24位的图片在IE6下面会出现背景</h4><p><strong>解决方案</strong>：使用png8格式的</p>
<h4 id="IE6下在使用margin-0-auto-无法使其居中"><a href="#IE6下在使用margin-0-auto-无法使其居中" class="headerlink" title="IE6下在使用margin:0 auto;无法使其居中"></a>IE6下在使用margin:0 auto;无法使其居中</h4><p><strong>解决方案</strong>：为其父容器设置<code>text-align:center;</code></p>
<h4 id="IE6-7标签高度无法小于10px"><a href="#IE6-7标签高度无法小于10px" class="headerlink" title="IE6/7标签高度无法小于10px"></a>IE6/7标签高度无法小于10px</h4><p><strong>问题症状</strong>：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>给超出高度的标签设置overflow:hidden;</li>
<li>或者设置行高line-height 小于你设置的高度</li>
<li>或设置fontsize大小为高度大小</li>
</ul>
<p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>
<h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>我们为了让页面形成统一的效果，要针对不同的浏览器或不同版本写出对应可解析的CSS样式，所以我们就把这个针对不同浏览器/版本而写CSS的过程叫做 CSS hack.</p>
<p>CSS hack主要有三种：IE条件注释法、CSS属性前缀法、选择器前缀法。</p>
<h3 id="IE条件注释法"><a href="#IE条件注释法" class="headerlink" title="IE条件注释法"></a>IE条件注释法</h3><p>在正常代码之外添加判别IE浏览器或对应版本的条件注释，符合条件的浏览器或者版本号才回执行里边的代码。</p>
<pre><code class="html">&lt;!-- [if IE]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;

&lt;!-- [if lt IE 8]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;

&lt;!-- [if ! IE 8]&gt;
   你想要执行的代码 
&lt;![endif]--&gt;
</code></pre>
<h3 id="CSS属性前缀法"><a href="#CSS属性前缀法" class="headerlink" title="CSS属性前缀法"></a>CSS属性前缀法</h3><p>给css的属性添加前缀。比如 * 可以被IE6/IE7识别，但 <em> 只能被IE6识别，IE6-IE10都可以识别 “\9”，IE6不能识别!important ,FireFox不能识别 * </em>  \9</p>
<pre><code class="css">//可以先使用“\9&quot;标记，将IE分离出来，再用”*&quot;分离出IE6/IE7，最后可以用“_”分离出IE6
.type{
        color: #111; /* all */
        color: #222\9; /* IE */
        *color: #333; /* IE6/IE7 */
        _color: #444; /* IE6 */
        }

//所以可以按着优先级就能给特定的版本捎上特定颜色
</code></pre>
<p>说明：在标准模式中</p>
<ul>
<li>“-″减号是IE6专有的hack</li>
<li>“\9″ IE6/IE7/IE8/IE9/IE10都生效</li>
<li>“\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>
<li>“\9\0″ 只对IE9/IE10生效，是IE9/10的hack</li>
</ul>
<h3 id="选择器前缀法"><a href="#选择器前缀法" class="headerlink" title="选择器前缀法"></a>选择器前缀法</h3><pre><code class="css">*div{color:red;}              //IE6可识别 
*+div{color:red;}            //IE7可识别 
@media screen\9{...}        //只对IE6/7生效
@media \0screen {body { background: red; }}                //只对IE8有效
@media \0screen\,screen\9{body { background: blue; }}    //只对IE6/7/8有效
@media screen\0 {body { background: green; }}             //只对IE8/9/10有效
@media screen and (min-width:0\0) {body { background: gray; }}     //只对IE9/10有效
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }}         //只对IE10有效 等等
</code></pre>
<h2 id="移动端适应"><a href="#移动端适应" class="headerlink" title="移动端适应"></a>移动端适应</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h2><h3 id="谈谈兼容性的问题"><a href="#谈谈兼容性的问题" class="headerlink" title="谈谈兼容性的问题"></a>谈谈兼容性的问题</h3><p>自己遇到的最严重的兼容性case，需求是什么，一开始怎么做的，怎么发现有问题，怎么找到问题的原因，有哪些解决方案，最后选了哪一种，为什么选这种方式，这个过程里学到了什么，再做一次类似case会有什么改变，将来怎么避免等等。</p>
<h2 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h2><h3 id="CSS中使用列布局是什么？"><a href="#CSS中使用列布局是什么？" class="headerlink" title="CSS中使用列布局是什么？"></a>CSS中使用列布局是什么？</h3><pre><code class="css">&lt;style&gt;
//我们需要把text划分为多少列
.magazine
{
  -moz-column-count:3; /* Firefox */
  -webkit-column-count:3; /* Safari and Chrome */
  column-count:3;

  //两列之间我们想要多少差距
  -moz-column-gap:40px; /* Firefox */
  -webkit-column-gap:40px; /* Safari and Chrome */
  column-gap:20px;

  //你想在这些列之间画一条线么？如果是，那么多厚呢？
  -moz-column-rule:4px outset #ff00ff; /* Firefox */
  -webkit-column-rule:4px outset #ff00ff; /* Safari and Chrome */
  column-rule:6px outset #ff00ff;
}
&lt;/style&gt;
</code></pre>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code class="css">.clearfix:after {
  content:&quot;.&quot;; 
  display:block; 
  height:0; 
  visibility:hidden; 
  clear:both; }
.clearfix { *zoom:1; }
</code></pre>
<h2 id="垂直水平居中实现"><a href="#垂直水平居中实现" class="headerlink" title="垂直水平居中实现"></a>垂直水平居中实现</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="行内或类行内元素"><a href="#行内或类行内元素" class="headerlink" title="行内或类行内元素"></a>行内或类行内元素</h4><p>在块级父容器中让行内元素居中，只需使用 <code>text-align: center;</code></p>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>设置 <code>margin-left</code> 和 <code>margin-right</code> 为 <code>auto</code>（前提是已经为元素设置了适当的 <code>width</code> 宽度，否则块级元素的宽度会被拉伸为父级容器的宽度）</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a><code>float</code></h4><p>float 属性是不能简单实现元素居中。</p>
<p>可以使用伪元素充当占位符</p>
<h4 id="多个块级元素"><a href="#多个块级元素" class="headerlink" title="多个块级元素"></a>多个块级元素</h4><p>修改<code>display</code> 值。使用了 <code>inline-block</code> 的显示方式，另一个使用了 <code>flexbox</code> 的显示方式</p>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="行内或类行内元素-1"><a href="#行内或类行内元素-1" class="headerlink" title="行内或类行内元素"></a>行内或类行内元素</h4><ul>
<li>等值的 <code>padding-top</code> 和 <code>padding-bottom</code></li>
<li><code>line-height</code> 和 <code>center</code> 相等</li>
</ul>
<h4 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h4><ul>
<li>等值的 <code>padding-top</code> 和 <code>padding-bottom</code></li>
<li><code>table-cell</code> 的父级容器，然后使用 <a href="http://www.w3cplus.com/css/what-is-vertical-align.html" target="_blank" rel="external"><code>vertical-align</code></a> 属性</li>
<li><code>flexbox</code> 实现垂直居中，对于父级容器为 <code>display: flex</code> 的元素来说，它的每一个子元素都是垂直居中</li>
<li>幽灵元素，在垂直居中的元素上添加伪元素，设置伪元素的高等于父级容器的高，然后为文本添加 <code>vertical-align: middle;</code> 样式</li>
</ul>
<h4 id="块级元素-1"><a href="#块级元素-1" class="headerlink" title="块级元素"></a>块级元素</h4><h5 id="已知元素的高度"><a href="#已知元素的高度" class="headerlink" title="已知元素的高度"></a>已知元素的高度</h5><pre><code class="css">position: absolute;
top: 50%;
height: 100px;
margin-top: -50px;
</code></pre>
<h5 id="未知元素的高度"><a href="#未知元素的高度" class="headerlink" title="未知元素的高度"></a>未知元素的高度</h5><p>需要先将元素定位到容器的中心位置，然后使用 <code>transform</code> 的 <code>translate</code> 属性，将元素的中心和父容器的中心重合，从而实现垂直居中</p>
<pre><code class="css">position: absolute; 
top: 50%; 
transform: translateY(-50%);
</code></pre>
<h4 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h4><pre><code class="css">display: flex; 
flex-direction: column; 
justify-content: center;
</code></pre>
<h3 id="水平且垂直居中"><a href="#水平且垂直居中" class="headerlink" title="水平且垂直居中"></a>水平且垂直居中</h3><h4 id="宽高固定元素"><a href="#宽高固定元素" class="headerlink" title="宽高固定元素"></a>宽高固定元素</h4><p>设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%，最后使用负向 margin 实现水平和垂直居中，margin 的值为宽高（具体的宽高需要根据实际情况计算 padding）的一半。</p>
<pre><code class="css">width: 300px; 
height: 100px;
padding: 20px; 
position: absolute; 
top: 50%; 
left: 50%; 
margin: -70px 0 0 -170px;
</code></pre>
<h4 id="宽高不固定元素"><a href="#宽高不固定元素" class="headerlink" title="宽高不固定元素"></a>宽高不固定元素</h4><p>设定父级容器为相对定位的容器，设定子元素绝对定位的位置 <code>position: absolute; top: 50%; left: 50%</code>。不同的是，接下来需要使用 <code>transform: translate(-50%, -50%);</code> 实现垂直居中</p>
<pre><code class="css">position: absolute; 
top: 50%; 
left: 50%; 
transform: translate(-50%, -50%);
</code></pre>
<p>使用 <code>transform</code> 有一个缺陷，就是当计算结果含有小数时（比如 <code>0.5</code>），会让整个元素看起来是模糊的，一种解决方案就是为父级元素设置 <code>transform-style: preserve-3d;</code> 样式</p>
<h4 id="flexbox-1"><a href="#flexbox-1" class="headerlink" title="flexbox"></a>flexbox</h4><pre><code class="css">display: flex; 
justify-content: center; 
align-items: center;
</code></pre>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="CSS3中的文本效果"><a href="#CSS3中的文本效果" class="headerlink" title="CSS3中的文本效果"></a>CSS3中的文本效果</h3><p>阴影文本效果</p>
<pre><code class="css">.specialtext
{
    text-shadow: 5px 5px 5px #FF0000;
}
</code></pre>
<p>文字包装效果：允许长单词换行到下一行</p>
<pre><code class="css">&lt;style&gt;
.breakword
    {word-wrap:break-word;}
&lt;/style&gt;
</code></pre>
<h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><pre><code class="css">div
{
  animation:mymove 5s infinite;
  -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */
}
</code></pre>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://segmentfault.com/a/1190000006890725" target="_blank" rel="external">前端面试之CSS总结(上)</a></li>
<li><a href="http://www.cnblogs.com/bergwhite/p/6417800.html" target="_blank" rel="external">前端总结·基础篇·CSS（一）布局</a></li>
<li><a href="http://blog.csdn.net/icesschen/article/details/52443364" target="_blank" rel="external">关于margin上下重叠的问题</a></li>
<li><a href="http://www.cnblogs.com/guhui1994/p/5906268.html" target="_blank" rel="external">CSS常见兼容性问题总结</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> CSS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础算法]]></title>
      <url>/2017/01/02/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>面试的基础算法整理总结</p>
<a id="more"></a>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><pre><code class="javascript">function quickSort(arr){
  if(arr.length&lt;=1){return arr;}
  var pivotIndex=Math.floor(arr.length/2);
  //找基准，并把基准从原数组删除
  var pivot=arr.splice(pivotIndex,1)[0];
  //定义左右数组
  var left=[];
  var right=[];

  //比基准小的放在left，比基准大的放在right
  for(var i=0;i&lt;arr.length;i++){
    if(arr[i]&lt;=pivot){
      left.push(arr[i]);
    }
    else{
      right.push(arr[i]);
    }
  }
  //递归
  return quickSort(left).concat([pivot],quickSort(right));
}
</code></pre>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="节点个数"><a href="#节点个数" class="headerlink" title="节点个数"></a>节点个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，节点个数为0</li>
<li>如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</li>
</ol>
<pre><code class="c++">int GetNodeNum(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    return GetNodeNum(pRoot-&gt;m_pLeft) + GetNodeNum(pRoot-&gt;m_pRight) + 1;  
}
</code></pre>
<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，二叉树的深度为0</li>
<li>如果二叉树不为空，二叉树的深度 = max(左子树深度， 右子树深度) + 1</li>
</ol>
<pre><code class="c++">int GetDepth(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 递归出口  
        return 0;  
    int depthLeft = GetDepth(pRoot-&gt;m_pLeft);  
    int depthRight = GetDepth(pRoot-&gt;m_pRight);  
    return depthLeft &gt; depthRight ? (depthLeft + 1) : (depthRight + 1);   
}
</code></pre>
<h3 id="前序遍历，中序遍历，后序遍历"><a href="#前序遍历，中序遍历，后序遍历" class="headerlink" title="前序遍历，中序遍历，后序遍历"></a>前序遍历，中序遍历，后序遍历</h3><p>前序遍历递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>
</ol>
<pre><code class="javascript">void PreOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    Visit(pRoot); // 访问根节点  
    PreOrderTraverse(pRoot-&gt;m_pLeft); // 前序遍历左子树  
    PreOrderTraverse(pRoot-&gt;m_pRight); // 前序遍历右子树  
}
</code></pre>
<p>中序遍历递归解法</p>
<ol>
<li>如果二叉树为空，空操作。</li>
<li>如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树</li>
</ol>
<pre><code class="javascript">void InOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    InOrderTraverse(pRoot-&gt;m_pLeft); // 中序遍历左子树  
    Visit(pRoot); // 访问根节点  
    InOrderTraverse(pRoot-&gt;m_pRight); // 中序遍历右子树  
}
</code></pre>
<p>后序遍历递归解法</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点</li>
</ol>
<pre><code class="javascript">void PostOrderTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    PostOrderTraverse(pRoot-&gt;m_pLeft); // 后序遍历左子树  
    PostOrderTraverse(pRoot-&gt;m_pRight); // 后序遍历右子树  
    Visit(pRoot); // 访问根节点  
}
</code></pre>
<h3 id="分层遍历二叉树（按层次从上往下，从左往右）"><a href="#分层遍历二叉树（按层次从上往下，从左往右）" class="headerlink" title="分层遍历二叉树（按层次从上往下，从左往右）"></a>分层遍历二叉树（按层次从上往下，从左往右）</h3><p>相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p>
<pre><code class="c++">void LevelTraverse(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return;  
    queue&lt;BinaryTreeNode *&gt; q;  
    q.push(pRoot);  
    while(!q.empty())  
    {  
        BinaryTreeNode * pNode = q.front();  
        q.pop();  
        Visit(pNode); // 访问节点  
        if(pNode-&gt;m_pLeft != NULL)  
            q.push(pNode-&gt;m_pLeft);  
        if(pNode-&gt;m_pRight != NULL)  
            q.push(pNode-&gt;m_pRight);  
    }  
    return;  
}
</code></pre>
<h3 id="求二叉树第K层的节点个数"><a href="#求二叉树第K层的节点个数" class="headerlink" title="求二叉树第K层的节点个数"></a>求二叉树第K层的节点个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空或者k&lt;1返回0</li>
</ol>
<ol>
<li>如果二叉树不为空并且k==1，返回1</li>
<li>如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和</li>
</ol>
<pre><code class="c++">int GetNodeNumKthLevel(BinaryTreeNode * pRoot, int k)  
{  
    if(pRoot == NULL || k &lt; 1)  
        return 0;  
    if(k == 1)  
        return 1;  
    int numLeft = GetNodeNumKthLevel(pRoot-&gt;m_pLeft, k-1); // 左子树中k-1层的节点个数  
    int numRight = GetNodeNumKthLevel(pRoot-&gt;m_pRight, k-1); // 右子树中k-1层的节点个数  
    return (numLeft + numRight);  
}
</code></pre>
<h3 id="求二叉树中叶子节点的个数"><a href="#求二叉树中叶子节点的个数" class="headerlink" title="求二叉树中叶子节点的个数"></a>求二叉树中叶子节点的个数</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回0</li>
</ol>
<ol>
<li>如果二叉树不为空且左右子树为空，返回1</li>
<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数</li>
</ol>
<pre><code class="c++">int GetLeafNodeNum(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL)  
        return 0;  
    if(pRoot-&gt;m_pLeft == NULL &amp;&amp; pRoot-&gt;m_pRight == NULL)  
        return 1;  
    int numLeft = GetLeafNodeNum(pRoot-&gt;m_pLeft); // 左子树中叶节点的个数  
    int numRight = GetLeafNodeNum(pRoot-&gt;m_pRight); // 右子树中叶节点的个数  
    return (numLeft + numRight);  
}
</code></pre>
<h3 id="求二叉树的镜像"><a href="#求二叉树的镜像" class="headerlink" title="求二叉树的镜像"></a>求二叉树的镜像</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回空</li>
<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树</li>
</ol>
<pre><code class="c++">BinaryTreeNode * Mirror(BinaryTreeNode * pRoot)  
{  
    if(pRoot == NULL) // 返回NULL  
        return NULL;  
    BinaryTreeNode * pLeft = Mirror(pRoot-&gt;m_pLeft); // 求左子树镜像  
    BinaryTreeNode * pRight = Mirror(pRoot-&gt;m_pRight); // 求右子树镜像  
        // 交换左子树和右子树  
    pRoot-&gt;m_pLeft = pRight;  
    pRoot-&gt;m_pRight = pLeft;  
    return pRoot;  
}
</code></pre>
<h3 id="判断二叉树是不是平衡二叉树"><a href="#判断二叉树是不是平衡二叉树" class="headerlink" title="判断二叉树是不是平衡二叉树"></a>判断二叉树是不是平衡二叉树</h3><p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回真</li>
<li>如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假</li>
</ol>
<pre><code class="c++">bool IsAVL(BinaryTreeNode * pRoot, int &amp; height)  
{  
    if(pRoot == NULL) // 空树，返回真  
    {  
        height = 0;  
        return true;  
    }  
    int heightLeft;  
    bool resultLeft = IsAVL(pRoot-&gt;m_pLeft, heightLeft);  
    int heightRight;  
    bool resultRight = IsAVL(pRoot-&gt;m_pRight, heightRight);  
    if(resultLeft &amp;&amp; resultRight &amp;&amp; abs(heightLeft - heightRight) &lt;= 1) // 左子树和右子树都是AVL，并且高度相差不大于1，返回真  
    {  
        height = max(heightLeft, heightRight) + 1;  
        return true;  
    }  
    else  
    {  
        height = max(heightLeft, heightRight) + 1;  
        return false;  
    }  
}
</code></pre>
<h3 id="由前序遍历序列和中序遍历序列重建二叉树"><a href="#由前序遍历序列和中序遍历序列重建二叉树" class="headerlink" title="由前序遍历序列和中序遍历序列重建二叉树"></a>由前序遍历序列和中序遍历序列重建二叉树</h3><p>递归解法：</p>
<ol>
<li>如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。</li>
<li>创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。</li>
</ol>
<pre><code class="javascript">function reConstructBinaryTree(pre, vin)
{
    // write code here
    if(pre.length==0 || vin.length==0) return null;
    var index=vin.indexOf(pre[0]);
    var left=vin.slice(0,index);//中序左子树
    var right=vin.slice(index+1);//中序右子树
    return {
        val:pre[0],
        //递归左右子树的前序，中序 
        left:reConstructBinaryTree(pre.slice(1,index+1),left),
        right:reConstructBinaryTree(pre.slice(index+1),right)
     }; 
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> 算法题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指offer]]></title>
      <url>/2017/01/02/%E9%9D%A2%E8%AF%95/%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer/</url>
      <content type="html"><![CDATA[<p>剑指offer一刷留念</p>
<a id="more"></a>
<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><blockquote>
<p>A：完全不理解写不出，B：思想理解写不出，C：思想不理解提示能写出</p>
</blockquote>
<h2 id="一刷"><a href="#一刷" class="headerlink" title="一刷"></a>一刷</h2><h3 id="1-二维数组中的查找-C"><a href="#1-二维数组中的查找-C" class="headerlink" title="1. 二维数组中的查找(C)"></a>1. 二维数组中的查找(C)</h3><blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>思路：因为矩阵的特殊性，所以先从<strong>第一列最后一行</strong>开始比较，小于则向上查找，大于则向后查找</p>
<h3 id="2-替换空格-B"><a href="#2-替换空格-B" class="headerlink" title="2.替换空格(B)"></a>2.替换空格(B)</h3><blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>思路：使用正则表达式，<strong>\s+代表多个空格，？则表示取尽可能少的空格</strong>，然后通过replace函数替换为%20</p>
<pre><code class="javascript">return str.replace(/\s+?/g,&#39;%20&#39;)
</code></pre>
<h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>
<p>思路1：先将链表每个结点的值存入数组中，然后通过数组的<strong>reverse</strong>方法，即可从尾到头打印</p>
<p>我的思路：直接用<strong>unshift</strong></p>
<pre><code class="javascript">res.unshift(head.val);
</code></pre>
<h3 id="4-重建二叉树-B"><a href="#4-重建二叉树-B" class="headerlink" title="4.重建二叉树(B)"></a>4.重建二叉树(B)</h3><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<p>思路：二叉树前序遍历第一个点为根节点，中序遍历顺序为先左子树然后根节点最后右子树。所以<strong>先通过前序遍历找出根节点，然后将中序遍历分为左右子树两组，最后对于每个子树依次递归调用。</strong></p>
<pre><code class="javascript">function reConstructBinaryTree(pre, vin)
{
    // write code here
    if(pre.length==0 || vin.length==0) return null;
    var index=vin.indexOf(pre[0]);
    var left=vin.slice(0,index);//中序左子树
    var right=vin.slice(index+1);//中序右子树
    return {
        val:pre[0],
        //递归左右子树的前序，中序 
        left:reConstructBinaryTree(pre.slice(1,index+1),left),
        right:reConstructBinaryTree(pre.slice(index+1),right)
     }; 
}
</code></pre>
<h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h3><blockquote>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</p>
</blockquote>
<p>思路：push + shift</p>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6. 旋转数组的最小数字"></a>6. 旋转数组的最小数字</h3><blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>Math.min</li>
<li>排序:直接将数组按从小到大排序，返回第一个元素即可。</li>
<li>二分法:mid = Math.floor((left+right)/2),直到左右差1个元素</li>
</ol>
<pre><code class="javascript">return Math.min.apply(Math,rotateArray);
</code></pre>
<h3 id="7-斐波那契数列-C"><a href="#7-斐波那契数列-C" class="headerlink" title="7.斐波那契数列(C)"></a>7.斐波那契数列(C)</h3><blockquote>
<p>输入一个整数n，请你输出斐波那契数列的第n项。</p>
</blockquote>
<p>思路：F(n) = F(n-2)+F(n-1)</p>
<ol>
<li>递归版本：不好</li>
<li><strong>动态规划版本</strong></li>
</ol>
<pre><code class="javascript">//2.动态规划版本：
for(var i=2;i&lt;=n;i++)
{
  temp = f1 + f2;
  f1=f2;
  f2 = temp;
}
</code></pre>
<h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>思路：和7题本质一样</p>
<h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>思路：<strong>F(n) = 2* F(n-1)</strong></p>
<pre><code class="javascript">return 2 * jumpFloorII(number - 1)
</code></pre>
<h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><blockquote>
<p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<p>思路：依旧是斐波那契数列</p>
<h3 id="11-二进制中1的个数-C"><a href="#11-二进制中1的个数-C" class="headerlink" title="11.二进制中1的个数(C)"></a>11.二进制中1的个数(C)</h3><blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>思路:</p>
<ol>
<li><strong>把一个整数减去1，再和原来的整数做与运算</strong>，会把该整数最右边的一个1变为0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。</li>
<li>如果是负数，对其进行位操作,然后<strong>toString</strong></li>
</ol>
<pre><code class="javascript">//思路1:n=n&amp;(n-1);
//思路2: n = n&gt;&gt;&gt;0;;n.toString(2);
</code></pre>
<h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h3><blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<p>思路:</p>
<ol>
<li>先判断浮点数的正负情况，然后通过累乘的方式, 注意exponent正负</li>
<li><code>return base**exponent;</code></li>
</ol>
<h3 id="13-调整数组顺序"><a href="#13-调整数组顺序" class="headerlink" title="13.调整数组顺序"></a>13.调整数组顺序</h3><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<p>思路: 通过map函数</p>
<pre><code class="javascript">array.map(a =&gt; (a%2!=0?arr1.push(a):arr2.push(a)));
</code></pre>
<h3 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h3><blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<p>思路: <strong>通过prev和tail来获取距离为k的一段</strong>，然后就tail指向链表最后，</p>
<h3 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h3><blockquote>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p>思路：<strong>三个指针</strong>。通过prev固定反转后链表头，通过head来反转，通过next指向剩下的链表头部</p>
<h3 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h3><blockquote>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<p>思路：两个指针分别指向链表元素，然后比较两个元素大小，小的则连到合成后链表，直到达到一个链表的末尾。然后如果哪一个链表还有元素，直接连到合成后链表后面即可。</p>
<h3 id="17-树的子结构-C"><a href="#17-树的子结构-C" class="headerlink" title="17.树的子结构(C)"></a>17.树的子结构(C)</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>思路：比较B是不是A的子树，B是不是A的右子树的子树，B是不是A的左子树的子树。如果根元素相同，则开始判断左子树和右子树</p>
<pre><code class="javascript">function isSubtree(pRoot1,pRoot2){
    if (pRoot2 == null) return true;//pRoot2为null，表示子树已经遍历完
    if (pRoot1 == null) return false;
    if(pRoot1.val==pRoot2.val){
        return isSubtree(pRoot1.left,pRoot2.left) &amp;&amp; isSubtree(pRoot1.right,pRoot2.right);
    }else{
        return false;
    }
}

function HasSubtree(pRoot1, pRoot2)
{
    if(pRoot1==null||pRoot2==null) return false;   
    return isSubtree(pRoot1,pRoot2)||HasSubtree(pRoot1.left,pRoot2)||HasSubtree(pRoot1.right,pRoot2);
}
</code></pre>
<h3 id="18-二叉树镜像"><a href="#18-二叉树镜像" class="headerlink" title="18.二叉树镜像"></a>18.二叉树镜像</h3><blockquote>
<p>操作给定的二叉树，将其变换为源二叉树的镜像</p>
</blockquote>
<p>思路：先将根的<strong>左右节点互换，然后就是递归调用</strong>，对左右子树进行分别处理</p>
<h3 id="19-顺时针打印矩阵-B"><a href="#19-顺时针打印矩阵-B" class="headerlink" title="19.顺时针打印矩阵(B)"></a>19.顺时针打印矩阵(B)</h3><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
</blockquote>
<p>思路：</p>
<ol>
<li>选坐标为(0,0),(1,1)…的点记为(start,start)，作为开始坐标,下一圈开始坐标为(start+1,start+1)；</li>
<li>关键：<strong>判断是否进入下一圈(即是否打印完成)的条件</strong>是<code>rows&gt;start*2 &amp;&amp; cols&gt;start*2</code>；</li>
<li>打印一圈的左上角坐标为(start,start)，右下角的坐标为(cols-start-1,rows-start-1)</li>
<li>根据一圈左上角和右下角坐标判断“从左到右”，“从上到下”，“从右到左”，“从下到上”需要打印的点。</li>
</ol>
<h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h3><blockquote>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
</blockquote>
<p>思路：通过数组来实现栈的功能</p>
<pre><code class="javascript"> result.map(val=&gt;((min&gt;val)?min=val:null));
</code></pre>
<h3 id="21-栈的压入、弹出-C"><a href="#21-栈的压入、弹出-C" class="headerlink" title="21.栈的压入、弹出(C)"></a>21.栈的压入、弹出(C)</h3><blockquote>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列<code>1,2,3,4,5</code>是某栈的压入顺序，序列<code>4,5,3,2,1</code>是该压栈序列对应的一个弹出序列，但<code>4,3,5,1,2</code>就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
</blockquote>
<p>思路：设置辅助栈，压入元素，<strong>判断栈顶元素是否等于出栈第一个，相同则出栈</strong>，不同则继续入栈</p>
<h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>思路：采用<strong>队列</strong>方法，先将<strong>根节点放入队列</strong>中，然后打印，接着<strong>将左右节点加入队列</strong>中。</p>
<pre><code class="javascript">while (queue.length) {
  var temp = queue.shift();
  result.push(temp.val);
  if (temp.left) {
    queue.push(temp.left);
  }
  if (temp.right) {
    queue.push(temp.right);
  }
}
</code></pre>
<h3 id="23-二叉搜索树的后序遍历-A"><a href="#23-二叉搜索树的后序遍历-A" class="headerlink" title="23.二叉搜索树的后序遍历(A)"></a>23.二叉搜索树的后序遍历(A)</h3><blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>思路：后序遍历最后一个元素为根节点，所以先遍历，将数组分为小于根节点部分和大于根节点部分，然后比较这两个部分是否符合与根节点的大小关系。</p>
<pre><code class="javascript">function VerifySquenceOfBST(sequence)
{
    // write code here
    if(sequence.length&lt;=0) return;
    return test(sequence,0,sequence.length-1)
}
function test(sequence,start,end){
    if(start&gt;=end) return true;
    var i=end-1;
    while(i&gt;=start &amp;&amp; sequence[i]&gt;sequence[end]){
        i--;
    }
    for(var j=i;j&gt;=start;j--){
        if(sequence[j]&gt;sequence[end]){
            return false;
        }
    }
    return test(sequence,start,i)&amp;&amp;test(sequence,i+1,end-1)
}
</code></pre>
<h3 id="24-二叉树中和为某一值的路径-A"><a href="#24-二叉树中和为某一值的路径-A" class="headerlink" title="24.二叉树中和为某一值的路径(A)"></a>24.二叉树中和为某一值的路径(A)</h3><blockquote>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
</blockquote>
<p>思路：判断当前结点是否是叶子结点，以及curtSum是否等于expectNumber。如果是，把当前路径保存在res结果中；</p>
<pre><code class="javascript">function FindPath(root, expectNumber)
{
    var result=[];
    if(root==null) return result;
    dfs(root,0,[]);
    function dfs(root,current,path){
        current+=root.val;
        path.push(root.val)
        if(current==expectNumber &amp;&amp; root.left==null &amp;&amp; root.right ==null){
            result.push(path.slice(0))
        }
        if(root.left!=null){
            dfs(root.left,current,path)
        }
        if(root.right!=null){
            dfs(root.right,current,path)
        }
        path.pop()
    }
    return result;
}
</code></pre>
<h3 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h3><blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p>
</blockquote>
<p>思路：将复杂链表分为<strong>头结点和剩余结点</strong>两部分，剩余部分采用递归方法。</p>
<pre><code class="javascript">var node = new RandomListNode(pHead.label);
node.random = pHead.random;
node.next = Clone(pHead.next);
</code></pre>
<h3 id="26-二叉搜索树与双向链表-A"><a href="#26-二叉搜索树与双向链表-A" class="headerlink" title="26.二叉搜索树与双向链表(A)"></a>26.二叉搜索树与双向链表(A)</h3><blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>将左子树构成双向链表，返回的是左子树的尾结点，将其连接到root的左边； </li>
<li>将右子树构成双向链表，将其追加到root结点之后，并返回尾结点；</li>
<li>向左遍历返回的链表至头结点处，即为所求双向链表的首结点。</li>
</ul>
<pre><code class="javascript">function Convert(pRootOfTree)
{
    // write code here
    if(pRootOfTree==null){
        return null;
    }
    var lastNode=null;
    lastNode=convertNode(pRootOfTree,lastNode);
    var head=lastNode;
    while(head &amp;&amp; head.left){//循环到头部
        head=head.left;
    }
    return head;
}
function convertNode(root,lastNode){
    if(root==null) return;
    if(root.left){//左子树
        lastNode=convertNode(root.left,lastNode)
    }
    root.left=lastNode;
    if(lastNode){
        lastNode.right=root;
    }
    lastNode=root;
    if(root.right){//右子树
        lastNode=convertNode(root.right,lastNode)
    }
    return lastNode;
}
</code></pre>
<h3 id="27-字符串排列（B）"><a href="#27-字符串排列（B）" class="headerlink" title="27.字符串排列（B）"></a>27.字符串排列（B）</h3><blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<p>思路：<strong>使用递归方法，n个元素的全排列 = （n-1） 个元素全排列 + 一个元素作为前缀。</strong>判断是否重复</p>
<pre><code class="javascript">function sortString(arr,sortTemp,result){...}
</code></pre>
<h3 id="28-数组中出现次数超过一半"><a href="#28-数组中出现次数超过一半" class="headerlink" title="28.数组中出现次数超过一半"></a>28.数组中出现次数超过一半</h3><blockquote>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
</blockquote>
<p>思路：可以使用map数据结构</p>
<pre><code class="javascript">numbers.map(x=&gt;(countObj[x]?countObj[x]++:countObj[x]=1));
for(var i in countObj)
</code></pre>
<h3 id="29-最小的k个数"><a href="#29-最小的k个数" class="headerlink" title="29.最小的k个数"></a>29.最小的k个数</h3><blockquote>
<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
</blockquote>
<p>思路：先排序，然后slice()即可。</p>
<pre><code class="javascript">input.sort((a,b)=&gt;(a-b));
return input.slice(0,k);
</code></pre>
<h3 id="30-连续子数组的最大和-C"><a href="#30-连续子数组的最大和-C" class="headerlink" title="30.连续子数组的最大和(C)"></a>30.连续子数组的最大和(C)</h3><blockquote>
<p>在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
</blockquote>
<p>思路：<strong>如果和为负数，则重新开始，如果和为正数，则继续加</strong>，然后比较大小，选出最大和即可。</p>
<pre><code class="javascript">var tempSum=0,sum=-Number.MAX_VALUE;
array.map(function(a){
    tempSum=(tempSum&lt;0)?a:tempSum+a;
    sum=(sum&lt;tempSum)?tempSum:sum;
})
</code></pre>
<h3 id="31-整数中1出现的次数-C"><a href="#31-整数中1出现的次数-C" class="headerlink" title="31.整数中1出现的次数(C)"></a>31.整数中1出现的次数(C)</h3><blockquote>
<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。求出任意非负整数区间中1出现的次数</p>
</blockquote>
<p>思路1：</p>
<ol>
<li>如果第i位上的数字为0，则第i位可能出现1的次数由其高位决定，若没有高位，则视为0，此时第i位可能出现1的次数为：<code>其高位数*10^(i-1)</code>，例如若c为0，则次数为ab*10^2;</li>
<li>如果第i位上的数字为1，则第i位上可能出现1的次数受其高位和低位影响，若没有，则视为0，此时第i位可能出现1的次数：<code>其高位数*10^(i-1)+（低位数+1）</code>，例如若c为1，则次数为ab*10^2+（de+1）;</li>
<li>如果第i位上的数字大于1，则第i位上可能出现1的次数受其高位影响，若没有，则视为0，此时第i位可能出现1的次数：<code>（其高位数+1）*10^(i-1)</code>，例如若c大于1，则次数为（ab+1）*10^2;</li>
</ol>
<p>思路2：暴力解决，一个数一个数判断</p>
<h3 id="32-把数组排成最小的数-B"><a href="#32-把数组排成最小的数-B" class="headerlink" title="32.把数组排成最小的数(B)"></a>32.把数组排成最小的数(B)</h3><blockquote>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
</blockquote>
<p>思路：排序规则如下：</p>
<ul>
<li>若ab &gt; ba 则 a &gt; b，</li>
<li>若ab &lt; ba 则 a &lt; b，</li>
<li>若ab = ba 则 a = b；</li>
</ul>
<pre><code class="javascript">numbers.sort(function(a,b){
        var s1 = a +&#39;&#39;+b;
        var s2 = b+&#39;&#39;+a;
        return parseInt(s1)-parseInt(s2);
    })
numbers.map(function(num){
        result = result.concat(num);
})
</code></pre>
<h3 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h3><blockquote>
<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
</blockquote>
<p>思路：下一个丑数是由数组中<strong>某个丑数A <em> 2，B </em> 3，C * 5中的最小值</strong>得来的。<strong>按序全部遍历</strong></p>
<pre><code class="javascript">uglys[i]=Math.min(uglys[factor2]*2,uglys[factor3]*3,uglys[factor5]*5)
if(uglys[i]==uglys[factor2]*2) factor2++;
...
</code></pre>
<h3 id="34-第一次只出现一次的字符"><a href="#34-第一次只出现一次的字符" class="headerlink" title="34.第一次只出现一次的字符"></a>34.第一次只出现一次的字符</h3><blockquote>
<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
</blockquote>
<p>思路：使用map结构，将每次出现字符和出现次数放入map中</p>
<pre><code class="javascript">strArr.map( s =&gt; (!count[s]?count[s]=1:count[s]++));
for(var i in count)
</code></pre>
<h3 id="35-数组中的逆序对-A"><a href="#35-数组中的逆序对-A" class="headerlink" title="35.数组中的逆序对(A)"></a>35.数组中的逆序对(A)</h3><blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 ; 注意：时间有限制</p>
</blockquote>
<p>思路：利用<strong>归并排序</strong>思想，先求出每个组中逆序对数，然后合并、排序并统计，</p>
<h3 id="36-两个链表的第一个公共结点-A"><a href="#36-两个链表的第一个公共结点-A" class="headerlink" title="36.两个链表的第一个公共结点(A)"></a>36.两个链表的第一个公共结点(A)</h3><blockquote>
<p>输入两个链表，找出它们的第一个公共结点。</p>
</blockquote>
<p>思路：两个指针，遍历后比较结点的值</p>
<ul>
<li>长度相同有公共结点，第一次就遍历到；没有公共结点，走到尾部NULL相遇，返回NULL</li>
<li>长度不同有公共结点，第一遍差值就出来了，第二遍一起到公共结点；没有公共，一起到结尾NULL。</li>
</ul>
<pre><code class="javascript">while(p1!=p2){
  p1=(p1==null?pHead2:p1.next)
  p2=(p2==null?pHead1:p2.next)
}
</code></pre>
<h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><blockquote>
<p>统计一个数字在排序数组中出现的次数。</p>
</blockquote>
<p>思路:</p>
<ol>
<li>暴力解决方法，遍历</li>
<li>二分查找方法：先看中间元素与k相比，小于则在左半部分，大于则在右半部分，</li>
</ol>
<h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h3><blockquote>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
</blockquote>
<p>思路：递归求左子树和右子树深度，然后比较，最终返回最大值加1</p>
<h3 id="39-平衡二叉树-B"><a href="#39-平衡二叉树-B" class="headerlink" title="39.平衡二叉树(B)"></a>39.平衡二叉树(B)</h3><blockquote>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
</blockquote>
<p>思路：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。遍历左子树和右子树的深度，然后比较二者差值</p>
<h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>思路：将数组同去重后的数组进行比较，求出数组中元素出现的次数</p>
<h3 id="41-和为S的连续正数序列-C"><a href="#41-和为S的连续正数序列-C" class="headerlink" title="41.和为S的连续正数序列(C)"></a>41.和为S的连续正数序列(C)</h3><blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? </p>
</blockquote>
<p>思路：设定两个指针，<strong>如果和大于sum，左指针向后移位，如果小于，右指针向后移位</strong>。 如果两个指针碰在一起，则跳出， <strong>左指针一直小于sum的一半</strong></p>
<h3 id="42-和为sum的两个数字"><a href="#42-和为sum的两个数字" class="headerlink" title="42.和为sum的两个数字"></a>42.和为sum的两个数字</h3><blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
</blockquote>
<p>思路：两头乘积最小，所以两个指针，一个从头，一个从尾分别遍历，当第一次出现和为S时，乘积最小。和41题本质相同</p>
<h3 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h3><blockquote>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
</blockquote>
<p>思路：通过切分字符串，然后将后部分的字符串贴在前部分字符串前面</p>
<p><strong>注意：</strong></p>
<pre><code class="javascript">var left=str.slice(0,n);
var right=str.slice(n);
</code></pre>
<h3 id="44-翻转单词顺序序列"><a href="#44-翻转单词顺序序列" class="headerlink" title="44.翻转单词顺序序列"></a>44.翻转单词顺序序列</h3><blockquote>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
</blockquote>
<pre><code class="javascript">//注意：join参数为分隔符
var array = str.split(&#39; &#39;);
return array.reverse().join(&#39; &#39;);
</code></pre>
<h3 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h3><blockquote>
<p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
</blockquote>
<p>思路：首先先排序，然后统计大小王个数，然后遍历，看缺多少个数才能连续，如果超过大小王个数则失败。注意可能牌重复</p>
<h3 id="46-圆圈中最后剩下的数-C"><a href="#46-圆圈中最后剩下的数-C" class="headerlink" title="46.圆圈中最后剩下的数(C)"></a>46.圆圈中最后剩下的数(C)</h3><blockquote>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
</blockquote>
<p>思路：约瑟夫问题</p>
<ol>
<li>建数组</li>
<li>模拟报数，将报数的人踢出数组，<strong>注意要少1个序号</strong>。</li>
<li>直到数组只剩1个</li>
</ol>
<blockquote>
<p>注意：for循环中i为1开始</p>
</blockquote>
<pre><code class="javascript">for(var i=0;i&lt;n;i++) arr.push(i);
var idx = 0;
while(arr.length &gt; 1){
  for(var i=1;i&lt;m;i++){
    idx=(idx+1)%arr.length;
  }
  arr.splice(idx,1);
}
return arr[0];
</code></pre>
<h3 id="47-1-2-3-……-n"><a href="#47-1-2-3-……-n" class="headerlink" title="47.1+2+3+……+n"></a>47.1+2+3+……+n</h3><blockquote>
<p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
</blockquote>
<p>思路：<strong>短路判断+递归运算</strong></p>
<h3 id="48-不用加减乘除做加法-A"><a href="#48-不用加减乘除做加法-A" class="headerlink" title="48. 不用加减乘除做加法(A)"></a>48. 不用加减乘除做加法(A)</h3><blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>首先看十进制是如何做的： 5+7=12，三步走</li>
<li>第一步：<strong>相加各位的值，不算进位</strong>，得到2。</li>
<li>第二步：<strong>计算进位值</strong>，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</li>
<li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li>
</ul>
<pre><code class="javascript">while(num2!=0){
  var temp = num1^num2;
  num2 = (num1&amp;num2)&lt;&lt;1;
  num1 = temp;
}
return num1;
</code></pre>
<h3 id="49-把字符串转换成整数-B"><a href="#49-把字符串转换成整数-B" class="headerlink" title="49.把字符串转换成整数(B)"></a>49.把字符串转换成整数(B)</h3><blockquote>
<p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。</p>
</blockquote>
<pre><code class="javascript">//res=res*10+str[i]-&#39;0&#39;;
res = res*10 + (arr[i] &amp; 0xf);
</code></pre>
<h3 id="50-数组中重复数字"><a href="#50-数组中重复数字" class="headerlink" title="50.数组中重复数字"></a>50.数组中重复数字</h3><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<pre><code class="javascript">//1.map
numbers.map(num=&gt;(obj[num]?duplication.push(num):obj[num]=1));
duplication.shift();
//2.排序
numbers.sort((a,b)=&gt;(a-b))
</code></pre>
<h3 id="51-构建乘积数组-B"><a href="#51-构建乘积数组-B" class="headerlink" title="51.构建乘积数组(B)"></a>51.构建乘积数组(B)</h3><blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素<code>B[i]=A[0]*A[1]*…*A[i-1]*A[i+1]*…*A[n-1]</code>。不能使用除法。</p>
</blockquote>
<p>思路：</p>
<ul>
<li>构建<strong>前向乘积数组</strong><code>C[i]=A[0]A[1]…*A[i-1]</code>，<strong>即C[i]=C[i-1]*A[i-1]；</strong></li>
<li>构建<strong>后向乘积数组</strong><code>D[i]=A[n-1]A[n-2]…A[n-i+1]</code>，<strong>即D[i]=D[i+1]*A[i+1]；</strong></li>
<li>通过C[i],D[i]来求B[i]：<strong>B[i]=C[i]*D[i]</strong></li>
</ul>
<pre><code class="javascript">for(var i=1;i&lt;len;i++)
{
  arr[i]=arr[i-1]*array[i-1];
}
for(var i=len-2;i&gt;=0;i--)
{
  temp*=array[i+1];
  arr[i]*=temp;
}
</code></pre>
<h3 id="52-正则表达式匹配-A"><a href="#52-正则表达式匹配-A" class="headerlink" title="52.正则表达式匹配(A)"></a>52.正则表达式匹配(A)</h3><blockquote>
<p>请实现一个函数用来匹配包括<code>’.’和’*‘</code>的正则表达式。模式中的字符’.’表示任意一个字符，而’<em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab</em>ac<em>a”匹配，但是与”aa.a”和”ab</em>a”均不匹配</p>
</blockquote>
<p>思路：</p>
<ul>
<li><p>当模式中的第二个字符不是“*”时：</p>
<ol>
<li>如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。</li>
<li>如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</li>
</ol>
</li>
<li><p>而当模式中的第二个字符是“*”时：</p>
<p>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：</p>
<ol>
<li>模式后移2字符，相当于x*被忽略；</li>
<li>字符串后移1字符，模式后移2字符；</li>
<li>字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；</li>
</ol>
</li>
</ul>
<h3 id="53-表示数值的字符串-B"><a href="#53-表示数值的字符串-B" class="headerlink" title="53.表示数值的字符串(B)"></a>53.表示数值的字符串(B)</h3><blockquote>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
</blockquote>
<pre><code class="javascript">return s.match(/[\+\-]?[0-9]*(\.[0-9]*)?([Ee][\+-]?[0-9]+)?/g)[0] == s
</code></pre>
<h3 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h3><blockquote>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
</blockquote>
<p>思路：设置一个数组存放初次出现的元素。如果这个元素没有过，就放进数组；如果这个元素有过了，就把他从数组删除。输出数组的第一个元素。</p>
<h3 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h3><blockquote>
<p>一个链表中包含环，请找出该链表的环的入口结点。</p>
</blockquote>
<p>思路：<strong>通过map来存储每次访问的结点</strong>，如果有重复，则是链表入口结点。</p>
<h3 id="56-删除链表中重复的结点-B"><a href="#56-删除链表中重复的结点-B" class="headerlink" title="56.删除链表中重复的结点(B)"></a>56.删除链表中重复的结点(B)</h3><blockquote>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
</blockquote>
<p>思路：<strong>需要三个指针</strong>，<strong>第一个指针first的next指向头结点，第二个指针pre指向first，确保每次指向的是重复结点的前一个结点，第三个指针head来遍历</strong>，遇到重复结点，则向后，直到找到当前结点不等于下一个结点时，将pre的next指向head。</p>
<h3 id="57-二叉树的下一个结点-B"><a href="#57-二叉树的下一个结点-B" class="headerlink" title="57.二叉树的下一个结点(B)"></a>57.二叉树的下一个结点(B)</h3><blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>二叉树为空，则返回空；</li>
<li><strong>节点右孩子存在</strong>，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；</li>
<li>节点不是根节点。如果该<strong>节点是其父节点的左孩子</strong>，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</li>
</ol>
<pre><code class="javascript">function GetNext(pNode)
{
    // write code here
    if(pNode==null) return null;
    if(pNode.right!=null) {//节点右孩子存在情况
        pNode=pNode.right;
        while(pNode.left!=null){//沿着向左节点找到叶子节点
            pNode=pNode.left;
        }
        return pNode;
    }
    while(pNode.next!=null){
        var pRoot=pNode.next;
        if(pRoot.left==pNode){
            return pRoot
        }
        pNode=pNode.next;
    }
    return null

}
</code></pre>
<h3 id="58-对称二叉树"><a href="#58-对称二叉树" class="headerlink" title="58.对称二叉树"></a>58.对称二叉树</h3><blockquote>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
</blockquote>
<p>思路：采用递归方法，先判断根节点的左子树和右子树是否为空，同时为空，则返回true，一个为空，则为false。同时不为空，则判断其值是否相等，然后递归判断左子树和右子树的</p>
<h3 id="59-按之字形顺序打印二叉树-B"><a href="#59-按之字形顺序打印二叉树-B" class="headerlink" title="59.按之字形顺序打印二叉树(B)"></a>59.按之字形顺序打印二叉树(B)</h3><blockquote>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
</blockquote>
<p>思路：按深度遍历二叉树，深度（从0开始）为奇数的反转加入数组。</p>
<pre><code class="javascript">function Print(pRoot)
{
    var queue = [];//存储节点队列
    var result = [];
    if(pRoot==null) return result;
    var nextLevel = 0;
    queue.push(pRoot);
    var toBePrinted = 1;//每一行节点个数
    var level = 0;//深度
    var arr = [];
    while(queue.length){
        var temp = queue.shift();
        toBePrinted--;
        arr.push(temp.val);
        if(temp.left){
            queue.push(temp.left);
            nextLevel++;
        }
        if(temp.right){
            queue.push(temp.right);
            nextLevel++;
        }
        if(toBePrinted==0){
            toBePrinted=nextLevel;
            nextLevel=0;
            level++;
            if(level%2==0){
                arr.reverse();
            }
            result.push(arr);
            arr = [];
        }
    }
    return result;
}
</code></pre>
<h3 id="60-把二叉树打印成多行-B"><a href="#60-把二叉树打印成多行-B" class="headerlink" title="60.把二叉树打印成多行(B)"></a>60.把二叉树打印成多行(B)</h3><blockquote>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
</blockquote>
<p>思路：采用队列数据结构，同时需要两个变量分别存储这一层和下一层结点个数。当前层结点个数为零时，则输出结点</p>
<pre><code class="javascript">function Print(pRoot)
{
    // write code here
    var queue = [];//存储节点队列
    var result = [];
    if(pRoot==null) return result;
    var nextLevel = 0;
    queue.push(pRoot);
    var toBePrinted = 1;//每一行节点个数
    var arr = [];
    while(queue.length){
        var temp = queue.shift();
        toBePrinted--;
        arr.push(temp.val);
        if(temp.left){
            queue.push(temp.left);
            nextLevel++;
        }
        if(temp.right){
            queue.push(temp.right);
            nextLevel++;
        }
        if(toBePrinted==0){
            toBePrinted=nextLevel;
            nextLevel=0;
            result.push(arr);
            arr = [];
        }
    }
    return result;
}
</code></pre>
<h3 id="61-序列化二叉树-B"><a href="#61-序列化二叉树-B" class="headerlink" title="61.序列化二叉树(B)"></a>61.序列化二叉树(B)</h3><blockquote>
<p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
</blockquote>
<p>思路：</p>
<ul>
<li>序列化，将节点值存入数组中，空节点则使用特殊标记存入数组中。</li>
<li>反序列化，从数组中获取元素，为number类型则生成节点，为特殊标记，则为空节点</li>
</ul>
<h3 id="62-二叉搜索树的第k个结点-C"><a href="#62-二叉搜索树的第k个结点-C" class="headerlink" title="62.二叉搜索树的第k个结点(C)"></a>62.二叉搜索树的第k个结点(C)</h3><blockquote>
<p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
</blockquote>
<p>思路：二叉搜索树，若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；任意节点的左、右子树也分别为二叉查找树；<br>所以采用<strong>中序遍历</strong>的方法，遍历后的结果就是从小到大顺序的结果</p>
<h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
</blockquote>
<p>思路：排序</p>
<h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}</p>
</blockquote>
<p>思路</p>
<ol>
<li><p>算出<strong>滑动窗口个数=数组元素个数-滑动窗口大小+1</strong>，然后<strong>遍历循环，将队列头元素取出，存入新元素</strong>。</p>
</li>
<li><p>我的思路:</p>
<pre><code class="javascript">arr.push(Math.max.apply(Math,num.slice(i,i+size)));
</code></pre>
</li>
</ol>
<h3 id="65-矩阵中的路径-A"><a href="#65-矩阵中的路径-A" class="headerlink" title="65.矩阵中的路径(A)"></a>65.矩阵中的路径(A)</h3><blockquote>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
</blockquote>
<p>思路：<strong>回溯算法</strong></p>
<p>这是一个可以用回朔法解决的典型题。首先，在矩阵中任选一个格子作为路径的起点。如果路径上的第i个字符不是ch，那么这个格子不可能处在路径上的第i个位置。如果路径上的第i个字符正好是ch，那么往相邻的格子寻找路径上的第i+1个字符。除在矩阵边界上的格子之外，其他格子都有4个相邻的格子。重复这个过程直到路径上的所有字符都在矩阵中找到相应的位置。</p>
<p>由于回朔法的<strong>递归特性</strong>，路径可以被<strong>开成一个栈</strong>。当在矩阵中定位了路径中前n个字符的位置之后，在与第n个字符对应的格子的周围都没有找到第n+1个字符，这个时候只要在路径上回到第n-1个字符，重新定位第n个字符。</p>
<p>由于路径不能重复进入矩阵的格子，<strong>还需要定义和字符矩阵大小一样的布尔值矩阵</strong>，用来标识路径是否已经进入每个格子。 当矩阵中坐标为（row,col）的格子和路径字符串中相应的字符一样时，从4个相邻的格子(row,col-1),(row-1,col),(row,col+1)以及(row+1,col)中去定位路径字符串中下一个字符<br>如果4个相邻的格子都没有匹配字符串中下一个的字符，表明当前路径字符串中字符在矩阵中的定位不正确，我们需要回到前一个，然后重新定位。</p>
<p>一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到合适的位置</p>
<pre><code class="javascript">function hasPath(matrix, rows, cols, path)
{
  function hasPathCore(matrix, rows, cols, row, col, path, pathIndex, visited)      {
    hasPath=hasPathCore(matrix, rows, cols, row - 1, col, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row + 1, col, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row, col - 1, path, pathIndex + 1, visited) ||
            hasPathCore(matrix, rows, cols, row, col + 1, path, pathIndex + 1, visited);
  }
}
</code></pre>
<h3 id="66-机器人的运动范围-A"><a href="#66-机器人的运动范围-A" class="headerlink" title="66.机器人的运动范围(A)"></a>66.机器人的运动范围(A)</h3><blockquote>
<p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
</blockquote>
<p>思路：<strong>回溯算法</strong></p>
<pre><code class="javascript">function movingCount(threshold, rows, cols)
{
  function movingCountSum(threshold,m,n,rows,cols,visited)
  {
    if(m&gt;=0&amp;&amp;m&lt;rows&amp;&amp;n&gt;=0&amp;&amp;n&lt;cols&amp;&amp;!visited[m][n]&amp;&amp;getSum(m,n)&lt;=threshold)
    {
        visited[m][n]=true;
        count = 1+movingCountSum(threshold,m,n-1,rows,cols,visited)+
                movingCountSum(threshold,m,n+1,rows,cols,visited)+
                movingCountSum(threshold,m-1,n,rows,cols,visited)+
                movingCountSum(threshold,m+1,n,rows,cols,visited);
    }
  }
}
</code></pre>
<h2 id="二刷"><a href="#二刷" class="headerlink" title="二刷"></a>二刷</h2><h3 id="2-替换空格-B-1"><a href="#2-替换空格-B-1" class="headerlink" title="2.替换空格(B)"></a>2.替换空格(B)</h3><blockquote>
<p>\s+代表多个空格，？则表示取尽可能少的空格</p>
</blockquote>
<h3 id="4-重建二叉树-B-1"><a href="#4-重建二叉树-B-1" class="headerlink" title="4.重建二叉树(B)"></a>4.重建二叉树(B)</h3><h3 id="11-二进制中1的个数-B"><a href="#11-二进制中1的个数-B" class="headerlink" title="11.二进制中1的个数(B)"></a>11.二进制中1的个数(B)</h3><h3 id="12-数值的整数次方-B"><a href="#12-数值的整数次方-B" class="headerlink" title="12.数值的整数次方(B)"></a>12.数值的整数次方(B)</h3><h3 id="16-合并两个排序的链表-A"><a href="#16-合并两个排序的链表-A" class="headerlink" title="16.合并两个排序的链表(A)"></a>16.合并两个排序的链表(A)</h3><pre><code class="javascript">function Merge(pHead1, pHead2)
{
    if(pHead1==null) return pHead2;
    if(pHead2==null) return pHead1;

    if(pHead1.val &lt;= pHead2.val)
    {
        pHead1.next = Merge(pHead1.next,pHead2);
        return pHead1;
    }
    else
    {
        pHead2.next = Merge(pHead1,pHead2.next);
        return pHead2;
    }
}
</code></pre>
<h3 id="17-树的子结构-B"><a href="#17-树的子结构-B" class="headerlink" title="17.树的子结构(B)"></a>17.树的子结构(B)</h3><blockquote>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
</blockquote>
<p>思路：比较B是不是A的子树，B是不是A的右子树的子树，B是不是A的左子树的子树。如果根元素相同，则开始判断左子树和右子树</p>
<blockquote>
<p>注意：</p>
<p>isSubtree中pRoot2要在pRoot1上面判断</p>
</blockquote>
<pre><code class="javascript">function isSubtree(pRoot1,pRoot2){
    if (pRoot2 == null) return true;//pRoot2为null，表示子树已经遍历完
    if (pRoot1 == null) return false;
    if(pRoot1.val==pRoot2.val){
        return isSubtree(pRoot1.left,pRoot2.left) &amp;&amp; isSubtree(pRoot1.right,pRoot2.right);
    }else{
        return false;
    }
}

function HasSubtree(pRoot1, pRoot2)
{
    if(pRoot1==null||pRoot2==null) return false;   
    return isSubtree(pRoot1,pRoot2)||HasSubtree(pRoot1.left,pRoot2)||HasSubtree(pRoot1.right,pRoot2);
}
</code></pre>
<h3 id="18-二叉树镜像-B"><a href="#18-二叉树镜像-B" class="headerlink" title="18.二叉树镜像(B)"></a>18.二叉树镜像(B)</h3><pre><code class="javascript">function Mirror(root)
{
    if(root == null) return;
    var left = Mirror(root.left);
    var right = Mirror(root.right);
    root.left = right;
    root.right = left;
    return root;
}
</code></pre>
<h3 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵(?)"></a>19.顺时针打印矩阵(?)</h3><h3 id="21-栈的压入、弹出-B"><a href="#21-栈的压入、弹出-B" class="headerlink" title="21.栈的压入、弹出(B)"></a>21.栈的压入、弹出(B)</h3><p>思路：设置辅助栈，压入元素，<strong>判断栈顶元素是否等于出栈第一个，相同则出栈</strong>，不同则继续入栈</p>
<h3 id="22-从上往下打印二叉树-B"><a href="#22-从上往下打印二叉树-B" class="headerlink" title="22.从上往下打印二叉树(B)"></a>22.从上往下打印二叉树(B)</h3><blockquote>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
</blockquote>
<p>思路：采用<strong>队列</strong>方法，先将<strong>根节点放入队列</strong>中，然后打印，接着<strong>将左右节点加入队列</strong>中。</p>
<pre><code class="javascript">while (queue.length) {
  var temp = queue.shift();
  result.push(temp.val);
  if (temp.left) {
    queue.push(temp.left);
  }
  if (temp.right) {
    queue.push(temp.right);
  }
}
</code></pre>
<h3 id="23-二叉搜索树的后序遍历-A-1"><a href="#23-二叉搜索树的后序遍历-A-1" class="headerlink" title="23.二叉搜索树的后序遍历(A)"></a>23.二叉搜索树的后序遍历(A)</h3><h3 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h3><h3 id="25-复杂链表的复制-B"><a href="#25-复杂链表的复制-B" class="headerlink" title="25.复杂链表的复制(B)"></a>25.复杂链表的复制(B)</h3><h3 id="26-二叉搜索树与双向链表-A-1"><a href="#26-二叉搜索树与双向链表-A-1" class="headerlink" title="26.二叉搜索树与双向链表(A)"></a>26.二叉搜索树与双向链表(A)</h3><h3 id="27-字符串排列-A"><a href="#27-字符串排列-A" class="headerlink" title="27.字符串排列(A)"></a>27.字符串排列(A)</h3><h3 id="32-把数组排成最小的数-C"><a href="#32-把数组排成最小的数-C" class="headerlink" title="32.把数组排成最小的数(C)"></a>32.把数组排成最小的数(C)</h3><h3 id="35-数组中的逆序对-A-1"><a href="#35-数组中的逆序对-A-1" class="headerlink" title="35.数组中的逆序对(A)"></a>35.数组中的逆序对(A)</h3><h3 id="56-删除链表中重复的结点-B-1"><a href="#56-删除链表中重复的结点-B-1" class="headerlink" title="56.删除链表中重复的结点(B)"></a>56.删除链表中重复的结点(B)</h3>]]></content>
      
        <categories>
            
            <category> 算法题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5总结]]></title>
      <url>/2017/01/01/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/HTML/HTML5/</url>
      <content type="html"><![CDATA[<p>总结H5。后续补上demo。</p>
<a id="more"></a>
<h1 id="提纲"><a href="#提纲" class="headerlink" title="提纲"></a>提纲</h1><ul>
<li>HTML5概念</li>
<li>多媒体</li>
<li>拖放</li>
<li>Canvas &amp; SVG</li>
<li>地理定位</li>
<li>Web存储</li>
<li>应用缓存</li>
<li>Web Workers</li>
<li>服务器发送事件</li>
<li>表单</li>
<li>Hisyory API</li>
</ul>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="HTML5概念"><a href="#HTML5概念" class="headerlink" title="HTML5概念"></a>HTML5概念</h2><h3 id="什么是HTML5"><a href="#什么是HTML5" class="headerlink" title="什么是HTML5"></a>什么是HTML5</h3><p>最新的HTML标准，主要目标是提供所有内容而不需要任何的像flash，silverlight等的额外插件</p>
<h3 id="SGML、XML、HTML关系"><a href="#SGML、XML、HTML关系" class="headerlink" title="SGML、XML、HTML关系"></a>SGML、XML、HTML关系</h3><p>SGML（标准通用标记语言）是一个标准，告诉我们怎么去指定文档标记。他是只描述文档标记应该是怎么样的元语言，HTML（超文本标记语言）是被用SGML描述的标记语言。</p>
<p>因此利用SGML创建了HTML参照和必须共同遵守的DTD（文档类型定义），你会经常在HTML页面的头部发现“DOCTYPE”属性，用来定义用于解析目标DTD</p>
<p>XML（可扩展标记语言）使用了SGML，例如：在SGML中你必须使用起始和结束标签，但是在XML你可以有自动关闭的结束标签。</p>
<p>XHTML创建于XML，他被使用在HTML4.0中。</p>
<p>总之，SGML是所有类型的父类，较旧的HTML利用SGML，HTML4.0使用派生自XML的XHTML</p>
<h3 id="为什么HTML5不需要DTD"><a href="#为什么HTML5不需要DTD" class="headerlink" title="为什么HTML5不需要DTD"></a>为什么HTML5不需要DTD</h3><p>HTML5没有使用SGML或者XHTML</p>
<h3 id="HTML5的页面结构变化"><a href="#HTML5的页面结构变化" class="headerlink" title="HTML5的页面结构变化"></a>HTML5的页面结构变化</h3><p>一个典型的WEB页面包含头部，脚部，导航，中心区域，侧边栏。HTML4要使用DIV标签。HTML5中为这些区域创建元素名称：<code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>等</p>
<h3 id="HTML5-文档类型和字符集"><a href="#HTML5-文档类型和字符集" class="headerlink" title="HTML5 文档类型和字符集"></a>HTML5 文档类型和字符集</h3><pre><code class="html">&lt;!doctype html&gt;
&lt;meta charset=”UTF-8″&gt;
</code></pre>
<h3 id="废弃的标签"><a href="#废弃的标签" class="headerlink" title="废弃的标签"></a>废弃的标签</h3><ul>
<li>frame</li>
<li>frameset</li>
<li>noframe</li>
<li>applet</li>
<li>big</li>
<li>center</li>
<li>basefront</li>
</ul>
<h3 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h3><ul>
<li>Media API</li>
<li>Text Track API</li>
<li>Application Cache API</li>
<li>User Interaction</li>
<li>Data Transfer API</li>
<li>Command API</li>
<li>Constraint Validation API</li>
<li>History API</li>
</ul>
<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><h3 id="嵌入音频"><a href="#嵌入音频" class="headerlink" title="嵌入音频"></a>嵌入音频</h3><pre><code class="html">&lt;audio controls&gt;
    &lt;source src=”jamshed.mp3″ type=”audio/mpeg”&gt;
    Your browser does’nt support audio embedding feature.
&lt;/audio&gt;
</code></pre>
<h3 id="嵌入视频"><a href="#嵌入视频" class="headerlink" title="嵌入视频"></a>嵌入视频</h3><pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
  &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
   Your browser does’nt support video embedding feature.
&lt;/video&gt;
</code></pre>
<h3 id="其他媒体标签"><a href="#其他媒体标签" class="headerlink" title="其他媒体标签"></a>其他媒体标签</h3><p><code>&lt;embed&gt;</code> 标签定义嵌入的内容，比如插件</p>
<pre><code class="html">&lt;embed type=”video/quicktime” src=”Fishing.mov”&gt;
</code></pre>
<p><code>&lt;source&gt;</code> 对于定义多个数据源很有用</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
&lt;/video&gt;
</code></pre>
<p><code>&lt;track&gt;</code> 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code class="html">&lt;video width=”450″ height=”340″ controls&gt;
     &lt;source src=”jamshed.mp4″ type=”video/mp4″&gt;
     &lt;source src=”jamshed.ogg” type=”video/ogg”&gt;
     &lt;track kind=”subtitles” label=”English” src=”jamshed_en.vtt” srclang=”en” default&gt;&lt;/track&gt;
      &lt;track kind=”subtitles” label=”Arabic” src=”jamshed_ar.vtt” srclang=”ar”&gt;&lt;/track&gt;
&lt;/video&gt;
</code></pre>
<h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function allowDrop(ev)
{
  ev.preventDefault();
}

function drag(ev)
{
  ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
}

function drop(ev)
{
  ev.preventDefault();
  var data=ev.dataTransfer.getData(&quot;Text&quot;);
  ev.target.appendChild(document.getElementById(data));
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p><strong>设置元素为可拖放 - draggable</strong></p>
<p>draggable 属性设置为 true </p>
<p><strong>拖动什么 - ondragstart 和 setData()</strong></p>
<p>ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。</p>
<p>dataTransfer.setData() 方法设置被拖数据的数据类型和值</p>
<p><strong>放到何处 - ondragover</strong></p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<pre><code class="javascript">event.preventDefault()
</code></pre>
<p><strong>进行放置 - ondrop</strong></p>
<p>ondrop 属性调用了一个函数，drop(<em>event</em>)</p>
<h2 id="Canvas-amp-SVG"><a href="#Canvas-amp-SVG" class="headerlink" title="Canvas &amp; SVG"></a>Canvas &amp; SVG</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><h4 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h4><h5 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h5><pre><code class="javascript">&lt;canvas id=&quot;myCanvas&quot; width=&quot;400&quot; height=&quot;200&quot;&gt;
  您的浏览器不支持canvas！
&lt;/canvas&gt;

var canvas = document.getElementById(&#39;myCanvas&#39;);
if (canvas.getContext) {
  var ctx = canvas.getContext(&#39;2d&#39;);
}

//（1）绘制路径
ctx.beginPath(); // 开始路径绘制
ctx.moveTo(20, 20); // 设置路径起点，坐标为(20,20)
ctx.lineTo(200, 20); // 绘制一条到(200,20)的直线
ctx.lineWidth = 1.0; // 设置线宽
ctx.strokeStyle = &#39;#CC0000&#39;; // 设置线的颜色
ctx.stroke(); // 进行线的着色，这时整条线才变得可见
//最后，还可以使用closePath方法，自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。

//（2）绘制矩形
//实心矩形
ctx.fillStyle = &#39;yellow&#39;;
ctx.fillRect(50, 50, 200, 100); 
//空心矩形
ctx.strokeRect(10,10,200,100);
//清除某个矩形区域的内容
ctx.clearRect(100,50,50,50);  

//（3）绘制文本
// 设置字体
ctx.font = &quot;Bold 20px Arial&quot;; 
// 设置对齐方式
ctx.textAlign = &quot;left&quot;;
// 设置填充颜色
ctx.fillStyle = &quot;#008600&quot;; 
// 设置字体内容，以及在画布上的位置,绘制文本,不支持文本断行
ctx.fillText(&quot;Hello!&quot;, 10, 50); 
// 绘制空心字
ctx.strokeText(&quot;Hello!&quot;, 10, 100); 

//（4）绘制圆形和扇形
//绘制扇形,startAngle和endAngle则是扇形的起始角度和终止角度（以弧度表示），anticlockwise表示做图时应该逆时针画（true）还是顺时针画（false）
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);
//绘制实心的圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.fillStyle = &quot;#000&quot;; 
ctx.fill();
//绘制空心圆形
ctx.beginPath(); 
ctx.arc(60, 60, 50, 0, Math.PI*2, true); 
ctx.lineWidth = 1.0; 
ctx.strokeStyle = &quot;#000&quot;; 
ctx.stroke();

//（5）设置渐变色
var myGradient = ctx.createLinearGradient(0, 0, 0, 160); 
myGradient.addColorStop(0, &quot;#BABABA&quot;); 
myGradient.addColorStop(1, &quot;#636363&quot;);
//使用方法如下：
ctx.fillStyle = myGradient;
ctx.fillRect(10,10,200,100);

//（6）设置阴影
ctx.shadowOffsetX = 10; // 设置水平位移
ctx.shadowOffsetY = 10; // 设置垂直位移
ctx.shadowBlur = 5; // 设置模糊度
ctx.shadowColor = &quot;rgba(0,0,0,0.5)&quot;; // 设置阴影颜色
ctx.fillStyle = &quot;#CC0000&quot;; 
ctx.fillRect(10,10,200,100)
</code></pre>
<h5 id="图像处理方法"><a href="#图像处理方法" class="headerlink" title="图像处理方法"></a>图像处理方法</h5><pre><code class="javascript">//drawImage方法:将图像文件插入画布,drawImage方法只能在图像完全载入后才能调用
var image = new Image();
image.onload = function() {
  var canvas = document.createElement(&#39;canvas&#39;);
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext(&#39;2d&#39;).drawImage(image, 0, 0);
  // 插入页面底部
  document.body.appendChild(image);
  return canvas;
}
image.src = &#39;image.png&#39;;

//getImageData方法，putImageData方法:读取Canvas的内容，返回一个对象，包含了每个像素的信息。该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度等于 图像的像素宽度 x 图像的像素高度 x 4，每个值的范围是0–255。这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用putImageData方法将数组内容重新绘制在Canvas上。
var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
context.putImageData(imageData, 0, 0);

//toDataURL方法:将Canvas数据重新转化成一般的图像文件形式。
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL(&#39;image/png&#39;);
  return image;
}

//save方法，restore方法:save方法用于保存上下文环境，restore方法用于恢复到上一次保存的上下文环境。
ctx.save();
ctx.fillStyle = &#39;#CC0000&#39;;
ctx.fillRect(10,10,150,100);
ctx.restore();
ctx.fillStyle = &#39;#000000&#39;;
ctx.fillRect(180,10,150,100);
</code></pre>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p><a href="http://blog.csdn.net/gertyy/article/details/53637951" target="_blank" rel="external">Canvas API 详解</a></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="Canvas和SVG"><a href="#Canvas和SVG" class="headerlink" title="Canvas和SVG"></a>Canvas和SVG</h4><h5 id="什么是SVG？"><a href="#什么是SVG？" class="headerlink" title="什么是SVG？"></a>什么是SVG？</h5><p>SVG（Scalable Vector Graphics可缩放矢量图形）表示可缩放矢量图形。他是基于文本的图形语言，使用文本，线条，点等来进行图像绘制，这使得他轻便，显示更加迅速</p>
<pre><code class="html">&lt;svg id=&quot;svgelem&quot; height=&quot;[object SVGAnimatedLength]&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
&lt;line style=&quot;stroke: rgb(255, 0, 0); stroke-width: 2px;&quot; y2=&quot;[object SVGAnimatedLength]&quot; x2=&quot;[object SVGAnimatedLength]&quot; y1=&quot;[object SVGAnimatedLength]&quot; x1=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/line&gt;
</code></pre>
<h5 id="Canvas和SVG图形的区别是什么？"><a href="#Canvas和SVG图形的区别是什么？" class="headerlink" title="Canvas和SVG图形的区别是什么？"></a>Canvas和SVG图形的区别是什么？</h5><table>
<thead>
<tr>
<th>SVG</th>
<th>Canvas</th>
</tr>
</thead>
<tbody>
<tr>
<td>这个就好像绘制和记忆，换句话说任何使用SVG绘制的形状都能被记忆和操作，浏览器可以再次显示</td>
<td>Canvas就像绘制和忘记，一旦绘制完成你不能访问像素和操作它</td>
</tr>
<tr>
<td>SVG对于创建图形例如CAD软件是良好的，一旦东西绘制，用户就想去操作它</td>
<td>Canvas在绘制和忘却的场景例如动画和游戏是良好的</td>
</tr>
<tr>
<td>因为为了之后的操作，需要记录坐标，所以比较缓慢</td>
<td>因为没有记住以后事情的意向，所以更快</td>
</tr>
<tr>
<td>我们可以用绘制对象的相关事件处理</td>
<td>我们不能使用绘制对象的相关事件处理，因为我们没有他们的参考</td>
</tr>
<tr>
<td>分辨率无关</td>
<td>分辨率相关</td>
</tr>
</tbody>
</table>
<h4 id="Canvas使用"><a href="#Canvas使用" class="headerlink" title="Canvas使用"></a>Canvas使用</h4><h5 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h5><ul>
<li>定义Canvas区域</li>
<li>获取访问canvas上下文区域</li>
<li>绘制图形</li>
</ul>
<pre><code class="html">&lt;body  onload=&quot;DrawMe();&quot;&gt;
&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border:1px solid #000000;&quot;&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;script&gt;
function DrawMe()
{
  var c=document.getElementById(&quot;mycanvas&quot;);
  var ctx=c.getContext(&quot;2d&quot;);
  ctx.moveTo(10,10);
  ctx.lineTo(200,100);
  ctx.stroke();
}
</code></pre>
<h5 id="Canvas和SVG画矩形"><a href="#Canvas和SVG画矩形" class="headerlink" title="Canvas和SVG画矩形"></a>Canvas和SVG画矩形</h5><p>SVG绘制矩形</p>
<pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;rect style=&quot;fill: rgb(0, 0, 255); stroke-width: 1px; stroke: rgb(0, 0, 0);&quot; height=&quot;[object SVGAnimatedLength]&quot; width=&quot;[object SVGAnimatedLength]&quot;&gt;
&lt;/rect&gt;
</code></pre>
<p>Canvas绘制矩形</p>
<pre><code class="javascript">var c=document.getElementById(&quot;mycanvas&quot;);
var ctx=c.getContext(&quot;2d&quot;);
ctx.rect(20,20,150,100);
ctx.stroke();
</code></pre>
<h2 id="地理定位"><a href="#地理定位" class="headerlink" title="地理定位"></a><a href="http://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="external">地理定位</a></h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p>getCurrentPosition() 方法</p>
<pre><code class="javascript">navigator.geolocation.getCurrentPosition(showPosition);
</code></pre>
<p>getCurrentPosition() 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数</p>
<h2 id="Web存储"><a href="#Web存储" class="headerlink" title="Web存储"></a>Web存储</h2><h3 id="localStorage的特点"><a href="#localStorage的特点" class="headerlink" title="localStorage的特点"></a>localStorage的特点</h3><ol>
<li>localStorage拓展了cookie的4K限制。</li>
</ol>
<ol>
<li><p>数据直接存储到本地，5M大小，相比于cookie可以节约带宽。</p>
<p>注意：遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage</p>
</li>
<li><p>localStorage只支持string类型的存储。</p>
</li>
</ol>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code class="javascript">//添加
localStorage[&quot;a&quot;]=1;
localStorage.b=1;
localStorage.setItem(“c”,”India”);

//读取
var a = localStorage[&quot;a&quot;];
var b = localStorage.b;
var country = localStorage.getItem(“Key001”);

//改
localStorage[&quot;a&quot;]=2;

//删
localStorage.clear();    //全删
localStorage.removeItem(&quot;a&quot;);    //部分删

//获取键值
for(i=0;i&lt;localStorage.length;i++){
  var key=localStorage.key(i);
}
</code></pre>
<p>可以存JSON,注意<strong>stringify</strong> 和 <strong>parse</strong></p>
<pre><code class="javascript">var data={
  name:&#39;xiecanyong&#39;,
  sex:&#39;man&#39;,
  hobby:&#39;program&#39;
};

var d=JSON.stringify(data);

storage.setItem(&quot;data&quot;,d);

//将JSON字符串转换成为JSON对象输出
var json=storage.getItem(&quot;data&quot;);
var jsonObj=JSON.parse(json);
</code></pre>
<h3 id="本地存储和cookies区别"><a href="#本地存储和cookies区别" class="headerlink" title="本地存储和cookies区别"></a>本地存储和cookies区别</h3><table>
<thead>
<tr>
<th></th>
<th>Cookies</th>
<th>Local storage</th>
</tr>
</thead>
<tbody>
<tr>
<td>客户端/服务端</td>
<td>客户端和服务端都能访问数据。Cookie的数据通过每一个请求发送到服务端</td>
<td>只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器</td>
</tr>
<tr>
<td>大小</td>
<td>每个cookie有4K</td>
<td>每个域5MB</td>
</tr>
<tr>
<td>过期</td>
<td>Cookies有有效期，所以在过期之后cookie和cookie数据会被删除</td>
<td>没有过期数据，无论最后用户从浏览器删除或者使用Javascript程序删除，我们都需要删除</td>
</tr>
</tbody>
</table>
<h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a><a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="external">知识点</a></h3><h4 id="应用缓存是什么"><a href="#应用缓存是什么" class="headerlink" title="应用缓存是什么"></a>应用缓存是什么</h4><p>应用缓存可以帮助你指定哪些文件需要缓存，哪些不需要。</p>
<h4 id="应用程序缓存优势"><a href="#应用程序缓存优势" class="headerlink" title="应用程序缓存优势"></a>应用程序缓存优势</h4><ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li>
</ul>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>首先我们需要指定”manifest”文件，Mainfest文件的内容类型应是“text/cache-manifest”.</p>
<pre><code class="http">CACHE MANIFEST
# version 1.0
CACHE :
Login.aspx
</code></pre>
<pre><code class="php">Response.ContentType = &quot;text/cache-manifest&quot;;
Response.Write(&quot;CACHE MANIFEST \n&quot;);
Response.Write(&quot;# 2012-02-21 v1.0.0 \n&quot;);
Response.Write(&quot;CACHE : \n&quot;);
Response.Write(&quot;Login.aspx \n&quot;);
Response.Flush();
Response.End();
</code></pre>
<p>创建一个缓存manifest文件以后，接下来的事情实在HTML页面中提供mainfest连接</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="应用缓存中的回退是什么"><a href="#应用缓存中的回退是什么" class="headerlink" title="应用缓存中的回退是什么"></a>应用缓存中的回退是什么</h4><p>应用缓存中的回退帮助你指定在服务器不可访问的时候，将会显示某文件。例如在下面的manifest文件中，我们说如果谁敲击了”/home”同时服务器不可到达的时候，”homeoffline.html”文件应送达</p>
<pre><code class="http">FALLBACK:
/home/ /homeoffline.html
</code></pre>
<h4 id="应用缓存中的网络是什么"><a href="#应用缓存中的网络是什么" class="headerlink" title="应用缓存中的网络是什么"></a>应用缓存中的网络是什么</h4><p>网络命令描述不需要缓存的文件，例如以下代码中，我们说”home.aspx”永远都不应该被缓存或者离线访问。</p>
<pre><code class="http">NETWORK:
home.aspx
</code></pre>
<h4 id="应用程序缓存和浏览器缓存有什么区别"><a href="#应用程序缓存和浏览器缓存有什么区别" class="headerlink" title="应用程序缓存和浏览器缓存有什么区别"></a>应用程序缓存和浏览器缓存有什么区别</h4><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><h4 id="什么是Web-Workers，有什么用"><a href="#什么是Web-Workers，有什么用" class="headerlink" title="什么是Web Workers，有什么用"></a>什么是Web Workers，有什么用</h4><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。帮助我们用异步执行Javascript文件</p>
<h4 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>除了 Internet Explorer</p>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><h5 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h5><pre><code class="javascript">if(typeof(Worker)!==&quot;undefined&quot;)
{
  // Yes! Web worker support!
  // Some code.....
}
else
{
  // Sorry! No Web Worker support..
}
</code></pre>
<h5 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h5><p><strong>主线程</strong>通过Javascript文件名创建<strong>worker</strong>对象</p>
<pre><code class="javascript">var worker = new Worker(&quot;MyHeavyProcess.js&quot;);
</code></pre>
<p><strong>子线程</strong>需要使用“<strong>PostMessage</strong>”发送信息给worker对象</p>
<pre><code class="javascript">worker.postMessage();
</code></pre>
<p><strong>主线程</strong>当worker线程发送数据的时候，我们在调用结束的时候，通过”<strong>onMessage</strong>”事件获取</p>
<pre><code class="javascript">worker.onmessage = function (e) 
{
document.getElementById(&quot;txt1&quot;).value = e.data;
};
</code></pre>
<p>出错处理。<strong>onerror</strong>监听，错误消息可以通过<strong>e.message</strong>来获取。</p>
<h5 id="如何中止"><a href="#如何中止" class="headerlink" title="如何中止"></a>如何中止</h5><p><strong>主线程</strong>。注意：一旦terminate后，无法重新启用，只能另外创建。</p>
<pre><code class="javascript">w.terminate();
</code></pre>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h4 id="Web-Worker线程的限制是什么"><a href="#Web-Worker线程的限制是什么" class="headerlink" title="Web Worker线程的限制是什么"></a>Web Worker线程的限制是什么</h4><p>Web worker线程不能修改HTML元素，全局变量和Window.Location一类的窗口属性。可以自由使用Javascript数据类型，XMLHttpRequest调用等。</p>
<p>简而言之，就是<strong>允许JavaScript创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</strong>。</p>
<blockquote>
<p>原因：worker.js执行的上下文，与主页面html执行时的上下文并不相同，最顶层的对象并不是window，woker.js执行的全局上下文，是个叫做<strong>WorkerGlobalScope</strong>的东西，所以无法访问window、与window相关的DOM API，但是可以与setTimeout、setInterval等协作。</p>
</blockquote>
<h2 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h2><h3 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h3><h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><h5 id="EventSource，onmessage"><a href="#EventSource，onmessage" class="headerlink" title="EventSource，onmessage"></a>EventSource，onmessage</h5><pre><code class="javascript">var source=new EventSource(&quot;demo_sse.php&quot;);

source.onmessage=function(event){
  document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;;
};
</code></pre>
<h5 id="服务器端代码实例"><a href="#服务器端代码实例" class="headerlink" title="服务器端代码实例"></a>服务器端代码实例</h5><p><strong>把 “Content-Type” 报头设置为 “text/event-stream”。</strong></p>
<h5 id="ASP-代码-VB-demo-sse-asp"><a href="#ASP-代码-VB-demo-sse-asp" class="headerlink" title="ASP 代码 (VB) (demo_sse.asp):"></a>ASP 代码 (VB) (demo_sse.asp):</h5><pre><code class="asp">&lt;%
Response.ContentType=&quot;text/event-stream&quot;
Response.Expires=-1
Response.Write(&quot;data: &quot; &amp; now())
Response.Flush()
%&gt;
</code></pre>
<h5 id="EventSource-对象"><a href="#EventSource-对象" class="headerlink" title="EventSource 对象"></a>EventSource 对象</h5><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onopen</td>
<td>当通往服务器的连接被打开</td>
</tr>
<tr>
<td>onmessage</td>
<td>当接收到消息</td>
</tr>
<tr>
<td>onerror</td>
<td>当错误发生</td>
</tr>
</tbody>
</table>
<h4 id="浏览器支持-1"><a href="#浏览器支持-1" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><p>除了IE。</p>
<h2 id="WebSQL"><a href="#WebSQL" class="headerlink" title="WebSQL"></a>WebSQL</h2><h3 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h3><h4 id="什么是WebSQL"><a href="#什么是WebSQL" class="headerlink" title="什么是WebSQL"></a>什么是WebSQL</h4><p>WebSQL是一个在浏览器客户端的结构关系数据库，这是浏览器内的本地RDBMS(关系型数据库系统)，你可以使用SQL查询</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>第一步我们需要做的是使用如下所示的“OpenDatabase”方法打开数据库</p>
<pre><code class="javascript">var db=openDatabase(&#39;dbCustomer&#39;,&#39;1.0&#39;,&#39;Customer app’, 2 * 1024 * 1024);
</code></pre>
<p>为了执行SQL，我们需要使用“transaction”方法，并调用”executeSql”方法来使用SQL</p>
<pre><code class="javascript">db.transaction(function (tx) 
{
  tx.executeSql(&#39;CREATE TABLE IF NOT EXISTS tblCust(id unique, customername)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES(1, &quot;shiv&quot;)&#39;);
  tx.executeSql(&#39;INSERT INTO tblcust (id, customername) VALUES (2, &quot;raju&quot;)&#39;);
  tx.executeSql(&#39;SELECT * FROM tblcust&#39;, [], function (tx, results) {
   for (i = 0; i &lt; len; i++)
    {
     msg = &quot;&lt;p&gt;&lt;b&gt;&quot; + results.rows.item(i).log + &quot;&lt;/b&gt;&lt;/p&gt;&quot;;
     document.querySelector(&#39;#customer).innerHTML +=  msg;
    }
 }, null);
});
</code></pre>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><h4 id="WebSql是HTML5的一个规范吗"><a href="#WebSql是HTML5的一个规范吗" class="headerlink" title="WebSql是HTML5的一个规范吗"></a>WebSql是HTML5的一个规范吗</h4><p>不是，许多人把它标记为HTML5，但是他不是HTML5的规范的一部分，这个规范是基于SQLite的</p>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><h3 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h3><h4 id="浏览器支持-2"><a href="#浏览器支持-2" class="headerlink" title="浏览器支持"></a>浏览器支持</h4><pre><code class="javascript">return !!(window.history &amp;&amp; history.pushState);
</code></pre>
<h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><h5 id="两个新方法"><a href="#两个新方法" class="headerlink" title="两个新方法"></a>两个新方法</h5><p>history.pushState(); 和 history.replaceState();</p>
<p>两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。</p>
<p>pushState()和replaceState()参数一样，参数说明如下：</p>
<ol>
<li>state：存储JSON字符串，可以用在popstate事件中。</li>
<li>title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替</li>
<li>url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。</li>
</ol>
<h5 id="history对象常见用法"><a href="#history对象常见用法" class="headerlink" title="history对象常见用法"></a>history对象常见用法</h5><ul>
<li>history.back();//返回上一页，相当于浏览器上后退功能。</li>
<li>history.forward();//去到下一页，相当于浏览器的前进功能。</li>
<li>histoty.go(int);//去到指定的浏览历史记录页面。int是正的时候，就是向前int个历史记录，如果没有那么多，就没有行为。int是负数的时候那么就会向后，为0页面即没有任何变化。</li>
</ul>
<h2 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h2><h3 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h3><h4 id="keygen-元素"><a href="#keygen-元素" class="headerlink" title="keygen 元素"></a>keygen 元素</h4><p>keygen 元素的作用是提供一种验证用户的可靠方法。</p>
<h4 id="新的表单属性"><a href="#新的表单属性" class="headerlink" title="新的表单属性"></a>新的表单属性</h4><h5 id="新的-form-属性"><a href="#新的-form-属性" class="headerlink" title="新的 form 属性"></a>新的 form 属性</h5><ul>
<li>autocomplete</li>
<li>novalidate</li>
</ul>
<h5 id="新的-input-属性"><a href="#新的-input-属性" class="headerlink" title="新的 input 属性"></a>新的 input 属性</h5><ul>
<li>autocomplete</li>
<li>autofocus</li>
<li>form</li>
<li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li>
<li>height 和 width</li>
<li>list</li>
<li>min, max 和 step</li>
<li>multiple</li>
<li>pattern (regexp)</li>
<li>placeholder</li>
<li>required</li>
</ul>
<h4 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h4><p>HTML5中的Datalist元素有助于提供文本框自动完成特性</p>
<p>datalist 元素规定输入域的选项列表。列表是通过 datalist 内的 option 元素创建的。</p>
<p>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id：</p>
<pre><code class="html">&lt;input list=&quot;Country&quot;&gt;
&lt;datalist id=&quot;Country&quot;&gt;
  &lt;option value=&quot;India&quot;&gt;
  &lt;option value=&quot;Italy&quot;&gt;
  &lt;option value=&quot;Iran&quot;&gt;
  &lt;option value=&quot;Israel&quot;&gt;
  &lt;option value=&quot;Indonesia&quot;&gt;
&lt;/datalist&gt;
</code></pre>
<blockquote>
<p>提示：option 元素永远都要设置 value 属性。</p>
</blockquote>
<h4 id="新的表单元素"><a href="#新的表单元素" class="headerlink" title="新的表单元素"></a>新的表单元素</h4><ol>
<li>Color</li>
<li>Date</li>
<li>Datetime-local</li>
<li>Email</li>
<li>Time</li>
<li>Url</li>
<li>Range</li>
<li>Telephone</li>
<li>Number</li>
<li>Search</li>
</ol>
<pre><code class="html">如果你想显示颜色选择对话框
&lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;

如果你想显示日历对话框
&lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt;

如果你想显示含有本地时间的日历
&lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;

如果你想创建一个含有email校验的HTML文本框，我们可以设置类型为“email”
&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;

对于URL验证设置类型为”url”
&lt;input type=&quot;url&quot; name=&quot;sitename&quot;&gt;

如果你想限定数字范围，你可以设置类型为“number”
&lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;

如果你想显示范围控制，你可以使用类型”range”
&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot; value=&quot;6&quot;&gt;

想让文本框作为搜索引擎
&lt;input type=&quot;search&quot; name=&quot;googleengine&quot;&gt;

想只能输入时间
&lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;

如果你想使用文本框接受电话号码
&lt;input type=&quot;tel&quot; name=&quot;mytel&quot;&gt;
</code></pre>
<h4 id="输出元素"><a href="#输出元素" class="headerlink" title="输出元素"></a>输出元素</h4><p>当你需要计算两个输入的和值到一个标签中的时候你需要输出元素。</p>
<p>例如你有两个文本框，你想将来自这两个输入框中的数字求和并放到标签中。</p>
<pre><code class="html">&lt;form onsubmit=&quot;return false&quot;  oninput=&quot;o.value = parseInt(a.value) + parseInt(b.value)&quot;&gt;
  &lt;input name=&quot;a&quot; type=&quot;number&quot;&gt; +
  &lt;input name=&quot;b&quot; type=&quot;number&quot;&gt; =
  &lt;output name=&quot;o&quot; /&gt;
&lt;/form&gt;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 大前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速搭建Hexo]]></title>
      <url>/2016/10/01/Hexo/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是提醒自己半年更一次博客忘了要怎么做。当然如果想<strong>迅速</strong>建站，可是可以参考的。</p>
<a id="more"></a>
<h1 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h1><p>首先需要搭建hexo，包括：</p>
<ul>
<li>安装node.js</li>
<li>安装Hexo</li>
<li>后期部署</li>
<li>hexo配置</li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><pre><code class="shell">npm install -g hexo-cli --no-optional
npm install hexo-deployer-git --save
cd ~/Document/hexo
hexo init
npm install
</code></pre>
<h2 id="后期部署"><a href="#后期部署" class="headerlink" title="后期部署"></a>后期部署</h2><pre><code>hexo new &quot;blogName&quot;        //添加文章
hexo new page &quot;pageName&quot; #新建页面
hexo clean
hexo algolia    //algolia搜索
hexo 

hexo generate    //生成静态页面
hexo sever        //本地启动
hexo deploy        //同步到github
</code></pre><h2 id="hexo配置"><a href="#hexo配置" class="headerlink" title="hexo配置"></a>hexo配置</h2><p>主要是配置下github账户信息：</p>
<pre><code>deploy: 
     type: git 
     repo: https://github.com/用户名/用户名.github.io.git 
     branch: master
</code></pre><p>其他配置信息可以参考各个主题文档</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><p>用过material、yilla、next等，也用过自定义的主题，其实内容都是大同小异，主要就是_config.yml修改，插入图片，配置rss、评论、搜索、统计等信息。详细见各个主题Doc。</p>
<p>我最近使用的是material( <a href="https://mt.viosey.com/docs/#/" target="_blank" rel="external">Material Theme Doc</a> )，也是我推荐的。它的主题是简洁，看着很干净。</p>
<p>具体流程：</p>
<ul>
<li>安装主题</li>
<li>启用主题</li>
<li>主题配置</li>
</ul>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>在站点 _config.yml 中设置theme</p>
<h2 id="主题配置-1"><a href="#主题配置-1" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="头像等信息"><a href="#头像等信息" class="headerlink" title="头像等信息"></a>头像等信息</h3><h3 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h3><p>这块也是因主题而异。material主题只需要在post的md中首行添加</p>
<pre><code>categories:
  - 博客栈
</code></pre><h3 id="设置favicon"><a href="#设置favicon" class="headerlink" title="设置favicon"></a>设置favicon</h3><p>选择一个favicon制作网站完成制作，例如<a href="http://www.bitbug.net/" target="_blank" rel="external">比特虫</a>是一个免费的在线制作ico图标网站。</p>
<h1 id="插件第三方"><a href="#插件第三方" class="headerlink" title="插件第三方"></a>插件第三方</h1><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><ul>
<li><a href="http://www.tuicool.com/articles/m6bIJfq" target="_blank" rel="external">为Hexo博客添加版权说明和打赏功能</a> </li>
</ul>
<h2 id="添加canvas-nest特效"><a href="#添加canvas-nest特效" class="headerlink" title="添加canvas_nest特效"></a>添加canvas_nest特效</h2><ul>
<li><a href="http://tc9011.com/2017/02/02/hexo%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%95%88/" target="_blank" rel="external">hexo文章添加版权声明及一些特效</a> </li>
</ul>
<h2 id="algolia搜索"><a href="#algolia搜索" class="headerlink" title="algolia搜索"></a>algolia搜索</h2><ul>
<li><a href="http://www.jianshu.com/p/fa2354d61e37" target="_blank" rel="external">hexo+next添加algolia搜索</a></li>
<li>修改文章需要执行：<pre><code>hexo algolia
</code></pre></li>
</ul>
<h2 id="添加文章阅读量"><a href="#添加文章阅读量" class="headerlink" title="添加文章阅读量"></a>添加文章阅读量</h2><ul>
<li><a href="http://www.joryhe.com/2016-05-29-how_to_create_leancloud_read_Counter.html" target="_blank" rel="external">leanCloud,实现文章阅读量统计</a> </li>
</ul>
<h2 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h2><ul>
<li><a href="https://segmentfault.com/q/1010000008403584" target="_blank" rel="external">hexo主题下的开启打赏功能具体是怎么实现的呀？</a> </li>
</ul>
<h2 id="音乐外链"><a href="#音乐外链" class="headerlink" title="音乐外链"></a>音乐外链</h2><ul>
<li><a href="http://weqeo.com/2016/10/11/Hexo%E4%B8%AD%E6%92%AD%E6%94%BE%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%9A%84%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">Hexo中播放网易云音乐的实践</a> </li>
</ul>
<h2 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h2><ul>
<li><a href="http://blog.csdn.net/yingpaixiaochuan/article/details/68954103" target="_blank" rel="external">Hexo博客（Next主题）放弃多说，接入网易云跟贴</a></li>
</ul>
<h2 id="首页文章以摘要形式显示"><a href="#首页文章以摘要形式显示" class="headerlink" title="首页文章以摘要形式显示"></a>首页文章以摘要形式显示</h2><ul>
<li>打开<strong>主题配置文件</strong>，找到如下位置，其中<code>length</code>代表显示摘要的截取字符长度。修改<pre><code>auto_excerpt:
  enable: true
length: 150
</code></pre></li>
</ul>
<h2 id="设置首页文章显示篇数"><a href="#设置首页文章显示篇数" class="headerlink" title="设置首页文章显示篇数"></a>设置首页文章显示篇数</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><pre><code>  npm install --save hexo-generator-index
  npm install --save hexo-generator-archive
  npm install --save hexo-generator-tag
</code></pre><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><pre><code>index_generator:
  per_page: 5

archive_generator:
  per_page: 20
  yearly: true
  monthly: true

tag_generator:
  per_page: 10
</code></pre><h2 id="设置404公益页面"><a href="#设置404公益页面" class="headerlink" title="设置404公益页面"></a>设置404公益页面</h2><p>在<strong>站点目录</strong>的source文件夹下，新建<code>404.html</code>文件，将下面的代码复制进去保存即可。</p>
<pre><code class="html">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;404 - arao&#39;blog&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;404错误，页面不存在！&quot;&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;
    &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;http://qzonestyle.gtimg.cn/qzone_v6/lostchild/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="github-clone速度慢"><a href="#github-clone速度慢" class="headerlink" title="github clone速度慢"></a>github clone速度慢</h2><pre><code class="shell">git config --global http.postBuffer 524288000
</code></pre>
<h2 id="Hexo-Next的文章目录形式异常"><a href="#Hexo-Next的文章目录形式异常" class="headerlink" title="Hexo Next的文章目录形式异常"></a>Hexo Next的文章目录形式异常</h2><h3 id="反引号问题"><a href="#反引号问题" class="headerlink" title="反引号问题"></a>反引号问题</h3><p>用typora生成文章并传给next，中间需要注意的是代码注释段(反引号)，typora和next解析逻辑不一样，注意去掉反引号前面的空格,可以使toc匹配<br>如果去除反引号和上面的空行，可以使代码段格式和上面内容对齐</p>
<h3 id="Head错位"><a href="#Head错位" class="headerlink" title="Head错位"></a>Head错位</h3><p>比如上一层是H2，内部是H4，就会出现错位。</p>
<h2 id="Hexo-Next的文章不显示内容"><a href="#Hexo-Next的文章不显示内容" class="headerlink" title="Hexo Next的文章不显示内容"></a>Hexo Next的文章不显示内容</h2><p>引用中设置字体，会导致整个文档无法解析。</p>
<h2 id="Hexo-g-无法生成html"><a href="#Hexo-g-无法生成html" class="headerlink" title="Hexo g 无法生成html"></a>Hexo g 无法生成html</h2><p>排查发现对以下解析问题：</p>
<pre><code>`{{{ xxx }}}`
`{{* foo }}`
`{{ }}`
</code></pre><hr>
<p>基本这就是搭建一个github blog需要包括的内容了。当然，最快的方式也许是找一个官方demo直接clone修改配置。</p>
]]></content>
      
        <categories>
            
            <category> 博客栈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
